[{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた この記事 まえがき 私も未来のことを迷っているけど、でも生活がずっと続いているから、自分を変えなきゃね\n動画 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね\n未熟: みじゅく\nもう少しで私は未熟な大人に　なるみたいです\nなんか笑っちゃうね\n本当はね\nもっと前を向けるようなうたを　書くつもりだったけど\n書けなくて\n私はまだ　他の誰かを支えられるほど\n強くなかったみたい　ごめんね\n拝啓　未来の私へ　今そこで\nどんなことをして　生きていますか\n拝啓　今の私へ　今ここで\nどんなことをしたら　生きていけるんでしょうか\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\nどうせだったらもうちょっと　貴方みたいに\nやさしいうたを書けばよかったね\n本当はね　好きなことだけして生きたいの\nでもそれは上手な生き方とは言えないから\n無駄になっても　意味がなくても\n今はここから　離れなきゃいけないの　ごめんね\n拝啓　未来の私へ　今そこで\nどんな大人になって　生きていますか\n拝啓　今の私へ　今ここで\nどんな大人になりたいと　言えばいいんでしょうか\n「さよなら」は悲しくなるからさ\n「またね」って言わせて\nいつか私が　今みたいな　うたを書けなくなっても\n怒らないでね\n拝啓　過去の私へ　今の私は\nずっと夢見ていたこと叶えてるよ\n拝啓　今の私へ\nこんな情けない　うただって歌えばいいよ\n情け: なさけ\nそれが私だから\n拝啓　未来の私へ　今そこは\nどんな綺麗な世界が　広がっていますか\n拝啓　今の私へ　今ここが\nどんな世界よりも　幸せでした\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\nこれから私は未熟な大人に　なる準備をします\n「じゃあ またね」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/ja/archives/224/","title":"歌から日本語を学ぼう - 《17さいのうた》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り この記事 17さいのうた https://blog.yexca.net/ja/archives/224 まえがき 甘い曲だよねー\n動画 歌詞 ハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\n出会っちゃった！\nときめいちゃった？ ときめく\n私だけ？ドキドキしてるの\nちゃんと気にかけて\n私だけ！甘やかして\n(Ah)　君と話す理由欲しくて探している\n(なんで？)　強がっていても恋に負けちゃうんだね\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n取られたくないんだよ…\n誰よりも可愛くなりたい\n完全勝利して\n私だけって言わせてやる！\n(Ah)　君の胸を狙う私の恋の銃口\n(なんで？)　震えちゃうんだろう\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\nせーっの！BANG\n期待させてよ\nもっともっともっと\n私浮ついちゃって 浮つく: うわつく\nバカだバカだごめん\nハートは忙しくて\nあっちこっちどっちー？\n今はまだまだプロローグ\n押して押して押すの\n私、君に出会えて変わったの！\nそりゃあ悩んじゃう事もあるけど…\nもっともっと可愛くなりたいって思うし\n何より君に好きって言ってもらいたい！\n笑顔の私(可愛い)\n泣いちゃう私(可愛い)\n怒った私(可愛い)\n恋する私…\n甘えさせてよ\nずっとずっとずっと\nきっと後悔させない\nお願い　好きになって\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/ja/archives/220/","title":"歌から日本語を学ぼう - 《恋の押し売り》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと この記事 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 まえがき また歌詞だけ書こう、次回何か日本語で感想を書くほうがいいかな。\n動画 歌詞 何をしても不器用で　何かとミスしてばっか\nダメダメな私だって\nできる事があるの\n凹んで悲しくたって　笑顔にしてあげるんだ\nここにいるから　早く　私を見つけてね\nLove You Love You, I love you\nLove You Love You, Ah,I love you so much\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nいつでも隣にいるし、いつでも一緒に笑える\n私をたくさん知って　たくさん好きって言って\nワガママで朝も苦手　ドジだし　ダメダメだけど\nそれでも私の事を　見ててね\n描く夢の未来へ続く\n道をキミと歩けますように\nねぇもっと！好きになってもらいたいの！\n頭の中は君ばっか！\nってゆーかそっぽなんて向いてないで！\nあぁもう！ヤキモキしちゃうわ　Ah\nずっとずっと好きがいいの\n心の奥もトキメイちゃうくらい\nこっち向いててよね　ダーリン？\nあぁもう離さないから、絶対に！\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nキミがいるから私　いつでも頑張れるんだ\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\nキミがいるから　歩いてこれた\nキミがいなくちゃ　前も見れない\n嫌な事とか辛い事とかあったって\nキミの力でここまで笑ってこれたんだ\n今度はもっと私がぐっとひっぱって　連れて行くんだ\nキミがいるから私がいるの\nこんな私を　愛してくれる？\nねぇもっと　ねぇもっと\nまだもっと　受け止めてよね！ねぇいい？\nさぁ声を上げて！\nねぇもっと　ねぇもっと\n好きになってもらいたいの\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\nね、ほら夢中にしちゃうわ　Ah\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\nこっち向いててよねダーリン?\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n（あぁ 愛してもっと）\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/ja/archives/219/","title":"歌から日本語を学ぼう - 《あくあ色ぱれっと》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは この記事 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 まえがき てっ、この記事は日本語なので、もう日本語の勉強じゃない？書く必要がないかもね\nまあ、とりあえず歌詞を書こうかな\n動画 歌詞 僕が死のうと思ったのは　ウミネコが桟橋で鳴いたから\n桟橋: さんばし\n波の随意に浮かんで消える　過去も啄ばんで飛んでいけ\n啄ばむ: ついばむ\n僕が死のうと思ったのは　誕生日に杏の花が咲いたから\n杏: あんず\nその木漏れ日でうたた寝したら　虫の死骸と土になれるかな\n木漏れ日: こもれび　死骸: しがい　土: つち\n薄荷飴　漁港の灯台　錆びたアーチ橋　捨てた自転車\n薄荷: はっか　漁港: ぎょこう　灯台: とうだい　錆びる: さびる\n木造の駅のストーブの前で　どこにも旅立てない心\n旅立つ: たびだつ\n今日はまるで昨日みたいだ　明日を変えるなら今日を変えなきゃ\n分かってる　分かってる　けれど\n僕が死のうと思ったのは　心が空っぽになったから\n満たされないと泣いているのは　きっと満たされたいと願うから\n僕が死のうと思ったのは　靴紐が解けたから\n靴紐: くつひも　解ける: ほどける\n結びなおすのは苦手なんだよ　人との繋がりもまた然り\n然り: しかり\n僕が死のうと思ったのは　少年が僕を見つめていたから\nベッドの上で土下座してるよ　あの日の僕にごめんなさいと\nパソコンの薄明かり　上階の部屋の生活音\n薄上がり: うすあがり\nインターフォンのチャイムの音　耳を塞ぐ鳥かごの少年\n鳥かご: とりかご\n見えない敵と戦ってる　六畳一間のドンキホーテ\n一間: ひとま\nゴールはどうせ醜いものさ\n醜い: みにくい\n僕が死のうと思ったのは　冷たい人と言われたから\n愛されたいと泣いているのは　人の温もりを知ってしまったから\n温もり: ぬくもり\n僕が死のうと思ったのは　あなたが奇麗に笑うから\n死ぬことばかり考えてしまうのは　きっと生きる事に真面目すぎるから\n僕が死のうと思ったのは　まだあなたに出会ってなかったから\nあなたのような人が生まれた　世界を少し好きになったよ\nあなたのような人が生きてる　世界に少し期待するよ\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/ja/archives/214/","title":"歌から日本語を学ぼう - 《僕が死のうと思ったのは》"},{"content":" この記事の一部は機械翻訳を使ってるよ\nまえがき 今日は最近設計した半透明、すりガラスと丸みを帯びた角についてまとめようと思っていたけど、突然2023年12月01日何かを作ったことを思い出したので、それも一緒に再編成しようと思う\nウェブサイトの背景 現代の (アニメ風) ウェブページは背景が必要だ\nbody{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 繰り返さない */ padding: 0; margin: 0; } 半透明とすりガラス そして、背景にマスクを加えて、半透明効果とすりガラス効果を実現する\n.layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景ぼかし効果 */ -webkit-backdrop-filter: blur(2px); /* Safari サポート */ background: rgba(0, 0, 0, 0.4); /* 半透明黒い背景 */ } ウェブページのリニューアル そういえば、文章を書くのは面倒だな。プログラムしていると邪魔されて、プログラムが終わった時はとても疲れてしまったので、書きたくなくなった。だから今は気軽に文章を書いている\nプロジェクトのリング: https://github.com/yexca/MusicPlayer-Twinkle 顺便更新了下之前的文章 https://blog.yexca.net/archives/116/ 用此方法加了个示例: https://twinkle.yexca.net ところで、以前の文章も更新したよ (簡体字中国語で) https://blog.yexca.net/archives/116/ その方法で例を作った: https://twinkle.yexca.net カード効果 これも現代的な設計だよねー\n.card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白い背景 */ border-radius: 15px; /* 丸みを帯びた角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 影 */ backdrop-filter: blur(10px); /* 背景ぼかし効果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* ボーダー */ color: pink; /* 文字の色 */ } まあ、時間があればカードのデザインを基にしてプロジェクトを進めよう (また新しい沼にハマっちゃった)\nTwinkle ちなみに、プロジェクトの内容は Twinkle の音楽、詳しくはこちら\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/ja/archives/212/","title":"すりガラス効果"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGo バックエンドのシンプルな (非技術的なフレームワーク) 実装\n~~皆さんご存知のとおり、~~バックエンド開発は一般的にインターフェース指向開発、つまり CRUD エンジニアです。この記事では、Go を使用して、データベースからデータを読み取り、JSON データを返す方法について説明します。\nデータベース この例では、MySQL データベースのカテゴリ テーブルからカテゴリ名と ID を読み取ります。テーブル構造は次のとおりです。\nDROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; プロジェクト構造 この例のプロジェクト構造は次のようになります。\nproject/ ├── database/ // データベースパッケージ │ └── database.go // データベース接続 ├── handler/ // ハンドラパッケージ │ └── category.go // カテゴリ関連のインターフェース ├── model/ // データモデルパッケージ │ ├── category.go // カテゴリテーブルモデル │ └── response.go // レスポンスデータモデル ├── router/ // ルーティングパッケージ │ └── router.go // ルーティング設定 ├── utils // ツールキット │ └── response.go // 統合レスポンス ├── main.go // プログラムエントリ 次にディレクトリについて説明します\ndatabase このパッケージはデータベースへの接続を管理します\n// database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;Failed to open database: %v\u0026#34;, err) } // Test Connect err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;Failed to ping database: %v\u0026#34;, err) } fmt.Println(\u0026#34;Successfully connected Database!\u0026#34;) } handler このパッケージは、特定の処理のロジック（3 層アーキテクチャの service に似ています）を処理して、データベース処理も階層化できます（Mapper に似ています）が、これは単なる簡単な例です、それだけです〜\n// category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // Select Database rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;Failed to query Categories\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // analyze data var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;Failed to analyze Categories\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // return JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } コメントアウトされた内容は統合レスポンスインターフェースには適用されず、JSON が直接返されます。\nmodel ここでのデータモデルは、一般的にフロントエンドから受け取るもの、データベースから受け取るもの、フロントエンドに返すものの 3 つに分けられます。これは単純な例なので、細かくは説明していません。\n// category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 応答のデータモデルは\npackage model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router このパッケージはルーティング、つまり、どのパスにアクセスして対応する処理ロジックを指定するかを管理します（3 層アーキテクチャの controller に似ています）\n// router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils このパッケージはツールクラスであり、一般的なツールを定義するために使用されます\n// response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main プログラムエントリー\n// main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // init Database database.InitDB() // Init Router r := router.InitRouter() // start log.Println(\u0026#34;Starting server on port 8848\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } go run main.go を実行すると、プログラムはポート 8848 をリッスンします。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/ja/archives/208/","title":"GoLang バックエンドを使い始める"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: この記事\nゴルーチン (Goroutine) は channel を通じてデータを転送できます。参照型 channel は複数の Goroutine が通信するために使用できます。同時実行の安全性を確保するために、内部で同期を実装します。\nこれは、 RabbitMQ (簡体字中国語) に似ています (これは学習に便宜上の例えです、実は異なるものです)\n変数を定義する channel は参照型です。関数をコピーまたは呼び出すと、同じ channel オブジェクトが参照されます。ゼロ値は nil です。\nmake() 関数によって作成される。例えば\nc := make(chan int) // 容量を 3 に追加 c := make(chan int, 3) 容量が 0 の場合、channel はバッファリングされず、読み取りと書き込みがブロックされます。 容量が 0 より大きい場合、キャッシュがあり、非ブロッキングであり、いっぱいになるまでブロックされません。\nデータの送受信には \u0026lt;- を使用します\n// channel にデータを送信する channel \u0026lt;- 3 // 受信して破棄 \u0026lt;-channel // スペースがないことに注意してください // 値を受け取って変数に割り当てる x := \u0026lt;-channel // 受信して変数に割り当て、受信が成功したかどうか（channel が空かどうか）を判定します data, flag := \u0026lt;-channel バッファリングなし package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A running\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main over\u0026#34;) } バッファリング package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A over\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A goroutine, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main over\u0026#34;) } channel を閉じる close() で閉じる\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 閉じる close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main Finished\u0026#34;) } range の使用 上記の main の for ループは、range を使用して短縮することができます。\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 一方向 channel デフォルトでは、channel は双方向、つまり読み取りと書き込みが可能です。チャネルの方向を読み取り専用または書き込み専用に指定することもできます。\nvar c chan int // 通常の双方向チャネルを宣言する // c1 は書き込みのみ可能 var c1 chan\u0026lt;- int // c2 は読み取り専用です var c2 \u0026lt;-chan int 双方向チャネルを一方向チャネルに変換することは可能ですが、その逆はできません。つまり、関数パラメータを一方向として定義し、それを双方向に渡すことができます。\n// chan\u0026lt;- // 書き込みのみ func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 相手が読んでいない場合はブロックします } } // \u0026lt;-chan // 読み取り専用 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 双方向 go counter(c) // プロデューサー printer(c) // 消費者 fmt.Println(\u0026#34;done\u0026#34;) } select select は複数の channel 上のデータ フローを監視できます。構文は switch に似ていますが、各 case ステートメントには IO 操作が含まれている必要があります。\n通常は for{} コードブロック内に置く\npackage main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return // デフォルトを設定することもできますが、この例では不要です } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/ja/archives/207/","title":"GoLang チャンネル"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: この記事\nGoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 プロセス -\u0026gt; スレッド -\u0026gt; コルーチン\nコルーチン (coroutine) は軽量スレッドとも呼ばれます。システム リソースを使い果たすことなく、数万のコルーチンを簡単に作成できます。複数のコルーチンは、スレッドに割り当てられたコンピューター リソースを共有します。\nGo 言語は、ゴルーチン (goroutine) と呼ばれるコルーチンをネイティブにサポートしています。Go の並行性は、goroutine と channel を通じて実装されます。\ngoroutine を作成する go キーワードでゴルーチンを開始する\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 匿名関数の使用 もちろん、匿名関数を使用することもできます\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名関数は戻り値に実体パラメータを持つこともできますが、goroutine の戻り値は channel を介して送信する必要があります。次の例では、実体パラメータのみを示しています。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 退出 メインの goroutine が終了すると、他の動作中の goroutine も自動的に終了します。\nただし、runtime.Goexit() を使用して、現在の goroutine の実行を直ちに終了することもできます (defer が実行されます)\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // ゴルーチンを終了する fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 出力 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/ja/archives/206/","title":"GoLang ゴルーチン"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: この記事\nGoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 構造タグはパッケージ内のクラスの役割を記述するために使用できます。\nタグの値を取得する tag を定義するには ` を使用します (markdown コードブロックのキー)\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 複数の tag はスペースで区切られます name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 変換 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // パブリックプロパティのみが JSON に変換できることに注意してください Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/ja/archives/205/","title":"GoLang 構造タグ"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: この記事\nGoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 反射指の一種の用途であり、自己記述と自己制御が可能です\npair Go 言語变量には type と value の部分が含まれ、pair で構成されます\nstatic type はコード実行時に見られるタイプであり、concrete type は runtime システムに見られるタイプです。\nこのタイプは、static type ではなく変数の concrete type に応じて成功するかどうかを判断します。したがって、concrete type が write メソッドの命令も実装している場合、タイプは write として承認される可能性があります。\n反射はタイプに基づいて確立され、静的タイプであり、固定されているため、反射は主に interface タイプに関係します (concrete type)\npackage main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // r のタイプは Book であるため w.Write() } TypeOf と ValueOf Reflect.TypeOf() は pair 中の type を取得します、reflect.ValueOf() は pair 中の value を取得します\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 型转换 reflect.ValueOf() を実行すると、型が reflect.Value 变量になります。\n既知原データの種類 既知原データ型は直接强制转换可能\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 型変換は完全に一貫している必要があることに注意することが重要です。そうでないと、ポインタなどの panic が発生します。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 輸送先住所 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 型をポインタに変換する newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } つまり、反射することができます \u0026ldquo;反射型オブジェクト\u0026rdquo; 再再再转换は \u0026ldquo;インターフェース変数\u0026rdquo;\n未知原データ型 Field を横断して取得\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行は 1 つの field です Name string Age int Rank float64 } // メソッドはパブリックであることに注意してください。プライベートの場合はアクセスできません。 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 属性を取得します numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // メソッドを取得します numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } reflect.Value による割り当て package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // ポインタの場合のみ割り当て可能 pointer := reflect.ValueOf(\u0026amp;a) // 元の値を取得するためのアドレスを設定します newValue := pointer.Elem() // 値が設定可能かどうかをチェックする fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 設定できる場合 newValue.SetFloat(9.96) // 変数の値を表示 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } reflect.Value 経由でメソッドを呼び出す 関数名による呼び出し\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 関数名で呼び出す method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // ビルドパラメータ args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 関数の呼び出し method1.Call(args1) // パラメータなしで呼び出す method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } リフレクションの基本原則 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/ja/archives/204/","title":"GoLang リフレクション"},{"content":"問題一：この記事\n問題二 (簡体字中国語)： https://blog.yexca.net/archives/201 問題三 (簡体字中国語)： https://blog.yexca.net/archives/200 問題四 (簡体字中国語)： https://blog.yexca.net/archives/202 問題五 (簡体字中国語)： https://blog.yexca.net/archives/203 まえがき この記事は初めて母国語じゃない言語で書いて、他の記事を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、記事の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}{ \\log_e(2x+3)-\\log_e(x) }$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$ a=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2 $$\nb\n$$ \\because when \\space x \\to 0 ,\\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space and \\space sinx \\sim x \\ \\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2} $$\nc ロピタルの定理を用いて\n$$ \\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+sinx}{1}=3 $$\n2 以下の実行列の積の行列式を計算せよ。\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} \\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nThe determinant of the product of two matrices is the product of their determinants\nFor A\n$$ A=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} $$\nThe determinant of A\n$$ \\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix} 2 \u0026amp; 1 \\ 3 \u0026amp; 2 \\end{vmatrix} -0+0 =1 $$\nFor B\n$$ B=\\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nThe determinant of B\n$$ \\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix} 11 \u0026amp; 11 \\ 4 \u0026amp; 5 \\end{vmatrix} -0+0 = 341 $$\nso\n$$ \\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341 $$\n3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$ F_X(x)=\\left { \\begin{matrix} -4x\\log_e(x) \u0026amp; 0 \\lt x \\le 1 \\ 0 \u0026amp; x \\le 0 \\space または \\space x \\gt 1 \\end{matrix} \\right . $$\nまずは、累積分布関数を考えて\n$x \\le 0$ $$ F_X(x) = 0 $$\n$x\\gt 1$ $$ F_X(x) = 1 $$\n$0 \\lt x \\le 1$ $$ \\begin{align} F_X(x) \u0026amp;= \\int_0^x(-4t\\log_e(t))dt \\ \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u = \\ln t \u0026amp; dv=4tdt \\ du = \\frac{1}{t}dt \u0026amp; v=2t^2 \\end{matrix} $$\nしたがって\n$$ \\begin{align} F_X(x) \u0026amp;=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\ \u0026amp;=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\ \u0026amp;=-( 2x^2\\ln x - t^2\\mid_0^x ) \\ \u0026amp;=x^2 - 2x^2\\ln x \\end{align} $$\nこれより\n$$ F_X(x)= \\left { \\begin{matrix} 0 \u0026amp; x \\le 0 \\ x^2-2x^2\\ln x \u0026amp; 0 \\lt x \\le 1 \\ 1 \u0026amp; x \\gt 1 \\end{matrix} \\right . $$\n次に、分散を求める。分散の定義は\n$$ V(X)=E[X^2] - (E[X])^2 $$\n期待値 $E[X]$ を計算する\n$$ \\begin{align} E[X] \u0026amp;= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\ \u0026amp;= \\int_0^1x(-4x\\ln x)dx \\ \u0026amp;= -\\int_0^1 4x^2\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=4x^2dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{4}{3}x^3 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X] \u0026amp;= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\ \u0026amp;= -(-\\frac{4}{9}x^3\\mid_0^1) \\ \u0026amp;= \\frac{4}{9} \\end{align} $$\n$E[X^2]$ の計算\n$$ \\begin{align} E[X^2] \u0026amp;= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\ \u0026amp;= \\int_0^1x^2(-4x\\ln x)dx \\ \u0026amp;= -4\\int_0^1x^3\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=x^3dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{1}{4}x^4 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X^2] \u0026amp;= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\ \u0026amp;= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\ \u0026amp;= \\frac{1}{4} \\end{align} $$\nだから\n$$ \\begin{align} V(X) \u0026amp;= E[X^2] - (E[X])^2 \\ \u0026amp;= \\frac{1}{4} - (\\frac{4}{9})^2 \\ \u0026amp;= \\frac{17}{342} \\end{align} $$\n4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n不良品である確率：$P(A)=\\frac{1}{1000}$、不良品と判定する確率：$P(B)$\nこれより\n$$ \\begin{matrix} p(\\bar{A})=\\frac{999}{1000} \u0026amp; P(B\\mid A)=\\frac{99}{100} \u0026amp; P(B\\mid \\bar{A})=\\frac{1}{5} \\end{matrix} $$\nしたがって\n$$ P(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000} $$\nベイズの定理を用いると\n$$ P(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079} $$\n以上より、不良品である確率は $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：ポケットAにボールが入る確率は他のポケットと同じである。すなわち\n$$ P(A)=\\frac{1}{4} $$\n$H_1$ ：ポケットAにボールが入る確率は他のポケットより高い。すなわち\n$$ P(A)\\gt \\frac{1}{4} $$\nボールはポケットAに4回入る確率は\n$$ P(X=4)=(_4^5) (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024} $$\nボールはポケットAに5回入る確率は\n$$ P(X=5)=(_5^5) (\\frac{1}{4})^5=\\frac{1}{1024} $$\nこれより\n$$ P(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64} $$\nこの確率は有意水準より小さいため、帰無仮説を棄却する。ゆえに、「このルーレットはボールがポケットAにより入りやすい」という仮設は統計的に有意であると言えます。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/198/","title":"科学大院理工学 2020 問題一"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 n クイーン問題は、n 行 n 列のチェス盤に n 個のクイーンを配置し、クイーン同士が攻撃できないようにすることです。ルールは、2 個のクイーンが同じ行、列、または対角線上にないことです（つまり、 、チェスのクイーンの移動範囲）\n問題分析 n クイーン問題を解決するために、次のアイデアが提案されています。\ni 番目のクイーンは i 番目の列に置かれる\n最初のクイーンから始めて、各クイーンについて、対応する行の最初の列から試します（i番目のクイーンはi番目の行に対応します） 配置できる場合は位置を決定し、次のクイーンを検討します 前の女王と衝突する場合は、次の列を考慮する 最後の列を超えた場合は、前のクイーンの位置が再決定されます。\nすべての配置ソリューションが見つかるまでこのプロセスを繰り返します。\nC コード #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // クイーンの数 // k 番目のクイーンの現在の位置が前のクイーンと競合するかどうかを判定する int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初期化の位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // i 番目のクイーンを配置してみて while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 配置計画を取得する } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 次のクイーンを考えてみよう if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 前のクイーンについて考えるために戻る pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/ja/archives/176/","title":"n-クイーン問題のアルゴリズム（バックトラッキング）"},{"content":"導入 卒業論文は面倒くさいな、この記事はいつか書いたのでしょうか。ファイルは 2023-11-30 に作成されたけど、2022.09.18 に変更されて、わからなくて、ショックを受けた\nコード \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 06, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 呼び出し 使いたいところで以下のコードを入れる\n\u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 参考資料 个人博客添加运行时间 - 腾讯云开发者社区-腾讯云 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/ja/archives/172/","title":"ブログ実行時間"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: この記事\nGoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 造を使用してクラスとオブジェクトの概念を構築する\nオブジェクト指向を理解する: オブジェクト指向の基礎(簡体字中国語だけど) struct まずは、C に似た type キーワードを使用したカスタム型です。\npackage main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 出力 * a = 0 * type of a is main.myTye */ stuct を使用して型を定義する\npackage main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 関数転送は関連しており、ポインタは使用されず、値の転送です\npackage main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 値の転送、元のデータは変更されません func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 参照を渡すと元のデータが変更されます func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } カプセル化 package main import \u0026#34;fmt\u0026#34; // クラス type Person struct { // プロパティ name string age int } // クラスメソッド func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } クラス名とメソッド名の最初の文字が大文字になっていることに注意してください。これは、クラスとメソッドが他のパッケージからアクセスできることを意味します (java public)。最初の文字が小文字の場合は、このパッケージからのみアクセスできます (java private) プロパティについても同様です。\n継承 次のコードは同じファイル、親クラスにあります\n// 親クラス type Person struct { name string age int } // 親クラスのメソッド func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } サブクラス\n// サブクラス type SuperMan struct { Person // 親クラスから継承 level int // サブクラス属性 } // サブクラスは親クラスのメソッドをオーバーライドします func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // サブクラス固有のメソッド func (this *SuperMan) Fly() {} main 関数\nfunc main() { // サブクラスの属性を定義する、方法 1 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // サブクラスの属性を定義する、方法 2 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 同じパッケージ内にあるため、親クラスの属性にアクセスできます superMan2.age = 20 superMan2.level = 5 // サブクラスは親クラスのメソッドを呼び出す superMan1.Eat() // サブクラスのオーバーライドメソッド superMan1.Walk() // サブクラスメソッド superMan2.Fly() } 多態性 次のコードは同じファイルにあり、インターフェースを定義しています\n// インターフェース、基本的にはポインタ type Animal interface { Sleep() GetName() string GetType() string } 実装クラス 1\n// 実装クラス 1 type Cat struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 実装クラス 2\n// 実装クラス 2 type Dog struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\nfunc ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } ユニバーサル型とアサーション package main import \u0026#34;fmt\u0026#34; // ユニバーサルデータ型を表すために空のインターフェースを使用する func f(arg interface{}) { // 型アサーションメカニズム (つまり型変換) value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // カスタムを含む任意のデータ型を渡すことができます f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 出力 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/ja/archives/162/","title":"GoLang オブジェクト指向"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: この記事\nGoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のスライスは配列の抽象化である\n配列 配列の長さは変更できません\npackage main import \u0026#34;fmt\u0026#34; func main() { // 定義方法 1 var arr1 [10]int // トラバース for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方法 2、代入 arr2 := [10]int{0, 1, 2, 3} // range トラバーサル for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 異なる長さを定義する var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } コンパイルして実行すると、arr3 が arr1 および arr2 とは異なる型であることがわかります。そのため、関数パラメータを定義するときにも対応する型を指定する必要があります。\nfunc test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上記の関数は arr3 を値で渡すことしかできず、値を変更しても元のデータには影響しません。\nスライスを定義する 配列と比較すると、スライスは固定長ではなく、要素を追加することができます（動的配列）。追加するとスライスの容量が増加する可能性があります。\nスライスは、サイズが指定されていない配列を宣言することによって定義できます。\nvar name []type // 例えば var s []int または make() 関数を使用してスライスを作成する\nvar slice []type = make([]type, len) // len はスライスの初期の長さです // 次のように省略することもできます slice := make([]type, len) オプションの capacity パラメータを使用して容量を指定できます。省略した場合は、length と同じになります。\nvar slice []type = make([]type, length, capacity) スライスの初期化 直接初期化\ns := []int {1, 2, 3} 配列の値を startIndex から endIndex-1 までのスライスとして初期化します。両方の値は省略できます。\ns := arr[startIndex:endIndex] startIndex または endIndex を省略すると、最初の要素からインデックス付けするか、最後の要素までインデックス付けすることを意味します。\nlen() と cap() スライスはインデックス可能であり、その長さは len() 関数を使用して取得できます。\ncap() は容量を計算するメソッドであり、スライスが到達できる長さを測定できます。\npackage main import \u0026#34;fmt\u0026#34; // スライス渡しは参照渡しであり、関数内の変更は元のデータに影響します func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 出力 * len=3, cap=5, slice=[0 0 0] */ 空のスライス スライスは初期化前はデフォルトで nil (空のスライス) であり、その長さは 0 です。\npackage main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 空かどうか確認する if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } スライスインターセプション 上限と下限を設定してスライスをカットする\npackage main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 元のスライスを印刷する fmt.Println(s) // 2(含む) から 5(含まない) まで printSlice(s[2:5]) // 1 番目から 5 まで (含まない) printSlice(s[:5]) // 2 番目から最後まで printSlice(s[2:]) // この割り当てと subS の変更は s に影響します subS := s[1:6] printSlice(subS) } append() と copy() スライスの容量を増やし、スライスをコピーする\npackage main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 要素を追加する s = append(s, 0) printSlice(s) // 複数の要素を追加する s = append(s, 1, 2, 3, 4) printSlice(s) // s の 2 倍の容量を持つ s2 を作成します s2 := make([]int, len(s), cap(s)*2) // s を s2 にコピーします。s2 を変更しても s には影響しません。 copy(s2, s) printSlice(s2) } スライス拡張: 追加された値が容量を超える場合、容量は2倍になります\nmap map を宣言する方法は 2 つあります\npackage main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // データを挿入 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 2 番目\npackage main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map のネスト package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 出力 * map[first:map[one:1 two:2]] */ トラバーサルを変更して削除する package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 改訂 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // トラバース for key, value := range map1{ fmt.println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 消去 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 特定の値があるかどうかを判定する package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, key := map1[\u0026#34;one\u0026#34;] if key { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/160/","title":"GoLang スライス"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: この記事\nGoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 複数の戻り値 Go 関数は複数の値を返すことができる\n匿名の戻り package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 出力 * 20 10 */ パラメータ名を返す package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上記の戻り値は同じ型であり、組み合わせることができる\npackage main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不给 x,y 赋值，默认为0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init と main init はどのパッケージにも、あるいは同じパッケージに複数回出現することができますが、1 つだけ記述することをお勧めします。\nmain は package main 内にのみ存在でき、パッケージにはこの関数がなければなりません。\nこれら 2 つの関数は予約関数であり、定義時にパラメーターや戻り値を持つことはできません。\nGo プログラムは自動的に init() と main() を呼び出す\nプログラムの実行 プログラムの初期化と実行はすべて main パッケージから始まります。同じパッケージが複数のパッケージでインポートされた場合でも、インポートされるのは 1 回だけです。次の図は実行順序を示しています。\n例\n次の構造を想定する\nhello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 内容は以下のとおりです\nlib1.go\npackage InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\npackage InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\npackage main import ( \u0026#34;fmt\u0026#34; // ここでのアンダースコアはパッケージの別名です。別名でない場合はインポートは呼び出されず、コンパイルは成功しません。 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 運用結果\nlib1 init lib2 init main init main Lib1 パッケージを Lib2 にインポートすると、main コードは変更されません。\nlib1.go\npackage InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main 結果を実行\nlib2 init lib1 init main init main lib2 は 1 回だけ出現する\n他のパッケージ関数を呼び出す 上記の例では、エイリアスとして _ を使用していますが、これは匿名であり、対応するパッケージ メソッドを呼び出すことはできません。\nlib1 に関数を追加する\nlib1.go\npackage InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 他のパッケージから呼び出す前に、最初の文字を大文字にする必要があります func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\npackage main import ( \u0026#34;fmt\u0026#34; // パッケージにエイリアスを付ける mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // alias.method 経由で呼び出す mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 出力 * lib1 init * lib2 init * lib1 test * main */ または . を直接使用して\nmain.go\npackage main import ( \u0026#34;fmt\u0026#34; // エイリアスが . に変更されました。 . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用する Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 推奨されません。 2 つのパッケージに同じ名前の関数がある場合、あいまいさが生じます。\nポインタ C ポインタに似ている\n数を呼び出すときにパラメータを渡す方法は、値渡しとポインタ（参照）渡しの 2 つがあります。デフォルトでは、この記事の最初のコードのように値の受け渡しが使用されます。\n変数に対応するメモリアドレスを取得するには \u0026amp; を使用します\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 参照渡しはメモリアドレスを関数に渡し、関数の変更は実際のパラメータに影響します。これはスワップ関数でもあり、今回はポインタを使用しています。\npackage main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer ステートメントは、遅延関数と呼ばれる関数の呼び出しをスケジュールするために使用されます。その機能は次のとおりです。\n占有されているリソースを解放する 例外をキャッチして処理する 出力ログ try\u0026hellip;catch\u0026hellip;finally の finally に似ています\nファイルのオープン/クローズ、ロックの取得/解放、接続/切断などのペア操作を処理するためによく使用され、エラーや早期復帰が発生した場合でもリソースが適切に解放され、実行が保証されます。\n関数内に複数の defer ステートメントがある場合、それらはスタックと同様に LIFO (後入れ先出し) の順序で実行されます。\npackage main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 出力 * 4 * 3 * 2 * 1 */ recover ランタイム パニック例外がトリガーされると、プログラムはクラッシュします。recover は、例外をキャプチャする Java の try\u0026hellip;catch と同様に、ランタイム パニックを「インターセプト」するために使用される組み込み関数です。\nrecover は defer によって呼び出される関数内でのみ有効です\npackage main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // エラーインターセプションはエラーの前に設定されます defer func() { // エラーメッセージを傍受するように recover を設定する err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 出力 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/ja/archives/156/","title":"GoLang 関数"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: この記事\nGoLang (func) 関数: https://blog.yexca.net/archives/ja/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 変数 変数は通常 var キーワードを使用して宣言されます\n単一変数 タイプを定義する 初期値が指定されていない場合、デフォルトは 0 です。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 初期値を指定します。a は 100 です。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略タイプ 宣言時に型がわからない場合、Go は変数の型を自動的に決定します。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 省略に応じて型が自動的に決定され、:= を使用して変数を直接宣言できます。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 出力 * p = 3.14 * Type of p is float64 */ 多変量 同じタイプ package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 同じタイプの割り当て package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 異なるタイプ 1 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 出力 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 異なるタイプ 2 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } Go の文字列型は、基になる配列へのポインタと長さを含む構造体です。これら 2 つの部分はそれぞれ 8 バイトなので、文字列型のサイズは 16 バイトになります。\nunsafe.Sizeof()関数を使用して、タイプ占有率が見られます。\nグローバル変数 グローバル変数は := を使用して宣言することはできません\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } または、グローバル変数に一般的に使用される分解を使用します。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 定数 定数は通常、const キーワードを使用して定義されます。\n定義 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } タイプを省略することもできます\npackage main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列挙 定数定義は列挙に使用できる\npackage main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自己増加 上記の列挙は 0 から始まり、増分で増加します。代わりに iota を使用できます。\npackage main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota は式の中で使用できますが、通常は自動増分に使用されます\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/ja/archives/155/","title":"GoLang 変数と定数"},{"content":" この記事の一部は機械翻訳を使ってるよ\nGolang シリーズ\nHello GoLang: この記事\nGoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のダウンロード： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go の紹介 Go は直接コンパイルして直接実行し、デプロイできる静的型付け言語です。\n# 直接実行 go run hello.go # コンパイル go build hello.go # コンパイル後に実行 ./hello Go の応用例\n(1)、クラウドコンピューティングインフラ\n代表的なプロジェクト：docker、kubernetes、etcd、consul、cloudflare CDN、\u0026ldquo;七牛云存储(中国語)\u0026ldquo;など\n(2)、基本的なバックエンドソフトウェア\n代表的なプロジェクト：tidb、influxdb、cockroachdb など\n(3)、マイクロサービス\n代表的なプロジェクト：go-kit、micro、monzo bank的typhon、bilibili など\n(4)、インターネットインフラ\n代表的なプロジェクト：Ethereum、hyperledger など\nHello Go package main // パッケージ名を定義する /* * ソースファイルの最初の非コメント行で、ファイルが属するパッケージを指定する必要があります。 * main は独立して実行可能なプログラムを表します。すべての Go アプリケーションには、main という名前のパッケージが含まれています。 */ import \u0026#34;fmt\u0026#34; // IO フォーマットの関数を実装するために fmt パッケージをインポートします func main(){ // 関数 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般的に、main 関数は起動後に最初に実行される関数です。init関数がある場合は、init 関数が最初に実行されます。\n関数を定義するときは { が関数名と同じ行になければなりません\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/ja/archives/154/","title":"Hello GoLang"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 ある会社が長い鉄棒を購入し、それを切断して販売します。鉄筋を切断するコストはごくわずかで、鉄筋の長さはインチです。価格表 $p$ が与えられます。ここで、 $p_{i}(i=1,2,\\cdots,m)$ は長さ $i$ インチの鉄棒の価格を表します。今、売上収益を最大化するカット計画を見つける必要があります。\n問題分析 長い鋼棒の長さが $n$ インチで、最適な切断計画の左端の切断セグメントの長さが $i$ インチであると仮定して、残りの鋼棒の長さに対する最適な切断計画を解き続けます。 $m-1$ インチ。すべての可能な $i$ を考慮すると、最大の利益 $r_{n}$ に対応する伐採計画が最適な伐採計画となります。 $r_{n}$ の再帰定義は次のようになる。\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$\nC コード この問題には2つの解決策があります\n(1) 分割統治法（上から下まで） int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大値 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間計算量 $O(2^{n})$\n(2) 動的計画法（下から上まで） int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:部分問題の最適な切断方法 int r[n+1]; // 部分問題の最適値 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間計算量 $O(n^{2})$\nその他のコンテンツ 検索プロセス中に、既存の記事を見つけました： 【基础算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/ja/archives/110/","title":"アルゴリズム 鉄筋切断問題 (動的計画法 分割統治法)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 コインは $n$ 枚あり、そのうち 1 枚は偽造コインであり、偽造コインの方が軽いことが分かっています。今では残高は 1 つだけなので、できるだけ少ない比較で偽造コインを見つける必要があります。\n問題分析 $n$ 枚のコインを 2 つの等しい部分に分割します。\n$n$ が偶数の場合、最初の部分と2番目の部分、$1\\cdots\\frac{n}{2}$ と $\\frac{n}{2}+1\\cdots n$ を2つのスケールの端と端を照らします。軽い方の端に偽造コインが含まれています。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけます。 $n$ が奇数の場合、最初と最後の部分 $1\\cdots\\frac{n-1}{2}$ と $\\frac{n+1}{2}+1\\cdots n$ を、天秤の軽い方の端に偽造コインがあります。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけ続けます。両端の重さが同じであれば、真ん中のコインは偽造コインです。つまり、$\\frac{n+1}{2}$ 枚のコインは偽造品である。 Cコード #include \u0026lt;stdio.h\u0026gt; // coins:重量配列 first,last:配列の最初と最後の添え字 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;%d は偽造コインです\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 残りコインは2枚のみ if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶数枚のコイン if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇数のコイン for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/ja/archives/109/","title":"アルゴリズム偽造コイン問題 (分割統治)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 回路基板の上端と下端には n 個の端子があります。回路設計によれば、$(i, \\pi(i))$ は、上側の端子 i と下側の端子 $\\pi(i)$ の間の接続を表すために使用され、これは回路図上の i 番目の接続と呼ばれます。\n下の図に示す $\\pi(i)$ は、任意の $1 \\le i \u0026lt; j \\le n $ に対して ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ として配置されます。i 番目のリンクと j 番目のリンクが交差するための必要十分条件は $\\pi(i)\u0026gt;\\pi(j)$ である。\n回路基板を作るとき、これらのn本の配線を複数の絶縁層に分配する必要があり、同じ層の配線は交差しません。次に、どの配線を層に配置するかを決定する必要があります。このレイヤーで可能な限り多くのリンク、つまりリンクセット $Nets={ (i,\\pi(i)),1\\le i\\le n }$ の最大の分離サブセットを決定する。\n問題分析 $N(i,j)={ t|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j }$ とする。$N(i,j)$ の最大の分離部分集合を $MNS(i,j)$ ，$size(i,j)=|MNS(i,j)|$ とする。\n分析の結果、この問題は最適なサブ構造特性を持つことがわかりました。規模 n の回路配線問題では、次の再帰式を構築できます。\n$$ \\begin{align*} \u0026amp;(1) \\ \\ i=1\\ とする、 size(1,j)= \\begin{cases} 0, \u0026amp; \\text{j\u0026lt;$\\pi$(1)} \\ 1, \u0026amp; \\text{その他の状況} \\end{cases} \\ \u0026amp;(2) \\ \\ i\u0026gt;1\\ とする， size(i,j)= \\begin{cases} size(i-1,j), \u0026amp; \\text{j\u0026lt;$\\pi$(i)} \\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026amp; \\text{その他の状況} \\end{cases} \\end{align*} $$\nC コード #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題の大きさ // 分離した接続の最大数を見つける void maxNum(int pi[], int **size); // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net); int main(void){ // 下付き文字は1から始まります int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;分離接続の最大数は次のとおりです。%d\\n\u0026#34;,m); printf(\u0026#34;含まれる接続は次のとおりです。\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上部と下部にそれぞれ i と j の端子がある回路基板の最初の層における分離接続の最大数 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大接続数 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 端末セット内の最大接続数を記録する for(i=N; i\u0026gt;1; i--){ // 減少 // (i,pi[i])は最大の互いに素な部分集合を結ぶ線である。 if(size[i][j] != size[i-1][j]){ net[m++]=i; // iを配列ネットに記録し、接続ラインの数を1増やす j=pi[i]-1; // 拡張リンクバー間隔を更新しました } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } その他のコンテンツ 検索中に既存の記事が見つかりました： 算法设计与分析——电路布线（动态规划） 参考文献 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/ja/archives/106/","title":"アルゴリズム回路配線問題（動的計画法）"},{"content":" この記事は Google 翻訳を使用して処理されました\n「ハードドライブに保存されていないものはあなたのものではない」という原則に従い、個人の携帯電話に保存されている写真の数が増えているため、携帯電話のメモリ危機を緩和するために、緊急に整理してハードドライブに保存する必要があるため、アーティストによるダウンロード・保存方式を採用する。そのため、便利な記録と迅速な検索および変更の方法が必要です。アーティストの数が増えると、Markdown を使用した元のリストは必然的に非常に遅くなる可能性があります。\n2 日後に振り返ってみると、何かを記録する最良の方法はデータベースを使用することです。\nダウンロードとインストール 考えた結果、MySQLを使うことにしました。ダウンロードについては、 MySQL下载与安装 - 知乎 を参照してください。一部変更されていますが、ほぼ同じ。\nインストールはデフォルトのままで完了するまでクリックし続けました （面倒すぎる）\nサービスを開始し、win+Rを押してservices.mscと入力し、サービスを見つけて開始します。\nデータベース設計 正直に言うと、ここでデザインすることはあまりありません。今のところ、主に Pixiv からアーティストをダウンロードし、いくつかは Twitter からダウンロードしているので、1 つのテーブルしか使用できないはずです。\nID name downloadDate lastDownloadID platform url アーティスト固有ID 名前 ダウンロード日 最後にダウンロードした作品ID プラットフォーム リンク このデザインはどのようなパラダイムですか? コードは次のとおりです\n-- データベースを作成する create database hello; -- データベースを選択 use hello; -- テーブルを作成 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品をダウンロード Pixiv Powerful Pixiv Downloader 拡張機能 Chrome App Store リンク を使用する\nGithub リンク： xuejianxianzun/PixivBatchDownloader 必ず低速クロールを有効にしてください。そうしないと、ダウンロード速度が速すぎたり、一度にダウンロードする量が多すぎたりした場合に、IP が一時的にブロックされます。\nTwitter Twitter Media Downloader 拡張機能 Chrome App Store リンク を使用する\n公式ウェブサイトのリンク： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ データ挿入 -- データベースを選択 use hello; -- データの挿入 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 複数行のデータの場合、データは , で区切られます。\nデータの更新 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 詳細： データベースの学習 3 SQL言語 – yexca\u0026rsquo;Blog データベースについてもっと知りたいですか? 私が書いた (完全に翻訳しないけど)： データベース学習 1 データベース入門 – yexca\u0026rsquo;Blog 中国語（簡体字）: SQL 教程-菜鸟教程 参照記事 MySQL常见建表选项及约束 - GeaoZhang - 博客园 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/ja/archives/94/","title":"データベースにはダウンロードされたアーティストの作品が記録されます"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: 本文\n以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 SQL言語の分類 DDL（データ定義言語） データベースシステムでは、データベース内の各データベース、テーブル、ビュー、インデックスなどがデータベースオブジェクトです。データベースオブジェクトを作成または削除するには、SQL 言語を使用します。 DDL には CREATE、ALTER、DROP などが含まれます。\nDML（データ操作言語） DML は、INSERT、DELETE、UPDATE など、データベース内のデータを追加、変更、削除するために使用されるステートメントを指します。\nDQL (データクエリ言語) クエリはデータベースの基本機能であり、クエリ操作は SQL データ クエリ言語を通じて実装されます。たとえば、テーブルの内容を照会するにはSELECTを使用します。\nDCL（データ制御言語） DCL には、データベース オブジェクトの権限管理やトランザクション管理などが含まれます。\n(I) DDLデータ定義言語 1. データベースを作成する create database \u0026lt;データベース名\u0026gt; 2。基本テーブルを作成します create table \u0026lt;テーブル名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;データ型\u0026gt; [列レベルの整合性制約], [···,] [テーブルレベルの整合性制約,] [···] ) \u0026lt;1\u0026gt; データタイプ INT / INTEGER : 整数 FLOAT(n): 少なくともn桁の精度を持つ浮動小数点数 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d): p桁（符号と小数点を除く）のd桁の固定小数点数小数点以下の数字 CHAR(n): 長さnの固定長文字列 DATETIME: 日付と時刻の型 -- 例えば create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; ラインレベルの整合性の制約 not null: 空ではない\nunique: ユニーク\nnot null unique: 空ではなくユニーク\ndefault: デフォルト値を定義する\n-- 例えば create table test ( f1 int not null, -- この列は空にできません f2 int unique, -- この列の値は空でも構いませんが、各行は異なる必要があります f3 int not null unique, -- 列は空ではなく、各行は異なります f4 char(5) default \u0026#39;nashi\u0026#39; -- 新しく追加された行に値が割り当てられていない場合、この列はデフォルトで「nashi」になります。 ) \u0026lt;3\u0026gt; テーブルレベルの整合性の制約 名前 条項 通信の完全性 主キー句 PRIMARY KEY エンティティの整合性 チェック条項 CHECK ユーザー定義の整合性 外部キー句 FOREIGN KEY 参照整合性 -- 例えば create table student ( sid int, primary key(sid) -- not null unique ) -- または create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 整合性の検査 アサート（通常は推奨されません） CREATE ASSERTION \u0026lt;アサーション名\u0026gt; \u0026lt;チェック条項\u0026gt; -- チェック句は、where 句の式に似ています。 -- アサーション名を削除 DROP ASSERTION \u0026lt;断言名\u0026gt;; トリガー テーブルが追加、削除、または変更されると、トリガー内の条件がチェックされます。条件が満たされている場合はトリガー内のアクションが実行され、満たされていない場合はアクションは実行されません。\nCREATE TRIGGER \u0026lt;トリガー名\u0026gt; -- トリガー イベントが発生するたびに、トリガーがアクティブになります。 {BEFORE|AFTER} \u0026lt;トリガーイベント\u0026gt; ON \u0026lt;テーブル名\u0026gt; -- トリガー イベントの実行前または実行後にトリガーがアクティブ化されるかどうかを示します。 REFERERCING NEW|OLD ROW AS \u0026lt;変数\u0026gt; -- REFERENCINGは参照される変数を示す FOR EACH{ROW|STATEMENT} -- トリガーの種類を定義し、アクション本体の実行頻度を指定します。 [WHEN \u0026lt;トリガーイベント\u0026gt;] \u0026lt;トリガーアクション本体\u0026gt; -- トリガーアクションはトリガー条件が真の場合にのみ実行されます -- トリガーの削除 DROP TRIGGER \u0026lt;トリガー名\u0026gt; ON \u0026lt;テーブル名\u0026gt; 3。基本的なテーブル構造を変更します 新しい列を追加する alter table \u0026lt;テーブル名\u0026gt; add \u0026lt;列名\u0026gt; \u0026lt;タイプ\u0026gt; -- 例えば alter table test add f3 datetime 列を変更する* alter table \u0026lt;テーブル名\u0026gt; alter column \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; modify \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- 例えば alter table test alter column f3 float -- alter table test modify f3 float 列の削除 alter table \u0026lt;テーブル名\u0026gt; drop column \u0026lt;列名\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; drop \u0026lt;列名\u0026gt; -- 例えば alter table test drop column f3 -- alter table test drop f3 4。基本テーブルを削除します drop table \u0026lt;テーブル名\u0026gt; -- 例えば drop table test (二)、DML データ操作言語 次のコンテンツの例は、これらのテーブルに基づいています\n-- 注: 理解しやすいように中国語を使用しています。実際の開発では英語を使用してください。 -- 学生テーブル create table student ( 学号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 班号 char(5) ) -- 成績テーブル create table score ( 学号 char(5), 课程号 char(5), 分数 int ) -- 教師テーブル create table teacher ( 教师编号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 职称 char(6), 系别 char(10) ) -- コーススケジュール create table course ( 课程号 char(5) not null unique, 课程名 char(20), 任课教师编号 char(5) ) 1. INSERT ステートメントを挿入 SQL基本テーブルにデータを挿入する方法は2つあります。タプル値を直接挿入するか、クエリの結果値を挿入するかです。\nタプル値を直接挿入する insert into テーブル名[(列名の順序)] values (タプル値)[, ···] -- 或者 insert into テーブル名[(列名の順序)] (table (タプル値)[, (タプル値), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 指定した列を挿入する insert into student(学号，姓名，性别，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) クエリの結果値を挿入する insert into テーブル名[(列名の順序)] select \u0026lt;クエリステートメント\u0026gt; -- 例えば insert into student select 111, \u0026#39;赵六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 削除ステートメント delete from \u0026lt;テーブル名\u0026gt; [where \u0026lt;条件式\u0026gt;] -- 例えば delete from student -- テーブル全体を削除する -- 生徒番号111のタプルを削除します delete from student where 学号 = 111 3. UPDATE ステートメントを修正 update \u0026lt;テーブル名\u0026gt; set \u0026lt;列名\u0026gt; = \u0026lt;価値表現\u0026gt;[, ···] [where \u0026lt;条件式\u0026gt;] -- 例えば update student set 班号 = \u0026#39;09058\u0026#39; where 学号 = 110 -- または update student set 班号 = \u0026#39;09057\u0026#39;, 性别 = \u0026#39;女\u0026#39; where 学号 = 110 and 班号 = \u0026#39;09058\u0026#39; (三)、DQL データクエリ言語 SQL データクエリ機能は SELECT 文を通じて実装されます。完全な構文は次のとおりです。\nselect \u0026lt;対象テーブルの列名または列式のシーケンス\u0026gt; from \u0026lt;リレーションテーブルシーケンス\u0026gt; [where \u0026lt;行条件式\u0026gt;] [group by \u0026lt;列名の順序\u0026gt;] [having \u0026lt;グループ条件式\u0026gt;] [order by \u0026lt;列名\u0026gt; [asc|desc]] 1. 投影クエリ クエリ テーブル内の任意の列を選択するには、SELECT コマンドを使用します。複数の列がある場合は、カンマ , を使用して区切ります。 FROM句に複数のリレーショナルテーブルがある場合、各テーブルの名前を記述する必要があります。\n-- 例えば select 1 + 1 select 学号 * 100 from student -- 学生IDとスコアを照会する select student.学号, score.分数 from student, score -- すべての列をクエリする select * from student 重複行を削除するには DISTINCT を使用します\n-- 重複行を削除し、選択したコースを照会する select distinct 课程号 from score クエリ結果の列名をカスタマイズするには AS を使用します\n-- 例えば select 学号 as \u0026#39;sno\u0026#39; from student 2. クエリを選択 選択クエリは、クエリ条件を指定し、ソース テーブルからクエリ条件を満たすレコードのみを抽出または表示します。\n選択クエリでは通常、次の種類の操作が使用されます。\nオペレーター コード 説明する セットメンバーシップ演算子 INNOT IN セット内セットに含まれない 文字列マッチング演算子 LIKE _ および % を使用した単一または複数の文字の一致 NULL比較演算子 IS NULLIS NOT NULL 空の空にすることはできません 算術演算子 \u0026gt;\u0026gt;=\u0026laquo;br /\u0026gt;\u0026lt;==\u0026lt;\u0026gt; より大きいより大きいか等しい未満以下等しい等しくない \u0026lt;1\u0026gt; 条件式の比較演算 --- スコアが60～80のレコードを検索する select * from score where 分数 between 60 and 80 -- 60と80を含めるにはbetweenを使用します。つまり[60, 80]です。 -- スコア \u0026gt;= 60 かつスコア \u0026lt;= 80 の場合と同等 \u0026lt;2\u0026gt; 文字列マッチング操作 where [not] like \u0026#39;一致する文字列\u0026#39; [escape \u0026#39;一致する文字列\u0026#39;] '一致文字列' は完全な文字列にすることも、ワイルドカード文字 % と _ を含めることもできます。\n%: 任意の長さの文字を表します _ : 任意の1文字を表す \u0026lt;3\u0026gt; 集合の比較演算 -- スコアが85、86、または88のレコードをクエリします select * from score where 分数 in (85, 86, 88) \u0026lt;4\u0026gt; 論理的結合演算 -- クラス09031の女子生徒全員を照会する select * from student where 班号 = \u0026#39;09031\u0026#39; and 性别 = \u0026#39;女\u0026#39; 3. 並べ替えクエリ クエリ結果はORDER BY句を使用して並べ替えることができます。\n-- 昇順 asc (デフォルト、省略可能) select 学号, 姓名 from student order by 学号 -- 降順 desc select 学号, 姓名 from student order by 学号 desc 複数の列を指定して並べ替えることもできます。最初の列が最初に並べ替えられ、次に2番目の列が並べ替えられます。\n-- コース番号の昇順とスコアの降順で検索結果を表示します select * from score order by 课程号 asc, 分数 desc ORDER BY 句はクエリの最後に配置する必要があります。\n4. 集計関数 集計関数は、データ統計やその他の機能を実装します。一連の値を計算し、単一の値を返すために使用されます。\n通常は group by 句とともに使用される一般的な集計関数は次のとおりです。\n関数名 説明 AVG 平均値 COUNT 指定された式で選択された項目の数をカウントしますCOUNT(*)はクエリによって出力された行数をカウントします MIN 最小値 MAX 最大値 SUM 値の合計 STDWV 指定された式のすべてのデータの標準偏差を計算します STDEVP 母集団標準偏差 集計関数の引数の一般的な形式は次のとおりです。\n[all|distinct] expr このうち、ALL はすべての値に対して集計関数演算を実行することを意味し、これがデフォルト値となります。また、DISTINCT は、すべての一意の値が考慮されることを指定します。 exprは式です\n-- クラス「09031」の生徒数を照会する select count(*) as \u0026#39;人数\u0026#39; from student where 班号 = \u0026#39;09031\u0026#39; 5. データのグループ化 集計関数は1つの結果しか出力しないため、列をクエリして集計関数をまとめるとエラーが報告されます。\n特定のカテゴリの集計関数の結果は、データをグループ化することで計算できます。つまり、集計関数の範囲は各グループ内のすべてのレコードになります。\n集計関数をフィルター条件として使用する場合は、それを HAVING 句の後に置く必要があります。\n-- 最低スコアが 70 を超え、最高スコアが 90 未満の学生の学生 ID を照会します。 select 学号 from score where 分数 is not null group by 学号 having min(分数) \u0026gt; 70 and max(分数) \u0026lt; 90 クエリ内に WHERE 句、GROUP BY 句、HAVING 句、および集計関数が同時に出現する場合、SELECT コマンドの実行順序は次のようになります。\nWHERE句を実行してテーブルから行を選択します 選択した行を「GROUP BY」でグループ化する 集計関数を実行する HAVING句を実行して条件を満たすグループを選択します。 -- 各コースの平均スコアを照会する select 课程号, avg(分数) from score group by 课程号 集計関数は条件として HAVING 句の後にのみ配置でき、 WHERE 句の後には配置できません。\nSELECT句が列名と集計関数で構成されている場合、すべての列名をグループ化する必要があります。\n6. テーブル接続クエリ FROM 句では結合するテーブルを指定し、WHERE 句では結合条件を指定します。\nselect \u0026lt;列名1\u0026gt;[, ···] from \u0026lt;表1\u0026gt;[, ···] where 接続条件 2つのテーブルの共通列には、student.学号などのプレフィックスを指定する必要があります。\nSQL Server では、接続は内部接続と外部接続に分けられます。\n\u0026lt;1\u0026gt; 内部結合 Θ 結合、等価結合、自然結合\n内部結合は最も基本的な結合方法です。INNER JOIN キーワードを使用します。このキーワードを使用しない場合、デフォルトは内部結合になります。\n等接続 つまり、2つのテーブル間の接続関係は「等しい」です。\n-- すべての学生の名前、コース番号、スコアの列を照会する select student.姓名, score.课程号, score.分数 from student, score where student.学号 = score.学号 -- したがって select student.姓名, score.课程号, score.分数 from student inner join score on student.学号 = score.学号 入力を簡略化するために、テーブルエイリアスを使用することができます。\n-- 前の例の簡略化 select x.姓名, y.课程号, y.分数 from student x, score y where x.学号 = y.学号 非等価結合 つまり、2つのテーブル間の接続関係は「等しい」ではない。\n自己接続 同じテーブルを結合することを自己結合と呼びます。\n-- \u0026#39;3-105\u0026#39; を受験し、そのスコアが生徒 \u0026#39;109\u0026#39; のスコアより高い生徒の記録を照会します。 select x.课程号, x.学号, x.分数 from score x, score y where x.课程号 = \u0026#39;3-105\u0026#39; and x.分数 \u0026gt; y.分数 and y.学号 = \u0026#39;109\u0026#39; and y.课程号 = \u0026#39;3-105\u0026#39; order by x.分数 desc \u0026lt;2\u0026gt; 外部結合 OUTER JOIN 左外部結合: LEFT OUTER JOIN または LEFT JOIN\n右外部結合: RIGHT OUTER JOIN または RIGHT JOIN\n完全外部結合: FULL OUTER JOIN または FULL JOIN\n-- 左外部結合の例 -- すべてのコースの教師の名前を照会する select course.课程名, teacher.姓名 from course left join teacher on (course.任课教师编号 = teacher.教师编号) 7. サブクエリ \u0026lt;1\u0026gt; 一般的なサブクエリ あるクエリが別のクエリの条件である場合、つまり、テーブルから行を選択する条件がテーブル自体または他のテーブルの結合情報に依存する場合、サブクエリを実装する必要があります。\nサブクエリは、SELECT ステートメントの WHERE 句で最もよく使用されます。\n-- 学生番号「105」の学生と同じ年に生まれた学生を検索します select 学号, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相関サブクエリ 通常のサブクエリでは、各サブクエリは 1 回だけ実行され、返された値はメインクエリの WHERE 句で使用されます。\nメイン クエリが各行を選択するかどうかを判断するときは、サブクエリを「起動」し、メイン クエリにフィードバックする必要があります。つまり、内部条件に外部属性が含まれるサブクエリは相関サブクエリと呼ばれます。\n-- コースの平均スコアよりも低いスコアを持つ学生を照会する select 学号, 课程号, 分数 from score a where 分数 \u0026lt; ( select avg(分数) from score b where a.课程号 = b.课程号 and 分数 is not null ) \u0026lt;3\u0026gt; EXISTS テストを含むサブクエリ EXISTS は存在量指定子 ∃ を表し、論理真または論理偽の値のみを返します。\n-- すべての教師の名前と部門を照会する select 姓名, 系别 from teacher a where exists ( select * from course b where a.教师编号 = b.任课教师编号 ) あるいは、結果を否定する「NOT EXISTS」がある。\n8. クエリ結果の結合、交差、差の演算 次の演算子を使用して、2 つの SELECT クエリの結果に対して操作を実行できます。\nUNION : および 交差: 例外: 差異 -- ANDの例 -- すべての教師と生徒の名前、性別、生年月日を照会する select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 生年 (四)、DCL データ制御言語 データ制御は、ユーザーのデータ保存権限を制御し、DBA（データベース管理者）によって決定されます。\nデータベースセキュリティ 不安要素:\nデータベースへの不正アクセスと破壊 データベースから重要なデータが漏洩 安全保障環境の脆弱性 セキュリティコントロール:\nユーザーID認証: 静的パスワード認証、動的パスワード認証、生体認証、スマートカード認証 アクセス制御 自律的なアクセス制御方式（ユーザーが操作権限をカスタマイズし、他のユーザーに割り当てることができる） 自律アクセス制御 DBMS（データベース管理システム）データ制御には以下の機能が必要です\nGRANTとREVOKEを通じてシステムに権限を通知し、データ辞書に保存する ユーザーがリクエストを行った場合、認可ステータスに基づいて操作リクエストを実行するかどうかを確認します。 SQL 標準には、DELETE、INSERT、SELECT、および UPDATE 権限が含まれます。 SELETE 権限は READ 権限に対応します。SQL には REFERENCES 権限も含まれており、これはリレーションを作成するときにユーザーが外部キーを定義する機能を制限するために使用されます。\n1. 認可ステートメントの形式 grant \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] to \u0026lt;ユーザー\u0026gt;[, ···] [with grant option] 操作オブジェクトの種類によって権限は異なります。一般的な権限は次のとおりです。\nオブジェクト オブジェクトタイプ 操作権限 属性列 TABLE SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4つの権限の合計) ビュー TABLE SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4つの権限の合計) 基本テーブル TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEXALL PRIVILEGES (6つの権限の合計) データベース DATABASE CREATETAB テーブルを作成する権限。DBA が一般ユーザーに付与できます。 PUBLIC: 権限を受け取るユーザーは、単一のユーザーまたは複数の特定のユーザーです。PUBLIC パラメータは、すべてのユーザーに権限を付与できます。 GRANT OPTION付き: この句が指定されている場合、権限を取得したユーザーは他のユーザーに権限を付与することもできます。 2. 権限取り消しステートメントの形式 revoke \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] from \u0026lt;ユーザー\u0026gt;[, ···] データベースの役割 役割とは、CEO、取締役、一般従業員など、人物のタイプを指します。人物のタイプを承認できます。\nキャラクター作成 create role \u0026lt;キャラクター名\u0026gt; ロールの承認 grant \u0026lt;権限\u0026gt; on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt; to \u0026lt;役割1\u0026gt;[, ···] 他のユーザーまたはロールにロールを付与する grant \u0026lt;役割\u0026gt; to \u0026lt;役割\u0026gt;または\u0026lt;ユーザー名\u0026gt; [with admin option] with admin option は、このユーザーが他のロールまたはユーザーにこの権限を付与できることを意味します。\nロール権限の取り消し revoke \u0026lt;権限\u0026gt; on \u0026lt;オブジェクト名\u0026gt; from \u0026lt;キャラクター名\u0026gt; ビューのメカニズム ビューは、1 つ以上の基本テーブルまたはビューから派生したテーブルです。これは仮想テーブルです。\nユーザーごとに異なるビューを定義し、ユーザーが間違いを起こさないように不要なデータを非表示にします。\nビューの作成 create view \u0026lt;ビュー名(リスト名)\u0026gt; as select \u0026lt;クエリ句\u0026gt; [with check option] サブクエリのSELECT文には通常、ORDER BY句とDISTINCT文を含めることはできません。 WITH CHECK OPTION は、UPDATE、INSERT、および DELETE 操作の場合、操作対象の行がビュー定義の述語条件 (つまり、サブクエリの条件式) を満たす必要があることを意味します。 ビューを構成する属性列名がすべて省略されているか、すべて指定されています。省略した場合、ビューは SELECT サブクエリのターゲット列のプライマリ属性で構成されていることが暗黙的に示されます。 -- 関係モデル：student(sno, sname, sex, SD, email) -- 「コンピュータサイエンス（CS）」の学生向けのビューを作成し、変更操作を実行する場合 -- ビュー内のコンピュータサイエンスの学生のみが影響を受けるようにする create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option ビューの削除 drop view \u0026lt;ビュー名\u0026gt; --例えば drop view cs-student 監査 データベースに対するすべての操作は監査ログに記録され、そのログを使用して不正な動作があるかどうかを確認できます。\n-- 「SC」データを変更する監査操作 AUDIT UPDATE ON SC; -- 「SC」テーブルのすべての監査をキャンセルします NOAUDIT UPDATE ON SC; データ暗号化 いくつかの暗号化アルゴリズムにより、プレーンテキストは暗号テキストに変換され、他の人が閲覧できなくなります。\n＃＃ 索引\nインデックスを使用すると、データベース プログラムはテーブル全体をスキャンしなくても、テーブル内の必要なデータを見つけることができます。\nデータベースのインデックスは、テーブルの 1 つ以上の列の値のコレクションと、これらの値を物理的に識別するテーブル内のデータ ページへの論理ポインターの対応するリストです。\n内部スキーマによって定義されます（内部スキーマはすべての内部レコードタイプ、インデックス、およびファイル構成を定義します）\nインデックスを作成する create [unique] [cluster] index \u0026lt;インデックス名\u0026gt; on \u0026lt;テーブル名\u0026gt;(列名[順序], ···) 順序：オプションASC（デフォルト）または DSC\nUNIQUE ：このインデックスの各インデックス値が 1 つのデータ レコードのみに対応することを示します。\nCLUSTER ：作成されるインデックスがクラスター化インデックスであることを示します。つまり、インデックス項目の順序は、テーブル内のレコードの物理的な順序と一致します。\nインデックスの削除 drop index \u0026lt;インデックス\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/88/","title":"データベースの学習 3 SQL言語"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: 本文\nデータベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 リレーショナルモデルの基本用語 リレーショナル データベース システムは、リレーショナル モデルをサポートするデータベース システムです。リレーショナル モデルに関連する基本的な用語は次のとおりです。\nリレーションシップ: リレーションシップは2次元テーブルであり、各リレーションシップにはリレーションシップ名があります。 タプル: テーブル内の行はタプルであり、ストレージファイル内のレコード値に対応します。 属性: テーブル内の列は属性と呼ばれます。各列には属性名があり、属性値はレコード内のデータ項目またはフィールド値に相当します。 ドメイン: 属性の値の範囲、つまり異なるタプル内の同じ属性の値の範囲 リレーションシップモデル: リレーションシップの説明はリレーションシップモデルと呼ばれ、リレーションシップ名とその属性セットで構成されます。リレーションシップモデルの形式は次のとおりです: リレーションシップ名(属性名 1，···，属性名 n) 通常、リレーショナルモデルはリレーショナルファイルの結果に対応する。\n候補キー: タプルを一意に識別する値を持つ属性または属性の組み合わせ 主キー: 関係には複数の候補キーが存在する場合があり、そのうちの1つが主キーとして選択されます。 主属性: 候補コード に含まれる属性は主属性と呼ばれ、候補コード に含まれない属性は非主属性と呼ばれます。 外部キー: リレーション内の属性または属性グループがリレーションのキーではないが、別のリレーションのキーである場合、その属性または属性グループをリレーションの外部キーと呼びます。 フルコード: リレーショナルスキーマのすべての属性グループは、このリレーショナルスキーマの候補コードであり、フルコードと呼ばれます。 スーパーコード（スーパーキー）：コードを含む属性のセットはスーパーコードと呼ばれます 関係モデルの定義 関係の記述はリレーショナルモデルと呼ばれ、正式には次のように表現されます: R(U, D, dom, F)\nここで、Rは関係名、Uは関係を構成する属性名のセット、Dは属性グループUの属性の由来となるドメイン、domは属性からドメインへのマッピングのセット、Fは属性データ間の依存関係のセット。\nこれは通常、R(U)またはR($A_1$, $A_2$, ···)と略記されます。ここで、Rは関係名、Uは属性名セット、$A_1$、···は個々の属性です。名前。\nリレーショナル モデルは、リレーショナル データ構造、リレーショナル操作セット、リレーショナル整合性制約の 3 つの部分で構成されます。\nリレーショナルデータ構造 リレーショナルモデルにおけるデータの論理的な関係は2次元のテーブルである\n関係演算セット リレーショナルモデルは関係を操作する機能を提供する\n一般的なリレーショナル操作には、選択、投影、接続、除算、結合、積、差などのクエリ操作、および追加操作と削除操作が含まれます。\nリレーショナル整合性制約 リレーショナル モデルの 3 つの整合性ルールは次のとおりです。\nエンティティの整合性: リレーションシップの主キーの値は空または部分的に空にすることはできません。つまり、主キーの属性、つまり主属性は空の値を取ることはできません。 参照整合性: リレーション $R_2$ の外部キーXがリレーション $R_1$ の主キーに対応する場合(基本リレーション $R_1$ と $R_2$ は必ずしも異なるリレーションではなく、同じリレーションである可能性があります)、次に、外部キー X の各値は、リレーション $R_1$ の主キーの値内に見つかる必要があります。見つからない場合は null になります。 ユーザー定義の整合性: 特定のデータに対してユーザーが指定した制約の検証を指します。 関係代数演算子 オペレーター シンボル 意味 集合演算子 ∪–∩× 連合違い交差点デカルト積 特殊な関係演算子 σπ⋈÷ 選ぶ投影接続分割 比較演算子 ＞≥＜≤＝≠ より大きいより大きいか等しい未満以下等しい等しくない 論理演算子 ¬∧∨ 否及びまたは 従来の集合計算 専門的な関係オペレーター 接続 θ 接続、等接続と自然接続\nθ 接続：接続条件が等しくない 等価接続：接続条件は等価です 自然接続: 重複するプロパティの等価接続を削除します。最もよく使用される接続計算。 プロジェクター 投影計算は関係の垂直方向から計算を実行し、関係 R で新しい関係を構成するいくつかの属性列 A を抽出し、$π_A(R)$ を計算します。\n选择 選択計算は関係の水平方向からの計算であり、関係 R の中から所定の条件を満たす要素を選択し、$σ_F(R)$ として計算します。\n外部接続 外部接続計算は接続計算の拡張であり、接続計算によってメッセージが失われる可能性があります。\n左外部接続: 左側関係関係のすべてと右側関係関係のいずれかの要素グループが一致しない要素グループを取り出し、右側関係関係からのすべての属性を空の null で埋めます。 外部接続: 右側関係系のすべてと左側関係系のいずれかの元組が一致しない元組を取り出し、左側関係系からのすべての属性を空の null で埋めます。 ※全外部接続：左外部接続と右外部接続の操作を完了します。 除法 シンボルからSQL言語へ 関係 R：\nA B C 1 2 3 4 5 6 7 8 9 SQL言語への投影 $π_?(?)$\nselect ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\nselect A, B, C from R 注：SQL 语言不サポート列 (プロパティ) の順序番号\n選択からSQLへ $π_?(σ_?(?))$\nselect ? from ? where ? $π_{A, B, C}(σ_{B \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$\nselect A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # または select A, B, C from R where B \u0026gt;= 5 デカルト積からSQLへ $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\nselect R.A, R.B, R.C, S.A, S.B, S.D from R, S # 昇順で並べ替え order by R.A asc SQL言語への自然接続 関係 R(A, B, C) および S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\nselect R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/87/","title":"データベース学習 2 リレーショナル モデル"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: 本文\nデータベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 導入 以前のデータベースはうまく書かれていなかったので、見直して書き直しました（ただし、これもかなり乱雑です）\nデータベース4つの基本概念 データ 物事を記述する象徴的な記録\nデータベース 一般に、データベース データには、永続的な保存、整理、共有という 3 つの基本的な特性があります。\n厳密に言えば、データベースとは、長期間コンピューターに保存され、整理され、共有可能な大量のデータの集合です。データベース内のデータは、特定のデータ モデルに従って整理、記述、保存され、冗長性が低く、データの独立性が高く、スケーラビリティが容易で、さまざまなユーザーが共有できます。\nデータベース管理システム これは、ユーザーとオペレーティング システムの間に位置するデータ管理ソフトウェアのレイヤーです。オペレーティングシステムと同様に、コンピュータの基本ソフトウェアです。\n主な機能:\nデータ定義機能\nデータの整理、保存、管理\nデータ操作機能\nデータベースのトランザクション管理と運用管理\nデータベースの構築と保守機能\nその他の機能（通信機能、データ変換機能、相互アクセス・相互運用機能等）\nデータベースシステム これは、データベース、データベース管理システム (およびそのアプリケーション開発ツール)、アプリケーション、およびデータベース管理者 (DBA) で構成され、データを保存、管理、処理、および維持するシステムです。\nコンピューターデータ管理の開発 手動管理段階（1950年代半ば以前） データは保存、共有、独立していない\nファイル システム フェーズ (1950 年代後半から 1960 年代中期から後半) 保存はできるが、共有が不十分、冗長性が高く、独立性が低い\nデータベース システムの段階 (1960 年代後半から) データベースシステムの登場により、情報システムはデータ処理プログラム中心から共有データベース中心へと移行し、データ全体の構造化が実現しました。\nデータは高度に共有され、冗長性が低く、拡張が容易です。データの冗長性を大幅に削減し、ストレージスペースを節約し、データの独立性を高めることができます。\nデータモデル分類 モデル適用の目的の違いにより、モデルは2つのカテゴリまたは2つのレベルに分けられます。情報世界から抽象化されたデータモデルは概念データモデルと呼ばれ、DBMS（データベース管理システム）によってサポートされるデータモデルは情報世界から抽象化されます。コンピュータの世界では、構造データモデル（またはデータモデル）と呼ばれています。\nコンセプトデータモデル（概念モデル） 概念データモデルは、コンピュータシステムから独立したモデルです。システム内の情報の表現にはまったく関係しません。特定の組織が関心を持つ情報構造を記述するためにのみ使用されます。つまり、データをモデル化します。情報世界モデリングは、一般的にエンティティ・リレーションシップ法（E-R法）を用いて表現されます。主にデータベース設計に使用\n概念データ モデルでよく使用される用語は次のとおりです。\nエンティティ: 客観的に存在し、互いに区別できるものをエンティティと呼びます\n属性: エンティティを記述する特性を属性と呼びます。\nコード: エンティティを一意に識別する属性のセットはコードと呼ばれます。\nエンティティタイプ: エンティティ名と属性セットを使用して、類似のエンティティを抽象化し、特徴付けます。\nエンティティセット: 同じタイプのエンティティのコレクション\nドメイン: 属性の値の範囲は、属性のドメインと呼ばれます。\n関係: エンティティ間の対応する関係を関係と呼びます\n2つのエンティティ間の関係には3つの種類がある\n1対1のコンタクト 1対多の連絡 多対多の接続 実体関連法によって表現される概念データ モデルは、E-R 図と呼ばれます。エンティティは四角形で表され、属性は楕円形で表され、無向エッジはそれらを関連するエンティティに接続するために使用されます。\n構造データモデル（ロジックモデル） 構造データ モデルは、データベースの論理構造に直接関係します。すべての DBMS は構造データ モデルに基づいています。主にデータベース管理システムの実装に使用されます\n構造データモデルには主に、階層型、ネットワーク型、リレーショナル型、オブジェクト指向型などがある。\n階層モデル 階層モデルは、データ間の関係を表すために「ツリー構造」を使用します。そのデータ構造は「有向ツリー」です。\nメッシュモデル ネットワークモデルは「グラフ構造」を使用してデータ間の関係を表します。\nリレーショナルモデル リレーショナル モデルは、2 次元のテーブル構造を使用してエンティティとエンティティ間の関係を表すデータ モデルです。各 2 次元テーブルは行と列で構成され、これらは関係とも呼ばれます。リレーショナル モデルは、関係を記述したものです。したがって、リレーショナル モデルはリレーショナル パターンの集合であると言えます。\n物理モデル これはデータの抽象化の最低レベルです。システム内のデータの表現とアクセス方法、またはディスクやテープ上のデータの保存とアクセス方法を記述します。これはコンピュータシステム指向です。\nデータベースシステム構造 ストレージ構造が異なるデータベース製品は数多くあるが、アーキテクチャはすべて「3レベルモデルと2レベルイメージ」を採用しており、同じ特徴を持っている。\n3番目のレベルモード 概念モデル（基本表） スキーマまたは論理スキーマとも呼ばれ、データベース内のすべてのデータの論理構造と特性を記述したもので、すべてのユーザーに共通のデータ ビューです。\n外部モード（表示） ユーザー モードまたはサブモードとも呼ばれ、ユーザーとデータベース システム間のインターフェイスであり、ユーザーが使用するデータの説明です。\n内部モード（保存ファイル） ストレージ モードとも呼ばれ、データベースには 1 つの内部モードのみがあります。これは、データの物理的な構造と保存方法を記述したもので、データベース内でデータが整理される方法です。\n2 レベルの画像 データベース システムは、3 つのレベルのモデル間に、モデル/内部モデル マッピングと外部モデル/モデル マッピングという 2 つのレベルのマッピングを提供します。\nこれら 2 つのレベルのイメージがあるからこそ、データベース内のデータは高度な論理的独立性と物理的独立性を持つことになります。\nモード/内部モードイメージ（ストレージ） 概念レベルと内部レベルの間に存在し、概念モデルと内部モデルの相互変換を実現する\nデータベースのストレージ構造が変更された場合、データベース管理者はスキーマ/内部スキーマに対応する変更を加えてスキーマを変更しないようにできるため、アプリケーションを変更する必要がありません。データとプログラムの物理的な独立性を保証します\n外観モデル/モデルイメージ（表示） 外部レベルと概念レベルの間に存在し、外部モデルと概念モデルの相互変換を実現する\nスキーマが変更された場合、データベース管理者は各外部スキーマ/スキーマ イメージに対応する変更を加え、外部スキーマを変更せずに維持することができます。アプリケーションを変更する必要はありません。データとプログラムの論理的独立性を保証します\nデータの独立性とは、データがプログラムから独立しており、データの定義がプログラムから分離されていることを意味します。 DBMSの二次イメージング機能によりデータの独立性が確保されます。データの独立性には、データの物理的な独立性と論理的な独立性が含まれます。\nデータの物理的な独立性: ユーザーのアプリケーションとデータベース内のデータの物理的な保存は互いに独立しています。\nデータの論理的独立性: ユーザーのアプリケーションとデータベース内の論理構造は互いに独立しています。\nデータとプログラムが独立しているため、データの定義と記述をアプリケーション プログラムから分離できます。さらに、データアクセスはデータベース管理システムによって管理されるため、アプリケーションプログラムのコンパイルが簡素化され、アプリケーションプログラムの保守や修正にかかる手間が大幅に軽減されます。\nデータベースシステム構成 ハードウェアプラットフォームとデータベース 十分な大きさのメモリ、ディスクまたはディスクアレイ、その他のデバイス、データ転送速度を向上させるための高いチャネル容量\nソフトウェア データベース管理システム、データベース管理システムの動作をサポートするオペレーティングシステム、データベースインターフェースを備えた高級言語とそのコンパイルシステム、データベース管理システムを中核とするアプリケーション開発ツール、特定のアプリケーション環境向けに開発されたデータベースアプリケーションシステム\n人事 データベースを開発、管理、使用する人には、主にデータベース管理者、システムアナリスト、データベース設計者、アプリケーションプログラマー、エンドユーザーが含まれます。\nデータベース管理者の責任: データベースの情報内容と構造を決定し、データベースのストレージ構造とアクセス戦略を決定し、データのセキュリティ要件と整合性制約を定義し、データベースの使用と操作を監視し、データベースを改善および再編成します。 、データベースを再構築します。\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/ja/archives/86/","title":"データベース学習 1 データベース入門"},{"content":" この記事は Google 翻訳を使用して処理されました\n導入 コマンドラインから何かを実行して自慢したいと思わない男の子がいるでしょうか?以前から youtube-dl については知っていましたが、複雑すぎるようだったので使用していませんでした。今日試してみたところ、とても便利だとわかりました。\n環境 Python 3.7以降をインストールする Python の公式サイト でダウンロードしていい、インストールのとき、Add Python x.x to PATH をチェックしてね\nyt-dlp をインストール yt-dlp は youtube-dl に基づいて変更され、ダウンロード速度が速い\nダウンロード releases で yt-dlp.exe をダウンロードする\n構成 ダウンロードしたファイルを固定の場所に置き、マイコンピュータのプロパティを開き、システムの詳細設定 - 環境変数 - システム変数に移動し、Path を選択して編集をクリックし、新しいウィンドウで新規をクリックします。yt -dlp.exe のファイルを入力して\n次に、「はい」を 3 回クリックしてすべてのウィンドウを閉じる。\nテスト Win+R を押して「cmd」と入力し、Enter を押す。\ncmd に yt-dlp と入力します。Usage: yt-dlp [OPTIONS] URL [URL...] が表示されたら、設定は成功だ。\n更新 cmdに「yt-dlp -U」と入力するといい\n動画をダウンロード ダウンロードを開始するには、cmd に「yt-dlp」+「スペース」+「YouTube ビデオ リンク」と入力するだけです。\nデフォルトのダウンロードは720Pで、保存場所はC:/Users/%UserName%/です。\nダウンロード保存場所を変更する C:\\Users\\%UserName%\\AppData\\Roaming に新しいフォルダを作成し、yt-dlp という名前を付け、新しく作成したフォルダに入り、新しいファイル config.txt を作成します。\nファイルに次のコードを入力してください\n-o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; このうち、C:/Users/%UserName%/Downloads/Video/はダウンロードディレクトリです。\n%(title)s.%(ext)sは、ビデオのタイトルであるファイル名を保存する形式で、ビデオのタイトル.ビデオの拡張子名\n1080Pをダウンロード 1080P以上の動画は音声と動画が分離されているため、まずffmpegをダウンロードする必要があります。\nffmpeg 公式サイト にアクセスし、左下隅のシステムタイプを選択してから、ダウンロードを選択します。\nReleases · BtbN/FFmpeg-Builds を選択し、ffmpeg-n5.0-latest-win64-gpl-5.0.zipをダウンロードしました。\n次に、それを固定フォルダに配置し、システム変数に「bin」ファイルディレクトリを配置します。\nテスト cmd を開いて ffmpeg -version と入力します。バージョン番号が表示されれば、設定は成功です。\nクエリコマンド 現在のビデオの完全な形式を表示するには、yt-dlp -D [URL]と入力します (クエリのみ、ダウンロードは行われません)\nダウンロードコマンド 指定した形式でビデオをダウンロードするには、yt-dlp -f [ID] [URL]と入力します。ビデオとオーディオをダウンロードするには、[ID]+[ID]の組み合わせを使用できます。つまり、yt-dlp -f [ID]+[ID] [URL]はダウンロード後に自動的に結合されます\n注: 最高品質のビデオとオーディオをダウンロードします: -f \u0026quot;bv+ba/b\u0026quot;\naria2 を呼び出す ダウンロード コマンドの後に--external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; を追加するだけです。\n字幕をダウンロード outube-dl --write-sub [url]\t//これはvtt形式の英語字幕とmkv形式の1080pビデオをダウンロードします youtube-dl --write-sub --skip-download [url] //ビデオをダウンロードせずに別の vtt 字幕ファイルをダウンロードします youtube-dl --write-sub --all-subs [url] //すべての言語の字幕をダウンロードします（ある場合） youtube-dl --write-auto-sub [url] //自動生成された字幕をダウンロードする（YouTubeのみ） ビデオリストをダウンロード youtube-dl -f [format code] [palylist_url] //この方法では、指定された解像度のmp4ビデオをダウンロードできます youtube-dl [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl -cit [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl --yes-playlist [url] //リンクがビデオリストの場合、リスト内のビデオをダウンロードします。上記と同じですが、mkv または webm 形式である可能性があります。 視覚化 Releases · jely2002/youtube-dl-gui 参考文献 yt-dlp - Github 【备份】youtube-dl使用介绍 - 简书 一文搞懂Windows系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/ja/archives/52/","title":"コマンドラインからYouTube動画をダウンロードする"},{"content":"WordPress へようこそ。これが最初の投稿です。編集または削除して書き込みを始めてください。\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/ja/archives/1/","title":"Hello World！"}]