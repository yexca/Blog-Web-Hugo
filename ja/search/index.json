[{"content":" この記事の一部は機械翻訳を使ったよ\nみんながカード使ってるからって、全員が還元目的ってわけじゃない。システム作ってる人だって、全員がエンジニアなわけでもない。 たまにいるんだよね、カード切ってるのに設計者っぽいやつ。システム組んでるのに、生活感があるやつ。\n1. 導入：カードオタクって何？ まず最初に紹介したいのが、どこかで見た「カード勢の七大あるある」：\nここでの「中国本土」とは、資金の出入りに制限がある地域を指している\n中国本土で外貨を使う方法を探す 海外で人民元を使う方法を探す 人民元を国外に持ち出すルートを探す 外貨を中国本土に持ち込む方法を考える 本土でほとんど使えないカードをつくる 海外でさらに使えないカードをつくる 暗証番号の桁数より少ない金額を、ほとんど使い道のないカードの間でぐるぐる回す ※中国本土では銀行のパスワードが6桁で設定されることが多く、「暗証番号より桁が少ない＝金額すら届かないのに頑張って動かしてる」的な自虐ネタ。他地域では異なる可能性あり\n……ね？もうゲーム感覚。 パッと見は、ただカード増やして、ポイント狙って、手数料節約して、レート得する方法探してるだけ。 なんかちょっとセコい技集めみたいに見えるでしょ。\nでも、本気のカード勢ってそうじゃない。\nカードオタクってのは、「数円節約したい人」じゃなくて、複数通貨、複数経路、複数制限の中で最適な資金ルートを構築しようとしてる設計者なんだよね。\n羊毛狙いじゃない。現実世界の構造を掘り下げてるんだ。\n生活っていうシステムを、最適化しようとしてるんだよ。\n2. システムアーキテクトって何してる人？ システムアーキテクトの資格を取ろうとすると、よく出てくる用語がある。 たとえば「モジュールの分離」「パフォーマンス最適化」「インターフェース設計」…… でもね、用語は置いといて、やってることは意外とシンプル。\n制限だらけの現実の中で、リソースを上手く割り振って、ルートを引いて、システム同士をつないで、壊れにくくて柔軟な全体構造を作る\nアーキテクトが考えてるのって、「このコード綺麗に書けた！」とかじゃないし、ただ図を描くのが仕事でもない。 一番重要なのは、複雑な制約がある現実世界の中で、ちゃんと動くシステムになってるかどうか。\nたとえば：\nシステム間で役割をどう分ける？ サービス同士はどうやって通信する？ インターフェースってどう作れば、将来の拡張にも対応できる？ 不具合が起きたら、どうやって見つけて影響を最小限にする？ 予算が限られてるとき、どこまで性能とコストのバランスを取る？ アーキテクトって、レゴビルダーっぽくもあるし、道路設計者っぽくもあるし、バグだらけの街を修理してる職人みたいでもある。\n最初から綺麗な地図なんてない。バグってたり、壊れてたりする世界の中で、少しずつルートを整えて、橋を補強して、構造を変えて、流れをスムーズにしていく。\nつまりは、現実的な制約の中で、「ちゃんと動いて、あとから直せて、維持費が払える」システムを設計するってこと。 カッコいい技術を見せるんじゃない。「完璧な設計」を目指すんじゃない。 とにかく壊れずに回り続けること。壊れても止まらないこと。それがアーキテクトの美学なんだよ。\n自分はこの話、資格試験のために勉強したんだけど…… 気づけばまたカード遊びに夢中になってたんだ。\n3. カードオタクの「構造的課題」って？ ただの節約マニアだと思ってた？違う違う。 アーキテクトが「お堅いエンジニアの世界」に生きてるって思ってた？それも違う。\n一見バラバラに見えるけど、カードオタクもアーキテクトも、根っこは同じことをやってる：\nルールが複雑で、コスト制約があって、正解が見えない中で、最適なルートと構造を探す。\nカード勢はカードを作る人じゃなくて、「資金の流れを設計してる人」 システムアーキテクトはコード書く人じゃなくて、「情報と制御の流れを設計してる人」\nカード勢が悩むのは： 「どうやったら手数料減らせる？リスク管理回避できる？制限の中でうまく流せる？」\nアーキテクトが考えるのは： 「どうやったら障害少なく？拡張性高く？現場で安定して動かせる？」\n試験勉強で学んだアーキテクトの思考法、振り返ってみたら、 これ……カード組んでるときと全く同じじゃんって気づいたんだよね。\nカード世界 アーキテクト世界 コア思考 手数料 レイテンシや性能コスト コスト最適化 通信ルートの制限 APIコール制限 プロトコル適応力 カードの発行ルール モジュールの設計ルール 規格・コンプライアンス 為替や通貨制限 クロスプラットフォーム対応 環境適応性 カードの種類が多すぎる 技術スタックの多様性 システム統合設計 銀行の風当たり システムのセキュリティ リスク設計 カード間の資金移動経路 データフロー設計 経路・構造デザイン カードやってるのって、別に儲けたいとかじゃないんだよ。 やってること、ほぼ構造設計なんだよね。\n「どのカードが一番得か？」じゃなくて、 「どうやって一番効率よく、損せず、リスク回避しつつ、お金を流すか？」を考えてる。\nポイントは「できるか」じゃなくて、「美しく流れるか」。 送れるかどうかじゃなくて、「そのフローに無駄や詰まりがないか」。\nカード勢がやってるのは、ある意味「複雑制約付きの最短経路問題」解いてるみたいなもん。 アーキテクトが設計するのは、「モジュール間の結合度やSLA制限を考慮した構成の最適化」\nね？ほぼ一緒でしょ。場所が違うだけで、やってること変わらんのよ。\n4. 地図を塗るように構築する日常ルート 他人は還元狙い、自分は生態系を解き明かしてるつもり。\nカード勢のルートって、本当に人それぞれ。 使ってる銀行も、口座の種類も、持ってる通貨も、ライフスタイルすらバラバラ。\nだから面白いのは攻略サイトをなぞることじゃなくて、自分の条件下で、自分だけの最適解を試行錯誤で見つけること。\n最初はただ「手数料ちょっとでも減らせないかな～」くらいで始めたんだけど、調べれば調べるほど奥が深い。 銀行ごとに振込条件も違うし、時間帯によって無料だったり、特定通貨じゃないと跳ねられたり、なぜか理由もなく止められたり。\nまるで最初は真っ黒なマップのゲームみたいに、ちょっとずつルートを開拓して、通れる場所を増やして、チェックポイントをマークしていく感じ。\n小さな額で何回も試して、失敗して、やり直して……その繰り返しで、 自分にとって「コストが許容できる通り道」が見えてくる。\nやがて「高コストの地雷ルート」を避けながら、レートのタイミングすら読んで浮き分を狙ったり、 そのうち「この通貨経由すればもうちょい節約できるかも」ってルート最適化まで始まる。\n中には最初から「絶対無理でしょ」って思ってたルートも、 試してみたら意外と通ったりするんだよね。\nたとえば：\n暗号通貨を使って資金移動できる取引所を経由してみたり 実生活で仮想通貨をそのまま使ってみたり フィアット通貨→ステーブルコインの自動化ルートを組んだり マイナーな国向けに特化した送金アプリを使ってみたり こうして銀行システムを迂回して、無理だと思ってた送金もいつの間にか実現できてたりする。\nこれってまさに、ネットワークアーキテクチャを再設計する感覚。 単なる送金じゃない。\n「価値」と「情報」を運ぶルートを、自分で定義し直してるんだ。\n5. カードで鍛えられるアーキテクト的センス 日々のルート選び、失敗とリカバリ、コストの見直し、リスクの見積もり……カード勢が普段やってること、実はめっちゃアーキテクトの訓練っぽい。\nサーバーもコードも使ってないけど、「構造を安定させて効率を高める」っていう思考は、まんまシステム設計のそれ。\n気づかないうちに、こんなスキルが身についてた：\nスキル 実際の行動 アーキテクトっぽさ ルール把握 銀行ごとの上限・仕様を把握 ドキュメント読解力 統合力 複数カードの連携・連結 システム統合の視点 コスト意識 手数料を可能な限り削る 性能とコストのバランス設計 モデル構築力 資金フローをルートで見える化 構造モデリングのセンス リスク対策 複数口座・バックアップ経由の構成 高可用性・冗長構成の考え方 美意識 「お金も、スマートに流れるべき」 設計美学、エンジニアの美意識 カードで遊んでるように見えて、現実世界でアーキテクトの脳みそを鍛えてる……そんな日常ってちょっとカッコよくない？\n6. 思考が整った瞬間に気づいたこと 手数料は敵。ルートは信仰。そして流れは芸術。\nオレがカードにハマったのは、ポイントが欲しかったからじゃない。 何度も試して、計算して、構造を調整して……その中で「流れの美しさ」に気づいてしまったから。\nコードも書かないし、サーバーも持ってないけど、 1つ1つの資金移動、設計したルート──それ全部が、自分の中のアーキテクチャだった。\n試験のためにアーキテクトの知識を詰め込んで、 でも日常の中でカードを回してるときの方が、ずっとその感覚をリアルに感じてた。\n好きなのは「やり切ること」じゃなくて、「ルートを気持ちよく設計すること」なんだ。\n他人から見たら「小手先の裏技」、でも自分の中では「構造の美学」。 「ただのポイント厨」って言われても、心の中では「生活アーキテクト」やってる。\nカードオタクって、たぶん「節約術」とか「投資ノウハウ」じゃない。 これは日常の中で、自分のシステム思考を育てていくリアルな実験場なんだと思う。\n問題を可視化して、ちょっとずつ改善して、構造を組み替えて、美しく仕上げる。 それが楽しい。\nカードは節約じゃなくて訓練だし、アーキテクチャは発明じゃなくて選択なんだ。 「いくら得したか」でも「どれだけコード書いたか」でもない。大事なのは、世界のロジックを自分の中に落とし込んだかどうか。\nそして今日も、ATMの前で10分考え込む。 「こっち経由した方が手数料安いかも」って脳内シミュレーションしながら。\nたぶんオレ、サーバーは動かしてないけど、ちゃんと設計してる。\n結論：人生こそが、最強のアーキテクチャ カードを切る、送金する、ルートを考える、最適な組み合わせを選ぶ──その全部、じつは目に見えない「システム設計」なんだよね。\nアーキテクチャって、サーバーとかAPIだけじゃない。ときには、財布やカード、支払い方法の間にひっそりと潜んでる。\nカード最適化の果てにいるのは、羊毛ハンターじゃない。\n──そこにいるのは、たぶん「生活アーキテクト」だよ。\nおまけ：オレの資金ルート（コードで書いてみた） このコード、実行用じゃないよ。ただの日常資金フローを建築っぽく書いてみただけ。「オレ、こう考えて動かしてるよ」っていう思考モデル。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 海外送金ルート（イメージ） func RouteCNYtoJPY(CNY float64) JPY float64 { HKD := BOCExchange(CNY, to=\u0026#34;HKD\u0026#34;) log.Printf(\u0026#34;Exchanged %.2f CNY to %.2f HKD\u0026#34;, CNY, HKD) Transfer(HKD, from=\u0026#34;BOC\u0026#34;, to=\u0026#34;BOCHK\u0026#34;, by=\u0026#34;pbservice\u0026#34;) log.Println(\u0026#34;Transferred via pbservice → BOCHK\u0026#34;) Transfer(HKD, from=\u0026#34;BOCHK\u0026#34;, to=\u0026#34;Wise\u0026#34;, by=\u0026#34;fpservice\u0026#34;) log.Println(\u0026#34;Transferred via fps → Wise\u0026#34;) JPY := WiseConvert(HKD, to=\u0026#34;JPY\u0026#34;) log.Printf(\u0026#34;Converted %.2f HKD to %.2f JPY via Wise\u0026#34;, HKD, JPY) Deposit(JPY, to=\u0026#34;Revolut\u0026#34;, with=\u0026#34;ApplePay\u0026#34;) return JPY } 実行じゃなくて表現用のコード。生活の資金流れを、設計図っぽく組んでみた結果ってだけ。\n※この文章はあくまで個人の趣味と記録として書かれたものであり、金融アドバイスなどを意図したものではありません。ネタとしてお楽しみください。\n","date":"2025-04-22T00:35:15+09:00","image":"https://github.com/yexca/picx-images-hosting/raw/master/2025/04-FromCardEnthusiastToArchitect/250422-JP.3d4zmh3vn7.webp","permalink":"https://blog.yexca.net/ja/archives/245/","title":"カードオタクからアーキテクトへ──生活に宿るシステム設計の哲学"},{"content":" この記事の一部は機械翻訳を使ったよ\n2023年4月、私は家計簿をつけ始めた。2025年4月、記帳をやめた。\n最後の記録：¥0\n始まり：節約とコントロールのために きっかけはシンプルでした——支出を抑え、金銭感覚を高めること。最初は確かに効果的で、無駄遣いを抑えることができました。\n過程：最適解とカード収集の世界へ しかし次第に、「より良い」消費を求めて比較を始め、最適解を探すようになりました。最初は商品の比較だけでしたが、やがて支払い方法やツール、そして銀行の特典やカード開設の世界へと進みました。\n特典のためにカードを作り、便利さのためにカードを作り、気づけばカード収集の世界にどっぷりと浸かっていました。\n最初は節約のため、次に便利さのため、そして最後にはカードを集めるため。\n反作用：記帳が負担に こうして、記帳そのものが次第に負担となっていきました。アカウントが増え、シチュエーションが複雑になるにつれ、記帳にかかる時間や精神的なコストは実際の利益を上回るようになりました。​\n数百円の特典のために何時間も調べることもありました。最初は楽しかったものの、何度も繰り返すうちに、最適解を見つけても興奮しなくなり、最初の喜びは空虚感に変わっていきました。\n変化：最適解から心地よさへ もしかすると、私自身が変わったのかもしれません。消費に対する考え方も変わりました。\n「必要に応じてお得に」から「まあまあでいい、自分が心地よければいい」へ。​\nまた、設定した予算をすでに超えていることにも気づきましたが、それでもコントロールを失うことはありませんでした。むしろ、節約よりも時間と気持ちの方が大切だと、ますます理解するようになりました。\n反省：なぜ記帳していたのか？ 記帳のために、私は以下のようなことを始めました：​\nアカウントが多いため、何度も探し回る​ 通貨の変換のために、記帳アプリで新しいアカウントを頻繁に作成​ 商品を買うべきかどうかで長時間悩む​ 友人と遊びに行った際の支出で気分が台無しになる​ 私は考えざるを得ませんでした——私はなぜ記帳していたのか？\nその中で得られる利益は、本当に価値があるのか？​\n決断：手放し、リセット、再出発 そこで私は、細かいことを気にせず、「私は幸せか？」と自問することにしました。\n結果は——本当に幸せでした。そして、支出も思ったほど多くはありませんでした。\nおそらく、習慣が私を自然に価格比較へと導いていたのでしょう。あるいは、感情の価値は、そもそも特典で測れるものではないのかもしれません。​\nだから、手放す時が来たのだと思います。​\n記帳は、その使命を果たしました。\nもはやツールではなく、束縛となっていました。​\n行動習慣は、より良い生活のためのもの。\nそれが情熱で解消できず、生活の妨げとなるなら、別れを学ぶべきです。​\n終わりに：自分に感謝し、生活を続ける 2年間続けてきた習慣を手放すのは、確かに寂しいものです。\nでも、それも人生の一部なのでしょう。一生を共にできるものはありませんが、一緒に過ごした時間が美しいものであれば、それで十分です。​\n「私は節約上手」という象徴的なツールが一つ減ったとも言えます。\nしかし、これからの自分は、数字や記録に頼って安心感を得るのではなく、真の余裕と自由さで生きていきたいと思います。​\nコントロールできる状態から、未知への流れへ。\n早く適応できることを願っています。\n節約した時間を、より意味のある、より幸せなことに使えるように。​\nだから、\n最後の一筆、¥0 短い文章を添えて。 この2年間、真剣に記録してきた自分にありがとう。 これからは、節約した時間をもっと価値のある、もっと楽しいことに使えますように。​\nこのように、この体験をアーカイブしました。\nレコーディングは終わり、人生は始まったばかり\n","date":"2025-04-14T16:23:48+09:00","permalink":"https://blog.yexca.net/ja/archives/244/","title":"節約から生活、そして別れへ"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 drop この記事 まえがき 今日は2019年12月のN1試験を試してみて、思いがけず合格した。とてもうれしいので、また日本語の勉強の記事をやろう。\nなんでこんなに可愛い曲があるな、心も溶けるかも\n動画 歌詞 夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\n君の場所びゅーんと飛んでって\nアニメみたいに2人恋に落ちて\nくすぐったいくらいに君のこと\n考える1人の夜がいいの\nふわふわと浮かぶ甘い心\n頭離れない君は悪い男？\nわからないことにもやもやして\n夢でも君のことを考えて\nあぁ いじけちゃって嫌になっても 考えちゃう\nねぇ 優しかったり冷たくなったり 迷路みたい\nあぁ 攻略サイトも見当たらないから やり直しばかり\nもー知らないもんって強がり\nでも嫌いになんてなれるわけもない\nそう思うほど胸も痛くなる愛\n私の恋のキュービットは\nいつになったら現れるの\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nひいふうみいよ 数えて\n君につぎ 会える日を楽しみに眠るの\nいつでも会えるよう\n昨日よりもかわいくなるために生きるよ\n気付いてくれるかな\n君の好きなメイクにしてみたとか (どうかな？)\n少し重すぎかな\n優柔不断で何も決まんないや (もう)\n可愛くなれるかな\n君の前だとチークはいらないか (ねえ ねえ)\n私と同じかな\nこの気持ち君も同じだといいな\n夢の中で君と過ごしても\nまた覚めるたび君が離れないの\n退屈なベッドで1人きり\nあぁ 迎えに来てよ王子様\n君を知りたい 気持ちもどかしい\nいっそシャボン玉になって弾けたい\nあぁ 君が好き なんて言えない\nたまに冷たい 君がわかんない\nふわふわな気持ちを隠しても\n君の眼を見るとまた零れるちゃうよ\n味のないケーキも君となら\n大好きな時間に変わってく\n君を知りたい もっと知りたい\n好きの2文字が口から出せない\nあぁ 君が好き を隠した日々\nたまに冷たい 君も愛おしい\n","date":"2025-02-06T22:06:10+09:00","permalink":"https://blog.yexca.net/ja/archives/230/","title":"歌から日本語を学ぼう - 《drop》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた この記事 drop https://blog.yexca.net/ja/archives/230 まえがき 私も未来のことを迷っているけど、でも生活がずっと続いているから、自分を変えなきゃね\n動画 歌詞 こんな私の未熟なうたを　聴いてくれてどうも有難うね\n未熟: みじゅく\nもう少しで私は未熟な大人に　なるみたいです\nなんか笑っちゃうね\n本当はね\nもっと前を向けるようなうたを　書くつもりだったけど\n書けなくて\n私はまだ　他の誰かを支えられるほど\n強くなかったみたい　ごめんね\n拝啓　未来の私へ　今そこで\nどんなことをして　生きていますか\n拝啓　今の私へ　今ここで\nどんなことをしたら　生きていけるんでしょうか\n\u0026ldquo;好きだからかっこいい\u0026quot;とか　\u0026ldquo;そばにいる\u0026quot;とか\n\u0026ldquo;勝手に盗んだ\u0026quot;とか　書いてた\nどうせだったらもうちょっと　貴方みたいに\nやさしいうたを書けばよかったね\n本当はね　好きなことだけして生きたいの\nでもそれは上手な生き方とは言えないから\n無駄になっても　意味がなくても\n今はここから　離れなきゃいけないの　ごめんね\n拝啓　未来の私へ　今そこで\nどんな大人になって　生きていますか\n拝啓　今の私へ　今ここで\nどんな大人になりたいと　言えばいいんでしょうか\n「さよなら」は悲しくなるからさ\n「またね」って言わせて\nいつか私が　今みたいな　うたを書けなくなっても\n怒らないでね\n拝啓　過去の私へ　今の私は\nずっと夢見ていたこと叶えてるよ\n拝啓　今の私へ\nこんな情けない　うただって歌えばいいよ\n情け: なさけ\nそれが私だから\n拝啓　未来の私へ　今そこは\nどんな綺麗な世界が　広がっていますか\n拝啓　今の私へ　今ここが\nどんな世界よりも　幸せでした\nこんな私の未熟なうたを　聴いてくれてどうも有難うね\nこれから私は未熟な大人に　なる準備をします\n「じゃあ またね」\n","date":"2025-01-25T16:57:49+09:00","permalink":"https://blog.yexca.net/ja/archives/224/","title":"歌から日本語を学ぼう - 《17さいのうた》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り この記事 17さいのうた https://blog.yexca.net/ja/archives/224 drop https://blog.yexca.net/ja/archives/230 まえがき 甘い曲だよねー\n2025年01月27日歌った、めっちゃ可愛かった！！！\n動画 歌詞 ハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\n出会っちゃった！\nときめいちゃった？ ときめく\n私だけ？ドキドキしてるの\nちゃんと気にかけて\n私だけ！甘やかして\n(Ah)　君と話す理由欲しくて探している\n(なんで？)　強がっていても恋に負けちゃうんだね\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n取られたくないんだよ…\n誰よりも可愛くなりたい\n完全勝利して\n私だけって言わせてやる！\n(Ah)　君の胸を狙う私の恋の銃口\n(なんで？)　震えちゃうんだろう\nいつか撃ち抜けるまで 撃ち抜く: うちぬく\nせーっの！BANG\n期待させてよ\nもっともっともっと\n私浮ついちゃって 浮つく: うわつく\nバカだバカだごめん\nハートは忙しくて\nあっちこっちどっちー？\n今はまだまだプロローグ\n押して押して押すの\n私、君に出会えて変わったの！\nそりゃあ悩んじゃう事もあるけど…\nもっともっと可愛くなりたいって思うし\n何より君に好きって言ってもらいたい！\n笑顔の私(可愛い)\n泣いちゃう私(可愛い)\n怒った私(可愛い)\n恋する私…\n甘えさせてよ\nずっとずっとずっと\nきっと後悔させない\nお願い　好きになって\nハートマーク作って\n届け届け届け\nきっと恋の押し売り\n好きで好きでごめん\nハートのレスください\n早く早く早くー！\nこれは恋の押し売り\n返品なんてダメよ\n","date":"2025-01-20T16:24:43+09:00","permalink":"https://blog.yexca.net/ja/archives/220/","title":"歌から日本語を学ぼう - 《恋の押し売り》"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは https://blog.yexca.net/ja/archives/214 あくあ色ぱれっと この記事 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 drop https://blog.yexca.net/ja/archives/230 まえがき また歌詞だけ書こう、次回何か日本語で感想を書くほうがいいかな。\n2025年01月27日、この曲を歌った、その時湊あくあが歌った 誇り高きアイドル を思い出した、とっても楽しかった。私もあくあ色に染まられたかもXD\n動画 歌詞 何をしても不器用で　何かとミスしてばっか\nダメダメな私だって\nできる事があるの\n凹んで悲しくたって　笑顔にしてあげるんだ\nここにいるから　早く　私を見つけてね\nLove You Love You, I love you\nLove You Love You, Ah,I love you so much\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nいつでも隣にいるし、いつでも一緒に笑える\n私をたくさん知って　たくさん好きって言って\nワガママで朝も苦手　ドジだし　ダメダメだけど\nそれでも私の事を　見ててね\n描く夢の未来へ続く\n道をキミと歩けますように\nねぇもっと！好きになってもらいたいの！\n頭の中は君ばっか！\nってゆーかそっぽなんて向いてないで！\nあぁもう！ヤキモキしちゃうわ　Ah\nずっとずっと好きがいいの\n心の奥もトキメイちゃうくらい\nこっち向いててよね　ダーリン？\nあぁもう離さないから、絶対に！\nLove You Love You, I love you\nLove You Love You\n（あぁ　愛してもっと）\nキミがいるから私　いつでも頑張れるんだ\n落ち込んで悲しくたって　キミがいるから\u0026hellip;\nキミがいるから　歩いてこれた\nキミがいなくちゃ　前も見れない\n嫌な事とか辛い事とかあったって\nキミの力でここまで笑ってこれたんだ\n今度はもっと私がぐっとひっぱって　連れて行くんだ\nキミがいるから私がいるの\nこんな私を　愛してくれる？\nねぇもっと　ねぇもっと\nまだもっと　受け止めてよね！ねぇいい？\nさぁ声を上げて！\nねぇもっと　ねぇもっと\n好きになってもらいたいの\nいつでも　そう私ばっか みたいにそっぽなんて向かせないわ\nね、ほら夢中にしちゃうわ　Ah\nずっとずっと好きがいいの！心も体も染まっちゃうくらいに\nこっち向いててよねダーリン?\nあぁもう離さないから、絶対に　絶体ね　絶体よ　約束だよ\n（あぁ 愛してもっと）\n","date":"2025-01-20T00:16:48+09:00","permalink":"https://blog.yexca.net/ja/archives/219/","title":"歌から日本語を学ぼう - 《あくあ色ぱれっと》"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: https://blog.yexca.net/ja/archives/215 使い方: この記事\n削除 パラメータ名を中に入れたプレースホルダとして #{} を使用します\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public void delete(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test void contextLoads() { empMapper.delete(17); } } 通常、戻り値は必要ありません。戻り値は、この操作によって影響を受ける行の数です。\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // 削除 @Delete(\u0026#34;delete from mybatis.emp where id = #{id}\u0026#34;) public int delete(Integer id); } プレースホルダー パラメータプレースホルダは #{} と ${} です\nプレースホルダー #{} ${} 形状 プリコンパイル スプライシング いつ使うか パラメータの受け渡し、ログインなど テーブル名とリストを動的に設定する 長所と短所 安全性と高性能 SQLインジェクションの問題がある 挿入（新規） プレースホルダも使用されますが、渡されるパラメータが多すぎる場合は、オブジェクトのカプセル化を使用することができ、正式なパラメータ名はオブジェクトのパラメータ名になります。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testInsert(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom\u0026#34;); emp.setName(\u0026#34;トム\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } } 主キーの値を取得する 場合によっては、データが正常に追加された後、データベースに挿入されたデータの主キーを取得する必要があります。\n1 2 3 4 5 6 7 8 9 @Mapper public interface EmpMapper { // 主キーを取得します。最初の属性は、emp オブジェクトの id 属性に割り当てられた主キー値を定義します。2 番目の属性は、返される主キー値を表します。 @Options(keyProperty = \u0026#34;id\u0026#34;, useGeneratedKeys = true) // 増加 @Insert(\u0026#34;insert into mybatis.emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) \u0026#34;+ \u0026#34;values (#{username},#{name},#{gender},#{image},#{job},#{entrydate},#{deptId},#{createTime},#{updateTime});\u0026#34;) public void insert(Emp emp); } 更新（変更） 増加と同様に、オブジェクトにカプセル化することができます\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 変更 @Update(\u0026#34;update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, \u0026#34;+ \u0026#34;entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id};\u0026#34;) public void update(Emp emp); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testUpdate(){ Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom2\u0026#34;); emp.setName(\u0026#34;トム2\u0026#34;); emp.setGender((short) 1); emp.setImage(\u0026#34;tom.jpg\u0026#34;); emp.setJob((short) 1); emp.setEntrydate(LocalDate.of(2000,1,1)); emp.setDeptId(1); emp.setUpdateTime(LocalDateTime.now()); emp.setId(19); empMapper.update(emp); } } クエリ クエリには、IDに基づいてすべての属性をクエリするクエリと条件に基づいてクエリするクエリの2種類があります。\nIDによるクエリ インタフェース\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testIdSelect(){ Emp emp = empMapper.idSelect(19); System.out.println(emp); } } 結果\n1 Emp(id=19, username=Tom2, password=123456, name=汤姆2, gender=1, image=tom.jpg, job=1, entrydate=2000-01-01, deptId=null, createTime=null, updateTime=null) クラス Emp のフィールド名がデータベースと異なるため、クエリ結果は null になります。\n解決方法は3つあります\nエイリアスの使用 1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // 方法 1: エイリアス @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime\u0026#34; + \u0026#34; from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } @Results アノテーションの使用 1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // 方法 2: @Results @Result アノテーション @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 自動包装の使用 フィールド名と属性名がキャメルケース命名規則に準拠している場合は、自動キャメルケース命名カプセル化を有効にすることができ、Mybatisはキャメルケース命名規則に従って自動的にマッピングします。具体的には、データベースはアンダースコア「a_column」をJava属性「aColumn」にマッピングします。\nキャメルケース命名を有効にするには、application.propertiesに追加します。\n1 mybatis.configuration.map-underscore-to-camel-case=true 然后直接使用最初的代码\n1 2 3 4 5 6 @Mapper public interface EmpMapper { // IDによるクエリ @Select(\u0026#34;select * from mybatis.emp where id = #{id}\u0026#34;) public Emp idSelect(Integer id); } 使いやすさのために、IDEA に MyBatisX プラグインをインストールすることができます。\n条件による検索 要件: 従業員名 (あいまい一致)、性別 (完全一致)、雇用日 (範囲) に基づいて条件を満たす従業員情報を検索します。\n1 2 3 4 5 6 7 8 @Mapper public interface EmpMapper { // 条件による検索 // \u0026#39;%${name}%\u0026#39; のように名前に使用される ${} は、\u0026#39;\u0026#39; 内でも使用できることに注意してください。 @Select(\u0026#34;select * from mybatis.emp where name like \u0026#39;%${name}%\u0026#39; and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 文字列の連結には補間が使用されるため、この方法は安全ではありません。\n1 2 3 4 5 6 7 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } concat 関数は文字列を連結するために使用されます。テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class Mybatis02ApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testConditionSelect(){ List\u0026lt;Emp\u0026gt; empList = empMapper.conditionSelect(\u0026#34;张\u0026#34;, (short) 1, LocalDate.of(2010, 1, 1), LocalDate.of(2020, 1, 1)); System.out.println(empList); } } パラメータ名の説明 SQLで使用される#{}内の変数名はSpringBoot 2.x以降では自動的に認識されますが、バージョン1.xまたはMyBatisのみを使用する場合は、メソッド内で定義された変数名をアノテーションを使用して指定する必要があります。\n1 2 3 4 5 6 7 8 9 10 11 @Mapper public interface EmpMapper { // より安全な条件付きクエリ @Select(\u0026#34;select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } // 上記のコードは1.xでは動作しません。またMyBatisのみを使用する場合も動作しません。関数に注釈を付ける必要がある。 public List\u0026lt;Emp\u0026gt; conditionSelect(@Param(\u0026#34;name\u0026#34;) String name, @Param(\u0026#34;gender\u0026#34;) short gender, @Param(\u0026#34;begin\u0026#34;) LocalDate begin, @Param(\u0026#34;end\u0026#34;) LocalDate end); XML マッピングファイルの使用 SQL コードが比較的短い場合は、アノテーションを使用すると便利ですが、SQL が長かったり複雑だったりする場合は、少し乱雑に見えます。この目的のために、XML マッピング ファイルを使用できます。仕様は以下の通りです\nXML マッピングファイルの名前は Mapperイ ンターフェースの名前と一致しており、XML マッピングファイルと Mapper インターフェースは同じパッケージ（同じパッケージ、同じ名前）に配置されています。 XML の名前空間属性は Mapper インターフェースの完全修飾名と一致している XML 内の SQL 文の id 属性は Mapper インターフェースのメソッド名と一致しており、戻り値の型も一致している XML Maven プロジェクトでは、Java 以外のファイルは src/main/resources の下に配置されます。このディレクトリの下に Mapper インターフェースと一致するディレクトリを作成します。\nインターフェースが net.yexca.mapper.EmpMapper.java の場合、XML ファイルは net.yexca.mapper.EmpMapper.xml にあります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;https://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- 上記のヘッダーファイルを見つけるには、公式ウェブサイトにアクセスしてください。 --\u0026gt; \u0026lt;!-- namespace 属性はインターフェースである --\u0026gt; \u0026lt;mapper namespace=\u0026#34;net.yexca.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;!-- id属性はメソッド名です --\u0026gt; \u0026lt;!-- resultTypeは単一のレコードでカプセル化された型です --\u0026gt; \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender = #{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; インターフェースクラス 1 2 3 4 @Mapper public interface EmpMapper { public List\u0026lt;Emp\u0026gt; conditionSelect(String name, short gender, LocalDate begin, LocalDate end); } 動的 SQL 動的 SQL は、ユーザー入力または外部条件に応じて変化する SQL ステートメントです。\nたとえば、上記の最後の条件クエリでは、クエリを実行するために 3 つの条件すべてを入力する必要があります。実際の使用では、1 つまたは 2 つの条件のみを指定するか、指定しない (すべてをクエリする) ことができます。上記の手順に従って実行すると、空の結果が返されます。\nwhere if 条件が真であるかどうかを判断するために使用されます。条件判定を実行するには、テスト属性を使用します。条件が真の場合、SQLを連結します。\nたとえば、名前が空でない場合、連結条件は名前によって照会されます。\n1 2 3 \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like contact(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; where タグは、where キーワードを生成するかどうか、および and キーワードと or キーワードを自動的に削除するかどうかを管理します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;conditionSelect\u0026#34; resultType=\u0026#34;net.yexca.pojo.Emp\u0026#34;\u0026gt; select * from mybatis.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; set SQL の set キーワードを置き換え、UPDATE ステートメントで使用する余分なカンマを自動的に削除します。\nたとえば、次のSQL文は動的SQLに変更されます。\n1 2 3 4 5 6 7 8 9 10 update mybatis.emp set username = #{username}, name = #{name}, gender = #{gender}, image = #{image}, job = #{job}, entrydate = #{entrydate}, dept_id = #{deptId}, update_time = #{updateTime} where id = #{id}; XML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update mybatis.emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt;username = #{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt;name = #{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt;gender = #{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt;image = #{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt;job = #{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entrydate != null\u0026#34;\u0026gt;entrydate = #{entrydate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt;dept_id = #{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt;update_time = #{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; foreach foreach タグはトラバーサルに使用されます\n1 2 3 4 \u0026lt;!--走査するコレクション 横断された要素 デリミタ 開始前と開始後に連結されたSQLフラグメント--\u0026gt; \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; ids が [13, 14, 15] の場合、上記は (13,14,15) を生成します。\n要件: ID 1、2、3 の項目を走査して削除します。 SQL文は\n1 delete from emp where id in(1,2,3) インターフェースメソッド\n1 public void deleteByIds(List\u0026lt;Integer\u0026gt; ids); XML\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from mybatis.emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; テスト\n1 2 3 4 5 @Test public void testDeleteByIds(){ List\u0026lt;Integer\u0026gt; ids = Arrays.asList(13,14,15); empMapper.deleteByIds(ids); } sql と include 開発プロセスでは、多数の SQL ステートメントが繰り返される場合があります。sql タグを使用して再利用可能な SQL フラグメントを定義し、include タグを使用して再利用できます。\n1 2 3 4 5 6 7 \u0026lt;!-- id属性を通じてステートメントを一意に識別する --\u0026gt; \u0026lt;sql id = \u0026#34;commonCode\u0026#34;\u0026gt; \u0026lt;!-- SQL语句 --\u0026gt; \u0026lt;/sql\u0026gt; \u0026lt;!-- refid 属性は参照ステートメントを指定します。 --\u0026gt; \u0026lt;include refid = \u0026#34;commonCode\u0026#34; /\u0026gt; ","date":"2025-01-13T21:06:03+09:00","permalink":"https://blog.yexca.net/ja/archives/216/","title":"MyBatis 使い方"},{"content":" この記事の一部は機械翻訳を使ったよ\nMyBatis シリーズ\nインストールと開始方法: この記事\n使い方: https://blog.yexca.net/ja/archives/216 MyBatis は JDBC 開発を簡素化する優れた永続層フレームワークです。\nMySQL インストール (Windows) ダウンロード: https://dev.mysql.com/downloads/mysql/ ZIP Archive をダウンロード\n解凍し、環境変数 MYSQL_HOME PATH パス %MYSQL_HOME%\\bin を設定します。\n管理者権限で cmd を開き、mysql と入力して、設定が成功したかどうかを確認します。\nMySQL を初期化する コマンドを入力してください\n1 mysqld --initialize-insecure しばらく待つと、MySQL ディレクトリに data フォルダが生成されます。\nMySQL サービスを登録する コマンド\n1 mysqld -install MySQL サービスを開始する コマンド\n1 2 3 4 # mysqlサービスを開始する net start mysql # mysqlサービスを停止する net stop mysql root パスワードを変える コマンド\n1 mysqladmin -u root password 1234 ログインパラメータ\n1 2 3 4 mysql -u ユーザー名 -p パスワード -h 接続するMySQLサーバーのIPアドレス (デフォルト127.0.0.1) -P ポート番号 (デフォルト 3306) # 例えば mysql -u root -p # 実行後、パスワードの入力を求められます 入門例 まず、SpringBoot プロジェクトを作成し、依存関係「MyBatis Framework」と「MySQL Driver」を選択します。\nデータベース 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 create database mybatis; use mybatis; create table user( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, name varchar(100) comment \u0026#39;名前\u0026#39;, age tinyint unsigned comment \u0026#39;年齢\u0026#39;, gender tinyint unsigned comment \u0026#39;性別, 1:男, 2:女\u0026#39;, phone varchar(11) comment \u0026#39;電話番号\u0026#39; ) comment \u0026#39;ユーザーテーブル\u0026#39;; insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;白眉鹰王\u0026#39;,55,\u0026#39;1\u0026#39;,\u0026#39;18800000000\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;金毛狮王\u0026#39;,45,\u0026#39;1\u0026#39;,\u0026#39;18800000001\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;青翼蝠王\u0026#39;,38,\u0026#39;1\u0026#39;,\u0026#39;18800000002\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;紫衫龙王\u0026#39;,42,\u0026#39;2\u0026#39;,\u0026#39;18800000003\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明左使\u0026#39;,37,\u0026#39;1\u0026#39;,\u0026#39;18800000004\u0026#39;); insert into user(id, name, age, gender, phone) VALUES (null,\u0026#39;光明右使\u0026#39;,48,\u0026#39;1\u0026#39;,\u0026#39;18800000005\u0026#39;); application.properties 1 2 3 4 5 6 7 8 9 10 # データベース接続情報を構成する # ドライバークラス名 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver # データベース接続URL spring.datasource.url=jdbc:mysql://localhost:3306/mybatis # データベースに接続するためのユーザー名 spring.datasource.username=root # データベースに接続するためのパスワード spring.datasource.password=1234 User クラス 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class User { private Integer id; private String name; private short age; private short gender; private String phone; public User() { } public User(Integer id, String name, short age, short gender, String phone) { this.id = id; this.name = name; this.age = age; this.gender = gender; this.phone = phone; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public short getAge() { return age; } public void setAge(short age) { this.age = age; } public short getGender() { return gender; } public void setGender(short gender) { this.gender = gender; } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, gender=\u0026#34; + gender + \u0026#34;, phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } UserMapper インタフェース 1 2 3 4 5 6 @Mapper // 実行時に、インターフェースの実装クラスオブジェクト（プロキシオブジェクト）が自動的に生成され、管理のために IOC コンテナに引き渡されます。 public interface UserMapper { // ここではアノテーションを使用してSQL文を記述します @Select(\u0026#34;select * from user\u0026#34;) public List\u0026lt;User\u0026gt; list(); } テストクラス 1 2 3 4 5 6 7 8 9 10 11 12 @SpringBootTest class MybatisStartApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List\u0026lt;User\u0026gt; list = userMapper.list(); list.forEach(System.out::println); } } データベース接続プール データベース接続プールは、データベース接続 (Connection) の割り当てと管理を担当するコンテナです。\nこれにより、アプリケーションは新しいデータベース接続を確立する代わりに、既存のデータベース接続を再利用できます。\nアイドル時間が最大アイドル時間を超える接続を解放して、接続の解放の失敗によるデータベース接続の喪失を回避します。\n利点: リソースの再利用とシステム応答速度の向上\n公式標準インターフェース: DataSource\n一般的な製品: Hikari (SpringBoot デフォルト)、Druid\nLombok 上記の例では、User クラスはいくつかの属性のみを定義していますが、多くのメソッドが必要なため、コードが肥大化しています。この目的には、Lombok を使用できます。\nLombok は、アノテーションを通じてコン​​ストラクター、getter/setter、equals、hashcode、toString などのメソッドを自動的に生成し、ログ変数を自動的に生成して Java 開発を簡素化し、効率を向上させる実用的な Java クラス ライブラリです。\n注釈 効果 @Getter/@Setter すべてのプロパティに get/set メソッドを提供する @ToString クラスの読みやすい toString メソッドを自動的に生成します @EqualsAndHashCode クラスが所有する非静的フィールドに基づいて、equals メソッドと hashCode メソッドを自動的にオーバーライドします。 @Data より包括的なコード生成機能を提供します(@Getter+@Setter+@ToString +@EqualsAndHashCode) @NoArgsConstructor エンティティクラスのパラメータなしのコンストラクタメソッドを生成する @AllArgsConstructor static 変更フィールドに加えて、エンティティ クラスのパラメータを持つコンストラクタ メソッドを生成します。 Lombok の導入 依存関係を導入します。バージョン番号は不要で、SpringBoot によって設定されます。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; User クラス 1 2 3 4 5 6 7 8 9 10 @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private short age; private short gender; private String phone; } Lombok はコンパイル時に対応する Java コードを自動的に生成します。Lombok を使用するにはプラグインをインストールする必要がありますが、IDEA ではデフォルトでインストールされています。\n","date":"2025-01-12T23:59:48+09:00","permalink":"https://blog.yexca.net/ja/archives/215/","title":"MyBatis のインストールと開始方法"},{"content":" 日本語曲シリーズ\n曲 リンク 僕が死のうと思ったのは この記事 あくあ色ぱれっと https://blog.yexca.net/ja/archives/219 恋の押し売り https://blog.yexca.net/ja/archives/220 17さいのうた https://blog.yexca.net/ja/archives/224 drop https://blog.yexca.net/ja/archives/230 まえがき てっ、この記事は日本語なので、もう日本語の勉強じゃない？書く必要がないかもね\nまあ、とりあえず歌詞を書こうかな\n動画 歌詞 僕が死のうと思ったのは　ウミネコが桟橋で鳴いたから\n桟橋: さんばし\n波の随意に浮かんで消える　過去も啄ばんで飛んでいけ\n啄ばむ: ついばむ\n僕が死のうと思ったのは　誕生日に杏の花が咲いたから\n杏: あんず\nその木漏れ日でうたた寝したら　虫の死骸と土になれるかな\n木漏れ日: こもれび　死骸: しがい　土: つち\n薄荷飴　漁港の灯台　錆びたアーチ橋　捨てた自転車\n薄荷: はっか　漁港: ぎょこう　灯台: とうだい　錆びる: さびる\n木造の駅のストーブの前で　どこにも旅立てない心\n旅立つ: たびだつ\n今日はまるで昨日みたいだ　明日を変えるなら今日を変えなきゃ\n分かってる　分かってる　けれど\n僕が死のうと思ったのは　心が空っぽになったから\n満たされないと泣いているのは　きっと満たされたいと願うから\n僕が死のうと思ったのは　靴紐が解けたから\n靴紐: くつひも　解ける: ほどける\n結びなおすのは苦手なんだよ　人との繋がりもまた然り\n然り: しかり\n僕が死のうと思ったのは　少年が僕を見つめていたから\nベッドの上で土下座してるよ　あの日の僕にごめんなさいと\nパソコンの薄明かり　上階の部屋の生活音\n薄上がり: うすあがり\nインターフォンのチャイムの音　耳を塞ぐ鳥かごの少年\n鳥かご: とりかご\n見えない敵と戦ってる　六畳一間のドンキホーテ\n一間: ひとま\nゴールはどうせ醜いものさ\n醜い: みにくい\n僕が死のうと思ったのは　冷たい人と言われたから\n愛されたいと泣いているのは　人の温もりを知ってしまったから\n温もり: ぬくもり\n僕が死のうと思ったのは　あなたが奇麗に笑うから\n死ぬことばかり考えてしまうのは　きっと生きる事に真面目すぎるから\n僕が死のうと思ったのは　まだあなたに出会ってなかったから\nあなたのような人が生まれた　世界を少し好きになったよ\nあなたのような人が生きてる　世界に少し期待するよ\n","date":"2025-01-11T01:10:51+09:00","permalink":"https://blog.yexca.net/ja/archives/214/","title":"歌から日本語を学ぼう - 《僕が死のうと思ったのは》"},{"content":" この記事の一部は機械翻訳を使ったよ\nまえがき 今日は最近設計した半透明、すりガラスと丸みを帯びた角についてまとめようと思っていたけど、突然2023年12月01日何かを作ったことを思い出したので、それも一緒に再編成しようと思う\nウェブサイトの背景 現代の (アニメ風) ウェブページは背景が必要だ\n1 2 3 4 5 6 7 8 body{ background-image: url(\u0026#39;../img/77194247_p0.jpg\u0026#39;); background-size: cover; background-attachment: fixed; /* 固定 */ background-repeat: no-repeat; /* 繰り返さない */ padding: 0; margin: 0; } 半透明とすりガラス そして、背景にマスクを加えて、半透明効果とすりガラス効果を実現する\n1 2 3 4 5 6 7 8 9 10 11 .layout { /* display: flex; */ margin: 0; padding: 0; display: flex; width: 100vw; height: 100vh; backdrop-filter: blur(2px); /* 背景ぼかし効果 */ -webkit-backdrop-filter: blur(2px); /* Safari サポート */ background: rgba(0, 0, 0, 0.4); /* 半透明黒い背景 */ } ウェブページのリニューアル そういえば、文章を書くのは面倒だな。プログラムしていると邪魔されて、プログラムが終わった時はとても疲れてしまったので、書きたくなくなった。だから今は気軽に文章を書いている\nプロジェクトのリング: https://github.com/yexca/MusicPlayer-Twinkle 顺便更新了下之前的文章 https://blog.yexca.net/archives/116/ 用此方法加了个示例: https://twinkle.yexca.net ところで、以前の文章も更新したよ (簡体字中国語で) https://blog.yexca.net/archives/116/ その方法で例を作った: https://twinkle.yexca.net カード効果 これも現代的な設計だよねー\n1 2 3 4 5 6 7 8 9 10 .card { width: 300px; padding: 20px; background-color: rgba(255, 255, 255, 0.5); /* 半透明白い背景 */ border-radius: 15px; /* 丸みを帯びた角 */ box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 影 */ backdrop-filter: blur(10px); /* 背景ぼかし効果 */ border: 1px solid rgba(255, 255, 255, 0.3); /* ボーダー */ color: pink; /* 文字の色 */ } まあ、時間があればカードのデザインを基にしてプロジェクトを進めよう (また新しい沼にハマっちゃった)\nTwinkle ちなみに、プロジェクトの内容は Twinkle の音楽、詳しくはこちら\nhttps://twinkle130527.wixsite.com/twinkle https://www.dojin-music.info/circle/1255 SoundCloud\nhttps://soundcloud.com/twintwinkles ","date":"2025-01-05T16:19:36+09:00","permalink":"https://blog.yexca.net/ja/archives/212/","title":"すりガラス効果"},{"content":" この記事の一部は機械翻訳を使ったよ\nGo バックエンドのシンプルな (非技術的なフレームワーク) 実装\n~~皆さんご存知のとおり、~~バックエンド開発は一般的にインターフェース指向開発、つまり CRUD エンジニアです。この記事では、Go を使用して、データベースからデータを読み取り、JSON データを返す方法について説明します。\nデータベース この例では、MySQL データベースのカテゴリ テーブルからカテゴリ名と ID を読み取ります。テーブル構造は次のとおりです。\n1 2 3 4 5 6 DROP TABLE IF EXISTS categories ; CREATE TABLE categories ( id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, description VARCHAR(255) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; プロジェクト構造 この例のプロジェクト構造は次のようになります。\n1 2 3 4 5 6 7 8 9 10 11 12 13 project/ ├── database/ // データベースパッケージ │ └── database.go // データベース接続 ├── handler/ // ハンドラパッケージ │ └── category.go // カテゴリ関連のインターフェース ├── model/ // データモデルパッケージ │ ├── category.go // カテゴリテーブルモデル │ └── response.go // レスポンスデータモデル ├── router/ // ルーティングパッケージ │ └── router.go // ルーティング設定 ├── utils // ツールキット │ └── response.go // 統合レスポンス ├── main.go // プログラムエントリ 次にディレクトリについて説明します\ndatabase このパッケージはデータベースへの接続を管理します\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // database.go package database import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; _ \u0026#34;github.com/go-sql-driver/mysql\u0026#34; ) var DB *sql.DB func InitDB() { var err error dsn := \u0026#34;username:password@tcp(address:3306)/name?charset=utf8\u0026#34; DB, err = sql.Open(\u0026#34;mysql\u0026#34;, dsn) if err != nil { log.Fatalf(\u0026#34;Failed to open database: %v\u0026#34;, err) } // Test Connect err = DB.Ping() if err != nil { log.Fatalf(\u0026#34;Failed to ping database: %v\u0026#34;, err) } fmt.Println(\u0026#34;Successfully connected Database!\u0026#34;) } handler このパッケージは、特定の処理のロジック（3 層アーキテクチャの service に似ています）を処理して、データベース処理も階層化できます（Mapper に似ています）が、これは単なる簡単な例です、それだけです〜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // category.go package handler import ( \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/model\u0026#34; \u0026#34;project/utils\u0026#34; ) func GetCategories(w http.ResponseWriter, r *http.Request) { // Select Database rows, err := database.DB.Query(\u0026#34;select id,name from categories\u0026#34;) if err != nil { http.Error(w, \u0026#34;Failed to query Categories\u0026#34;, http.StatusInternalServerError) return } defer rows.Close() // analyze data var categories []model.Category for rows.Next() { var category model.Category err = rows.Scan(\u0026amp;category.Id, \u0026amp;category.Name) if err != nil { utils.JSONResponse(w, http.StatusInternalServerError, \u0026#34;Failed to analyze Categories\u0026#34;, nil) //http.Error(w, \u0026#34;Failed to analyze Categories\u0026#34;, http.StatusInternalServerError) return } categories = append(categories, category) } // return JSON //w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) //json.NewEncoder(w).Encode(categories) utils.JSONResponse(w, http.StatusOK, \u0026#34;\u0026#34;, categories) } コメントアウトされた内容は統合レスポンスインターフェースには適用されず、JSON が直接返されます。\nmodel ここでのデータモデルは、一般的にフロントエンドから受け取るもの、データベースから受け取るもの、フロントエンドに返すものの 3 つに分けられます。これは単純な例なので、細かくは説明していません。\n1 2 3 4 5 6 7 8 // category.go package model type Category struct { Id int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Description string `json:\u0026#34;description\u0026#34;` } 応答のデータモデルは\n1 2 3 4 5 6 7 package model type Response struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msf\u0026#34;` Data interface{} `json:\u0026#34;data\u0026#34;` } router このパッケージはルーティング、つまり、どのパスにアクセスして対応する処理ロジックを指定するかを管理します（3 層アーキテクチャの controller に似ています）\n1 2 3 4 5 6 7 8 9 10 11 12 13 // router.go package router import ( \u0026#34;github.com/gorilla/mux\u0026#34; \u0026#34;project/handler\u0026#34; ) func InitRouter() *mux.Router { router := mux.NewRouter() router.HandleFunc(\u0026#34;/categories\u0026#34;, handler.GetCategories).Methods(\u0026#34;GET\u0026#34;) return router } utils このパッケージはツールクラスであり、一般的なツールを定義するために使用されます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // response.go package utils import ( \u0026#34;encoding/json\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/model\u0026#34; ) func JSONResponse(w http.ResponseWriter, code int, message string, data interface{}) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json; charset=utf-8\u0026#34;) w.WriteHeader(http.StatusOK) err := json.NewEncoder(w).Encode(model.Response{Code: code, Msg: message, Data: data}) if err != nil { log.Fatal(err) return } } main プログラムエントリー\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // main.go package main import ( \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;project/database\u0026#34; \u0026#34;project/router\u0026#34; ) func main() { // init Database database.InitDB() // Init Router r := router.InitRouter() // start log.Println(\u0026#34;Starting server on port 8848\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8848\u0026#34;, r)) } go run main.go を実行すると、プログラムはポート 8848 をリッスンします。\n","date":"2024-12-22T22:07:15+08:00","permalink":"https://blog.yexca.net/ja/archives/208/","title":"GoLang バックエンドを使い始める"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: この記事\nゴルーチン (Goroutine) は channel を通じてデータを転送できます。参照型 channel は複数の Goroutine が通信するために使用できます。同時実行の安全性を確保するために、内部で同期を実装します。\nこれは、 RabbitMQ (簡体字中国語) に似ています (これは学習に便宜上の例えです、実は異なるものです)\n変数を定義する channel は参照型です。関数をコピーまたは呼び出すと、同じ channel オブジェクトが参照されます。ゼロ値は nil です。\nmake() 関数によって作成される。例えば\n1 2 3 c := make(chan int) // 容量を 3 に追加 c := make(chan int, 3) 容量が 0 の場合、channel はバッファリングされず、読み取りと書き込みがブロックされます。 容量が 0 より大きい場合、キャッシュがあり、非ブロッキングであり、いっぱいになるまでブロックされません。\nデータの送受信には \u0026lt;- を使用します\n1 2 3 4 5 6 7 8 // channel にデータを送信する channel \u0026lt;- 3 // 受信して破棄 \u0026lt;-channel // スペースがないことに注意してください // 値を受け取って変数に割り当てる x := \u0026lt;-channel // 受信して変数に割り当て、受信が成功したかどうか（channel が空かどうか）を判定します data, flag := \u0026lt;-channel バッファリングなし 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) c \u0026lt;- 6 fmt.Println(\u0026#34;A running\u0026#34;) }() num := \u0026lt;-c fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main over\u0026#34;) } バッファリング 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) go func() { defer fmt.Println(\u0026#34;A over\u0026#34;) for i := 0; i \u0026lt; 3; i++ { c \u0026lt;- i fmt.Println(\u0026#34;A goroutine, i =\u0026#34;, i, \u0026#34;len =\u0026#34;, len(c), \u0026#34;cap =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 3; i++ { num := \u0026lt;-c fmt.Println(\u0026#34;main, num =\u0026#34;, num) } fmt.Println(\u0026#34;main over\u0026#34;) } channel を閉じる close() で閉じる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // 閉じる close(c) }() for { if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main Finished\u0026#34;) } range の使用 上記の main の for ループは、range を使用して短縮することができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int, 5) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } close(c) }() //for { // if data, ok := \u0026lt;-c; ok { // fmt.Println(data) // } else { // break // } //} for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main Finished\u0026#34;) } 一方向 channel デフォルトでは、channel は双方向、つまり読み取りと書き込みが可能です。チャネルの方向を読み取り専用または書き込み専用に指定することもできます。\n1 2 3 4 5 var c chan int // 通常の双方向チャネルを宣言する // c1 は書き込みのみ可能 var c1 chan\u0026lt;- int // c2 は読み取り専用です var c2 \u0026lt;-chan int 双方向チャネルを一方向チャネルに変換することは可能ですが、その逆はできません。つまり、関数パラメータを一方向として定義し、それを双方向に渡すことができます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // chan\u0026lt;- // 書き込みのみ func counter(out chan\u0026lt;- int) { defer close(out) for i := 0; i \u0026lt; 5; i++ { out \u0026lt;- i // 相手が読んでいない場合はブロックします } } // \u0026lt;-chan // 読み取り専用 func printer(in \u0026lt;-chan int) { for num := range in { fmt.Println(num) } } func main() { c := make(chan int) // 双方向 go counter(c) // プロデューサー printer(c) // 消費者 fmt.Println(\u0026#34;done\u0026#34;) } select select は複数の channel 上のデータ フローを監視できます。構文は switch に似ていますが、各 case ステートメントには IO 操作が含まれている必要があります。\n通常は for{} コードブロック内に置く\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main x, y := 1, 1 for { select { case c \u0026lt;- x: tmp := x x = y y = tmp + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return // デフォルトを設定することもできますが、この例では不要です } } } ","date":"2024-12-21T14:52:55+08:00","permalink":"https://blog.yexca.net/ja/archives/207/","title":"GoLang チャンネル"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: この記事\nGoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 プロセス -\u0026gt; スレッド -\u0026gt; コルーチン\nコルーチン (coroutine) は軽量スレッドとも呼ばれます。システム リソースを使い果たすことなく、数万のコルーチンを簡単に作成できます。複数のコルーチンは、スレッドに割り当てられたコンピューター リソースを共有します。\nGo 言語は、ゴルーチン (goroutine) と呼ばれるコルーチンをネイティブにサポートしています。Go の並行性は、goroutine と channel を通じて実装されます。\ngoroutine を作成する go キーワードでゴルーチンを開始する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func newTask() { i := 0 for { fmt.Println(\u0026#34;newTask goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } func main() { go newTask() i := 0 for { fmt.Println(\u0026#34;main goroutine i =\u0026#34;, i) i++ time.Sleep(1 * time.Second) } } 匿名関数の使用 もちろん、匿名関数を使用することもできます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } 匿名関数は戻り値に実体パラメータを持つこともできますが、goroutine の戻り値は channel を介して送信する必要があります。次の例では、実体パラメータのみを示しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func(a, b int) { fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;b =\u0026#34;, b) }(10, 20) time.Sleep(2 * time.Second) } 退出 メインの goroutine が終了すると、他の動作中の goroutine も自動的に終了します。\nただし、runtime.Goexit() を使用して、現在の goroutine の実行を直ちに終了することもできます (defer が実行されます)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) runtime.Goexit() // ゴルーチンを終了する fmt.Println(\u0026#34;B\u0026#34;) }() // 匿名関数の実行を示します fmt.Println(\u0026#34;A\u0026#34;) }() time.Sleep(2 * time.Second) } /* * 出力 * B.defer * A.defer */ ","date":"2024-12-17T21:16:31+08:00","permalink":"https://blog.yexca.net/ja/archives/206/","title":"GoLang ゴルーチン"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: この記事\nGoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 構造タグはパッケージ内のクラスの役割を記述するために使用できます。\nタグの値を取得する tag を定義するには ` を使用します (markdown コードブロックのキー)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { // 複数の tag はスペースで区切られます name string `doc:\u0026#34;name\u0026#34; info:\u0026#34;nameOfUser\u0026#34;` age int `info:\u0026#34;ageOfUser\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} findTag(\u0026amp;user) } func findTag(input interface{}) { t := reflect.TypeOf(input).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { tagInfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagDoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, tagInfo, \u0026#34;doc:\u0026#34;, tagDoc) } } JSON 変換 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type User struct { // パブリックプロパティのみが JSON に変換できることに注意してください Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} // struct --\u0026gt; json jsonStr, err := json.Marshal(user) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Printf(\u0026#34;jsonStr : %s\\n\u0026#34;, jsonStr) } // json --\u0026gt; struct var user2 User err = json.Unmarshal(jsonStr, \u0026amp;user2) if err != nil { fmt.Println(\u0026#34;error\u0026#34;, err) } else { fmt.Println(user2) } } ","date":"2024-12-11T18:31:18+08:00","permalink":"https://blog.yexca.net/ja/archives/205/","title":"GoLang 構造タグ"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: この記事\nGoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 反射指の一種の用途であり、自己記述と自己制御が可能です\npair Go 言語变量には type と value の部分が含まれ、pair で構成されます\nstatic type はコード実行時に見られるタイプであり、concrete type は runtime システムに見られるタイプです。\nこのタイプは、static type ではなく変数の concrete type に応じて成功するかどうかを判断します。したがって、concrete type が write メソッドの命令も実装している場合、タイプは write として承認される可能性があります。\n反射はタイプに基づいて確立され、静的タイプであり、固定されているため、反射は主に interface タイプに関係します (concrete type)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import \u0026#34;fmt\u0026#34; type ReadBook interface { Read() } type WriteBook interface { Write() } type Book struct { } func (this *Book) Read() { fmt.Println(\u0026#34;read Book\u0026#34;) } func (this *Book) Write() { fmt.Println(\u0026#34;write Book\u0026#34;) } func main() { // b: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; b := \u0026amp;Book{} // r: pair\u0026lt;type:, value:\u0026gt; var r ReadBook // r: pair\u0026lt;type:Book, value:book{} のアドレス\u0026gt; r = b r.Read() var w WriteBook w = r.(WriteBook) // r のタイプは Book であるため w.Write() } TypeOf と ValueOf Reflect.TypeOf() は pair 中の type を取得します、reflect.ValueOf() は pair 中の value を取得します\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) // float64 fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 3.14 } 型转换 reflect.ValueOf() を実行すると、型が reflect.Value 变量になります。\n既知原データの種類 既知原データ型は直接强制转换可能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) value := reflect.ValueOf(a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, value) // reflect.Value newA := value.Interface().(float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // float64 } 型変換は完全に一貫している必要があることに注意することが重要です。そうでないと、ポインタなどの panic が発生します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 fmt.Println(\u0026#34;type of a:\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;value of a:\u0026#34;, reflect.ValueOf(a)) // 輸送先住所 point := reflect.ValueOf(\u0026amp;a) fmt.Printf(\u0026#34;type of value:%T\\n\u0026#34;, point) // reflect.Value // 型をポインタに変換する newA := point.Interface().(*float64) fmt.Printf(\u0026#34;type of newA:%T\\n\u0026#34;, newA) // *float64 } つまり、反射することができます \u0026ldquo;反射型オブジェクト\u0026rdquo; 再再再转换は \u0026ldquo;インターフェース変数\u0026rdquo;\n未知原データ型 Field を横断して取得\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type Person struct { // 一行は 1 つの field です Name string Age int Rank float64 } // メソッドはパブリックであることに注意してください。プライベートの場合はアクセスできません。 func (person Person) Sleep() { fmt.Println(\u0026#34;person sleep\u0026#34;) } func main() { p := Person{\u0026#34;zhangSan\u0026#34;, 18, 5.2} getFieldAndMethod(p) } func getFieldAndMethod(input interface{}) { getType := reflect.TypeOf(input) fmt.Println(\u0026#34;type:\u0026#34;, getType.Name()) getValue := reflect.ValueOf(input) fmt.Println(\u0026#34;value/AllField:\u0026#34;, getValue) // 属性を取得します numField := getValue.NumField() for i := 0; i \u0026lt; numField; i++ { fieldType := getType.Field(i) fieldValue := getValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, fieldType.Name, fieldType.Type, fieldValue) } // メソッドを取得します numMethod := getType.NumMethod() for i := 0; i \u0026lt; numMethod; i++ { method := getType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, method.Name, method.Type) } } reflect.Value による割り当て 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a := 3.14 // ポインタの場合のみ割り当て可能 pointer := reflect.ValueOf(\u0026amp;a) // 元の値を取得するためのアドレスを設定します newValue := pointer.Elem() // 値が設定可能かどうかをチェックする fmt.Println(\u0026#34;value canSet:\u0026#34;, newValue.CanSet()) if newValue.CanSet() { // 設定できる場合 newValue.SetFloat(9.96) // 変数の値を表示 fmt.Println(\u0026#34;value of a:\u0026#34;, a) // 9.96 } else { fmt.Println(\u0026#34;error\u0026#34;) } } reflect.Value 経由でメソッドを呼び出す 関数名による呼び出し\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { name string age int } func (user User) MethodHasArgs(a string, b int) { fmt.Println(\u0026#34;User MethodHasArgs\u0026#34;) } func (user User) MethonNotArgs() { fmt.Println(\u0026#34;User MethodNotArgs\u0026#34;) } func main() { user := User{\u0026#34;zhangSan\u0026#34;, 18} value := reflect.ValueOf(user) // 関数名で呼び出す method1 := value.MethodByName(\u0026#34;MethodHasArgs\u0026#34;) // ビルドパラメータ args1 := []reflect.Value{reflect.ValueOf(\u0026#34;string\u0026#34;), reflect.ValueOf(18)} // 関数の呼び出し method1.Call(args1) // パラメータなしで呼び出す method2 := value.MethodByName(\u0026#34;MethonNotArgs\u0026#34;) args2 := make([]reflect.Value, 0) method2.Call(args2) } リフレクションの基本原則 ","date":"2024-12-03T14:07:18+08:00","permalink":"https://blog.yexca.net/ja/archives/204/","title":"GoLang リフレクション"},{"content":"問題一： https://blog.yexca.net/ja/archives/198 問題二：この記事\n問題三 (簡体字中国語)： https://blog.yexca.net/archives/200 問題四 (簡体字中国語)： https://blog.yexca.net/archives/202 問題五 (簡体字中国語)： https://blog.yexca.net/archives/203 まえがき この質問を初めて見たときは形式言語（とオートマトン理論）に関する質問だと思ったのですが、実際にやってみると数学に関する質問でした （どちらも習ってないので同じです） 全体的な難易度は特に難しいわけではありません （私は東京大学の試験問題を受験したので、ここでの問題はそれほど難しくありません） しかし、それらを解くには、より多くの理論的基礎を習得する必要があります\nトピックの著作権は東京理科大学に帰属します。閲覧の便宜のために引用しているだけで、営利行為は一切ありません。\n1 命題論理について考える。命題 $\\varphi$ を $(\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0)$ とする。ただし、$p_0, p_1$ は命題記号である。\na）以下の表が $\\varphi$ の真理値表になるように（ア）～（エ）にあてはまる値を答えよ。ただし、1は真を表し、0は偽を表す。\n$p_0$ $p_1$ $\\varphi$ 0 0 （ア） 0 1 （イ） 1 0 （ウ） 1 1 （エ） b）命題 $\\varphi$ が恒真（トートロジー）であるか否か答えよ。\nc）命題 $\\varphi$ が充足可能であるか否か答えよ。\n1-a 先ずは、命題 $\\varphi$ を整理する\n$$ \\begin{align} \\varphi \u0026amp;= (\\neg p_0 \\to \\neg p_1) \\wedge (\\neg p_1 \\to p_0) \\ \u0026amp;= (p_0 \\vee \\neg p_1) \\wedge (p_1 \\vee p_0) \\end{align} $$\nこれより\n$p_0$ $p_1$ $\\varphi$ 0 0 0 0 1 0 1 0 1 1 1 1 ゆえに、ア：0、イ：0、ウ：1、エ：1\n1-b $\\varphi=0$ の場合が存在するため、恒真命題ではない\n1-c $\\varphi=1$ の場合が存在するため、充足可能である\n2 命題論理の自然演繹について考える。$p_1, p_2, p_3$ は命題記号であり、$\\wedge I$ は連言の導入規則、$\\wedge E_L$ は連言の除去規則（左）、$\\wedge E_R$ は連言の除去規則（右）、$\\to E$ は含意の除去規則である。\na）$(p_1 \\wedge p_2) \\wedge p_3$ を仮定とし、$p_1 \\wedge (p_2 \\wedge p_3)$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（オ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{(ア)}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(イ)}\\wedge E_L }{(ウ)}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{(エ)}\\wedge E_R }{(オ)}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\nb）$p_1 \\wedge p_2$ と $p_1 \\to (p_2 \\to p_3)$ を仮定とし、$p_3$ を結論とする以下の自然演繹の導出（証明図）を完成させたい。（ア）～（エ）にあてはめる命題を答えよ。\n$$ \\cfrac{ \\cfrac{(ア)}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{(イ)}{p_1}\\wedge E_L \\quad (ウ) }{(エ)}\\to E }{p_3}\\to E $$\nc）命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ が矛盾するか無矛盾であるかを答え、その理由を述べよ。\n2-解答 質問に示されている記号を理解できれば、この質問に答えるのは比較的簡単です。\n$\\wedge I$ は交差のインポート規則であり、$A$ と $B$ を $A \\wedge B$ に変換する。\n$\\wedge E_L$ は交差除去規則であり、左側を残す。つまり、$A \\wedge B$ は $A$ になる。\n$\\wedge E_R$ は交差除去規則であり、右側を残す。つまり、$A \\wedge B$ は $B$ になる。\n$\\to E$ は含意除去規則であり、$A$ と $A \\to B$ を $A$ に変換する。\n2-a ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_2$ エ: $p_3$ オ: $p_2 \\wedge p_3$ $$ \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2)\\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_1}\\wedge E_L \\quad \\cfrac{ \\cfrac{ \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_1 \\wedge p_2}\\wedge E_L }{p_2}\\wedge E_R \\quad \\cfrac{(p_1 \\wedge p_2) \\wedge p_3}{p_3}\\wedge E_R }{p_2 \\wedge p_3}\\wedge I }{p_1 \\wedge (p_2 \\wedge p_3)}\\wedge I $$\n2-b ア: $p_1 \\wedge p_2$ イ: $p_1 \\wedge p_2$ ウ: $p_1 \\to (p_2 \\to p_3)$ エ: $p_2 \\to p_3$ $$ \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_2}\\wedge E_R \\quad \\cfrac{ \\cfrac{p_1 \\wedge p_2}{p_1}\\wedge E_L \\quad p_1 \\to (p_2 \\to p_3) }{p_2 \\to p_3}\\to E }{p_3}\\to E $$\n2-c 無矛盾である。命題を整理する\n$$ \\neg p_0 \\to \\neg p_1 \\equiv p_0 \\vee \\neg p_1 \\ \\neg p_1 \\to p_0 \\equiv p_1 \\vee p_0 $$\n真理値表を作る\n$p_0$ $p_1$ $\\neg p_0 \\to \\neg p_1$ $\\neg p_1 \\to p_0$ 0 0 1 0 0 1 0 1 1 0 1 1 1 1 1 1 $p_0=1, p_1=0$ または $p_0=1, p_1=1$ の場合は、両方の命題が成り立つ\n少なくとも一つの真理値割り当てで命題集合が成り立つため、命題の集合 ${ \\neg p_0 \\to \\neg p_1, \\neg p_1 \\to p_0 }$ は無矛盾である\n3 一階述語論理について考える。\na）以下の論理式のモデルは存在するか。存在するならば、モデルのユニバースの濃度の最小値を答えよ。存在しないならば、その理由を述べよ。\n$$ \\exists x \\exists y \\exists z \\space \\neg(x=y) \\wedge \\neg(y=z) \\wedge \\neg(z=x) $$\nb）以下の論理式のモデルは存在するか。存在するならば、そのモデルを1つ挙げよ。存在しなければ、その理由を述べよ。\n$$ \\exists x \\forall y(x=y) $$\n3-a この論理式のモデルは存在する。モデルのユニバースの濃度の最小値は3である。\n3-b この論理式のモデルは存在する。例えば、ユニバース $U={a}$ を設定する。この場合、$U$ のすべての要素が $x$ と等しいため、論理式が成り立つ。\n4 一階述語論理の自然演繹について考える。以下が成り立つか否か答え、その理由を述べよ。ただし、$P$ はアリティ2の述語記号とする。\n$$ \\vdash (\\forall x \\exists y P(x,y)) \\to \\exists x \\forall y P(x,y) $$\n4-解答 これは成り立たない。反例は以下のように構成する。\nユニバースを ${ m,n,a,b }$ と定義する。このとき、述語 $P(x,y)$ の解釈を以下のように与える\n$$ P(m,a) = 真 \\quad P(a,m) = 偽 \\ P(n,b) = 真 \\quad P(b,n) = 偽 $$\nこれより、$\\forall x \\exists y P(x,y)$ が成り立つ。しかし、$\\exists x \\forall y P(x,y)$ は成り立たない。\nReference 自然演繹 命題論理 演繹定理 充足可能性問題 ","date":"2024-11-24T22:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/201/","title":"科学大院理工学 2020 問題二"},{"content":"問題一：この記事\n問題二： https://blog.yexca.net/ja/archives/201 問題三 (簡体字中国語)： https://blog.yexca.net/archives/200 問題四 (簡体字中国語)： https://blog.yexca.net/archives/202 問題五 (簡体字中国語)： https://blog.yexca.net/archives/203 まえがき この記事は初めて母国語じゃない言語で書いて、他の記事を参考しないので、言葉遣いがてきせつではないかも。それで、参考の答えはなくて、記事の答えが自分でできたので、正しくないかも。\n科学大とは東京工業大学の新しい名前で、略称が何か知らなくてこれを使った。\n問題の著作権は東京科学大学に帰属します。閲覧の便宜のためにのみ引用されており、営利を目的とするものではありません。\n1 以下の極限を求めよ。\na) $\\lim_{x\\to\\infty}{ \\log_e(2x+3)-\\log_e(x) }$\nb) $\\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}$\nc) $\\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}$\n回答\na\n$$ a=\\lim_{x \\to \\infty}\\log_e\\frac{2x+3}{x}=\\lim_{x\\to \\infty}\\log_e(2+\\frac{3}{x})=\\log_e2 $$\nb\n$$ \\because when \\space x \\to 0 ,\\space 1-\\cos x \\sim \\frac{1}{2}x^2 \\space and \\space sinx \\sim x \\ \\therefore \\lim_{x\\to 0}\\frac{1-\\cos x}{x\\sin x}=\\lim_{x\\to 0}\\frac{\\frac{1}{2}x^2}{x^2}=\\frac{1}{2} $$\nc ロピタルの定理を用いて\n$$ \\lim_{x\\to 0}\\frac{e^{3x}-\\cos x}{x}=\\lim_{x\\to 0}\\frac{3e^{3x}+sinx}{1}=3 $$\n2 以下の実行列の積の行列式を計算せよ。\n$$ \\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} \\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\n2つの行列の積の行列式は、それらの行列式の積である。\nA の場合\n$$ A=\\begin{pmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\ x \u0026amp; 2 \u0026amp; 1 \\ x^2 \u0026amp; 3 \u0026amp; 2 \\end{pmatrix} $$\nA の行列式\n$$ \\det(A)=(-1)^{1+1} \\times 1 \\times \\begin{vmatrix} 2 \u0026amp; 1 \\ 3 \u0026amp; 2 \\end{vmatrix} -0+0 =1 $$\nB の場合\n$$ B=\\begin{pmatrix} 31 \u0026amp; 23 \u0026amp; 17 \\ 0 \u0026amp; 11 \u0026amp; 11 \\ 0 \u0026amp; 4 \u0026amp; 5 \\end{pmatrix} $$\nB の行列式\n$$ \\det(B)=(-1)^{1+1} \\times 31 \\times \\begin{vmatrix} 11 \u0026amp; 11 \\ 4 \u0026amp; 5 \\end{vmatrix} -0+0 = 341 $$\nだから\n$$ \\det=\\det(A) \\times \\det(B)=1 \\times 341 = 341 $$\n3 以下の確率密度関数 $f_X(x)$ に従う連続型確率変数 $X$ の分散 $V(X)$ 、累積分布関数 $F_X(x)$ を各々求めよ。ただし、$\\lim_{x \\to +0}x^n\\log_e(x)=0$ ($n$ は 1 以上の整数) とする。\n$$ F_X(x)=\\left { \\begin{matrix} -4x\\log_e(x) \u0026amp; 0 \\lt x \\le 1 \\ 0 \u0026amp; x \\le 0 \\space または \\space x \\gt 1 \\end{matrix} \\right . $$\nまずは、累積分布関数を考えて\n$x \\le 0$ $$ F_X(x) = 0 $$\n$x\\gt 1$ $$ F_X(x) = 1 $$\n$0 \\lt x \\le 1$ $$ \\begin{align} F_X(x) \u0026amp;= \\int_0^x(-4t\\log_e(t))dt \\ \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u = \\ln t \u0026amp; dv=4tdt \\ du = \\frac{1}{t}dt \u0026amp; v=2t^2 \\end{matrix} $$\nしたがって\n$$ \\begin{align} F_X(x) \u0026amp;=-( [2t^2\\ln t]_0^x - \\int_0^x 2t^2\\frac{1}{t}dt ) \\ \u0026amp;=-( 2x^2\\ln x - \\int_0^x 2t dt ) \\ \u0026amp;=-( 2x^2\\ln x - t^2\\mid_0^x ) \\ \u0026amp;=x^2 - 2x^2\\ln x \\end{align} $$\nこれより\n$$ F_X(x)= \\left { \\begin{matrix} 0 \u0026amp; x \\le 0 \\ x^2-2x^2\\ln x \u0026amp; 0 \\lt x \\le 1 \\ 1 \u0026amp; x \\gt 1 \\end{matrix} \\right . $$\n次に、分散を求める。分散の定義は\n$$ V(X)=E[X^2] - (E[X])^2 $$\n期待値 $E[X]$ を計算する\n$$ \\begin{align} E[X] \u0026amp;= \\int_{-\\infty}^{\\infty}xf_X(x)dx \\ \u0026amp;= \\int_0^1x(-4x\\ln x)dx \\ \u0026amp;= -\\int_0^1 4x^2\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=4x^2dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{4}{3}x^3 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X] \u0026amp;= -([\\frac{4}{3}x^3\\ln x]_0^1-\\int_0^1\\frac{4}{3}x^3\\frac{1}{x}dx) \\ \u0026amp;= -(-\\frac{4}{9}x^3\\mid_0^1) \\ \u0026amp;= \\frac{4}{9} \\end{align} $$\n$E[X^2]$ の計算\n$$ \\begin{align} E[X^2] \u0026amp;= \\int_{-\\infty}^{\\infty}x^2f_X(x)dx \\ \u0026amp;= \\int_0^1x^2(-4x\\ln x)dx \\ \u0026amp;= -4\\int_0^1x^3\\ln xdx \\end{align} $$\n部分積分を用いて\n$$ \\begin{matrix} u=\\ln x \u0026amp; dv=x^3dx \\ du=\\frac{1}{x} \u0026amp; v=\\frac{1}{4}x^4 \\end{matrix} $$\nしたがって\n$$ \\begin{align} E[X^2] \u0026amp;= -4 \\times ([\\frac{1}{4}x^4\\ln x]_0^1-\\int_0^1\\frac{1}{4}x^3dx) \\ \u0026amp;= -4 \\times (-\\frac{1}{16}x^4\\mid_0^1) \\ \u0026amp;= \\frac{1}{4} \\end{align} $$\nだから\n$$ \\begin{align} V(X) \u0026amp;= E[X^2] - (E[X])^2 \\ \u0026amp;= \\frac{1}{4} - (\\frac{4}{9})^2 \\ \u0026amp;= \\frac{17}{342} \\end{align} $$\n4 ある製造ラインで生産された製品は1/1000の確率で不良品である。不良品を99/100の確率で正しく不良品と判定し、かつ、不良品でないものを4/5の確率で正しく不良品ではないと判定する検査手法がある。この製造ラインにおいて、この手法が不良品と判定した製品が、不良品である確率を求めよ。\n不良品である確率：$P(A)=\\frac{1}{1000}$、不良品と判定する確率：$P(B)$\nこれより\n$$ \\begin{matrix} p(\\bar{A})=\\frac{999}{1000} \u0026amp; P(B\\mid A)=\\frac{99}{100} \u0026amp; P(B\\mid \\bar{A})=\\frac{1}{5} \\end{matrix} $$\nしたがって\n$$ P(B)=P(A)P(B\\mid A)+P(\\bar{A})P(B\\mid \\bar{A})=\\frac{20079}{100000} $$\nベイズの定理を用いると\n$$ P(A\\mid B)=\\frac{P(AB)}{P(B)}=\\frac{P(A)P(B\\mid A)}{P(B)}=\\frac{99}{20079} $$\n以上より、不良品である確率は $\\frac{99}{20079}$\n5 あるカジノで、4個のパケットA,B,C,Dに区切られたルーレットがある。カジノの説明ではそれぞれのパケットにボールが入る確率は同じであるとされている。そのルーレットを5回試行したところ、ボールはパケットAに4回入った。カジノの説明とは異なる「このルーレットはボールがポケットAにより入りやすい」という仮設を、有意水準5％で検定せよ。解答には帰無仮説 $H_0$ 、対立仮説 $H_1$ を明記すること。\n$H_0$：ポケットAにボールが入る確率は他のポケットと同じである。すなわち\n$$ P(A)=\\frac{1}{4} $$\n$H_1$ ：ポケットAにボールが入る確率は他のポケットより高い。すなわち\n$$ P(A)\\gt \\frac{1}{4} $$\nボールはポケットAに4回入る確率は\n$$ P(X=4)=(_4^5) (\\frac{1}{4})^4 \\times \\frac{3}{4}=\\frac{15}{1024} $$\nボールはポケットAに5回入る確率は\n$$ P(X=5)=(_5^5) (\\frac{1}{4})^5=\\frac{1}{1024} $$\nこれより\n$$ P(X\\ge 4)=\\frac{15}{1024}+\\frac{1}{1024}=\\frac{1}{64} $$\nこの確率は有意水準より小さいため、帰無仮説を棄却する。ゆえに、「このルーレットはボールがポケットAにより入りやすい」という仮設は統計的に有意であると言えます。\n","date":"2024-11-21T15:42:18+08:00","permalink":"https://blog.yexca.net/ja/archives/198/","title":"科学大院理工学 2020 問題一"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 n クイーン問題は、n 行 n 列のチェス盤に n 個のクイーンを配置し、クイーン同士が攻撃できないようにすることです。ルールは、2 個のクイーンが同じ行、列、または対角線上にないことです（つまり、 、チェスのクイーンの移動範囲）\n問題分析 n クイーン問題を解決するために、次のアイデアが提案されています。\ni 番目のクイーンは i 番目の列に置かれる\n最初のクイーンから始めて、各クイーンについて、対応する行の最初の列から試します（i番目のクイーンはi番目の行に対応します） 配置できる場合は位置を決定し、次のクイーンを検討します 前の女王と衝突する場合は、次の列を考慮する 最後の列を超えた場合は、前のクイーンの位置が再決定されます。\nすべての配置ソリューションが見つかるまでこのプロセスを繰り返します。\nC コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; #define N 4 // クイーンの数 // k 番目のクイーンの現在の位置が前のクイーンと競合するかどうかを判定する int isplace(int pos[], int k){ int i; for(i=1; i\u0026lt;k; i++){ if(pos[i]==pos[k] || fabs(i-k) == fabs(pos[i]-pos[k])) return 0; } return 1; } int main(){ int i,j; int count = 1; int pos[N+1]; // 初期化の位置 for(i=1;i\u0026lt;=N;i++) pos[i]=0; j = 1; while(j\u0026gt;=1){ pos[j]=pos[j]+1; // i 番目のクイーンを配置してみて while(pos[j]\u0026lt;=N \u0026amp;\u0026amp; !isplace(pos,j)){ pos[j]=pos[j]+1; // 配置計画を取得する } if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j==N){ printf(\u0026#34;方案 %d：\u0026#34;, count++); for(i=1;i\u0026lt;=N;i++) printf(\u0026#34;%d\u0026#34;, pos[i]); printf(\u0026#34;\\n\u0026#34;); } // 次のクイーンを考えてみよう if(pos[j]\u0026lt;=N \u0026amp;\u0026amp; j\u0026lt;N){ j+=1; }else{ // 前のクイーンについて考えるために戻る pos[j]=0; j-=1; } } return 1; } ","date":"2024-07-28T14:26:26+08:00","permalink":"https://blog.yexca.net/ja/archives/176/","title":"n-クイーン問題のアルゴリズム（バックトラッキング）"},{"content":"導入 卒業論文は面倒くさいな、この記事はいつか書いたのでしょうか。ファイルは 2023-11-30 に作成されたけど、2022.09.18 に変更されて、わからなくて、ショックを受けた\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;script\u0026gt; function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second \u0026gt;= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second \u0026gt;= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second \u0026gt;= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second \u0026gt;= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second \u0026gt; 0) { time[4] = second; } return time; }\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; language=\u0026#34;javascript\u0026#34;\u0026gt; function setTime() { var create_time = Math.round(new Date(Date.UTC(2021, 11, 06, 14, 15, 19)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = \u0026#39;This Blog has running: \u0026lt;br/\u0026gt;\u0026#39; + currentTime[0] + \u0026#39; y \u0026#39; + currentTime[1] + \u0026#39; d \u0026#39; + currentTime[2] + \u0026#39; h \u0026#39; + currentTime[3] + \u0026#39; m \u0026#39; + currentTime[4] + \u0026#39; s\u0026#39;; document.getElementById(\u0026#34;htmer_time\u0026#34;).innerHTML = currentTimeHtml; } setInterval(setTime, 1000); \u0026lt;/script\u0026gt; 呼び出し 使いたいところで以下のコードを入れる\n1 \u0026lt;span id=\u0026#34;htmer_time\u0026#34; style=\u0026#34;color: pink;\u0026#34; /\u0026gt; 参考資料 个人博客添加运行时间 - 腾讯云开发者社区-腾讯云 ","date":"2024-05-14T11:08:25+08:00","permalink":"https://blog.yexca.net/ja/archives/172/","title":"ブログ実行時間"},{"content":"まずソフトウェアをインストールする必要があります。公式ウェブサイト (英語): https://nacos.io/en/ ポートは conf/application.properties ファイルで変更できます。デフォルトは 8848 です。\nサービスに登録する 親プロジェクトに管理依存関係を追加する\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.6.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Eureka の依存関係をコメントアウトし、Nacos クライアントの依存関係を追加します。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml を修正し、Nacos アドレスを追加し、Eureka アドレスをコメントします。\n1 2 3 4 spring: cloud: nacos: server-addr: localhost:8848 Nacos を始める\n1 2 startup.cmd -m standalone # 単一マシンの起動パラメータ http://localhost:8848/nacos/ にアクセスすると、ログイン アカウントとパスワードは両方とも nacos になります。\n階層型ストレージモデル サービスは複数のクラスターに分割され、各クラスターには複数のインスタンスがあり、クラスターはリージョンごとに割り当てられ、アクセス速度が向上します。\n対照的に、Eureka にはサービスインスタンスのみがあり、クラスターはありません。\nサービスを呼び出すときは、クラスター間の呼び出しの方が待機時間が長くなるため、可能な限りローカル クラスター内のサービスを選択してください。ローカルクラスタにアクセスできない場合は、他のクラスタにアクセスする\napplication.yml でクラスタを設定できます\n1 2 3 4 5 6 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 次に Ribbon 戦略を Nacos に設定する\n1 2 3 4 5 # マイクロサービスの負荷分散ルールを設定します。ここでは userService サービスです。 userService: ribbon: NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # NFLoadBalancerRuleClassName: com.netflix.loadbalancer.Nac # 負荷分散ルール 次に、Nacos でインスタンスの重み (0-1) を設定できます。重みが大きいほど、アクセス頻度が高くなります。\n環境隔離 Nacos のサービスストレージとデータストレージの最外層は、名前空間と呼ばれるもので、最外層の分離に使用されます。\nNacos に dev などの新しい名前空間を作成し、application.yml を修正することができます。\n1 2 3 4 5 6 7 spring: cloud: nacos: server-addr: localhost:8848 discovery: cluster-name: Shanghai # クラスター名 namespace: UUID # 名前空間のUUIDは次のとおりです 異なる名前空間内のサービスは相互に表示されず、アクセスできません。\n一時インスタンスと非一時インスタンス 一時的なインスタンスの場合、Nacos は Eukera と同じ方法で処理します。\n一時的でないインスタンスの場合、Nacos はアクティブにインスタンスが稼働中かどうかを問い合わせます。サービスが利用できない場合は削除されません。サービスが利用できない場合、Nacos は積極的に消費者に通知します。\n非一時的インスタンスの設定\n1 2 3 4 5 spring: cloud: nacos: discovery: ephemeral: false # 非一時インスタンスとして設定 Nacos 構成管理 マイクロサービスのデプロイインスタンスが増えると、一つ一つ構成を変更するのは非常に面倒です。Nacos を使用すると、構成を一元管理し、ホットアップデートを行うことができます。\nシンプルな使い方 Nacos コンソールの設定管理で、新しい設定を作成します。ここで、Data ID は、[サービス名]-[プロファイル].[サフィックス名] の形式の設定ファイルの ID です (例: userService-dev.yaml)。\n次に、設定コンテンツに設定を記述します。たとえば、\n1 2 pattern: dateformat: yyyy-MM-dd HH:mm:ss Nacos 構成管理クライアント依存関係の紹介\n1 2 3 4 5 \u0026lt;!--nacos 構成管理依存関係--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 取得を構成する手順\nプロジェクトの起動 -\u0026gt; bootstrap.yml -\u0026gt; Nacos 構成ファイル -\u0026gt; ローカル application.yml -\u0026gt; Spring コンテナの作成 -\u0026gt; Bean のロード\nbootstrap.yml を追加する\n1 2 3 4 5 6 7 8 9 10 spring: application: name: userService # サービス名 profiles: active: dev # 開発環境、こちらが dev です cloud: nacos: server-addr: localhost:8848 # Nacos住所 config: file-extension: yaml # ファイル拡張子 テスト\n1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 効果を確認するにはページをご覧ください\nホットアップデート これは2つの方法で達成できる\n方法1: @Value によって注入された変数が配置されているクラスにアノテーション @RefreshScope を追加する\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ @Value(\u0026#34;${pattern.dateformat}\u0026#34;) private String dateformat; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat)) } } 方法 2: @ConfigurationProperties を使用する\n新しい構成クラスを作成する\n1 2 3 4 5 6 @Component @Data @ConfigurationProperties(prefix = \u0026#34;pattern\u0026#34;) public class PatternProperties { private String dateformat; } Controller クラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @RefreshScope // 自動更新の設定 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) public class UserController{ // @Value(\u0026#34;${pattern.dateformat}\u0026#34;) // private String dateformat; @Autowired private PatternProperties properties; @GetMapping(\u0026#34;/now\u0026#34;) public String now(){ return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat())) } } 共有の構成 マイクロサービスが起動すると、Nacos から複数の設定ファイルを読み取ります。\n[spring.application.name]-[spring.profiles.active].yaml，例えば：userService-dev.yaml\n[spring.application.name].yaml，例えば：userService.yaml\n2番目の [spring.application.name].yaml には環境が含まれていないため、複数の環境で共有できます。\n設定の優先順位: [spring.application.name]-[spring.profiles.active].yaml \u0026gt; [spring.application.name].yaml \u0026gt; ローカル設定\n","date":"2024-05-02T22:36:17+08:00","permalink":"https://blog.yexca.net/ja/archives/169/","title":"Nacos 登録センター"},{"content":"コンシューマによって開始されたリクエストはリボンによってインターセプトされ、リボンはユーレカからプロバイダリストを取得し、ユーレカはプロバイダリストを返し、リボンはIRuleに基づいてリクエストを開始するサーバを選択します。\n詳細なインターセプション: リクエスト -\u0026gt; DynamicServerListLoadBalancer (URL 内のサービス ID、userService を取得) -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; Eureka -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; IRule -\u0026gt; DynamicServerListLoadBalancer -\u0026gt; リクエストの開始\n負荷分散戦略 組み込みの負荷分散ルールクラス ルールの説明 ZoneAvoidanceRule(Eureka 默认) サーバーの選択は、その地域で利用可能なサーバーに基づいて行われます。ゾーンを使用してサーバーを分類します。このゾーンは、コンピューター ルーム、ラックなどとして理解できます。次にゾーン内の複数のサービスをポーリングします RoundRobinRule サービス リストをポーリングするだけでサーバーを選択できます。これはリボンのデフォルトの負荷分散ルールです AvailabilityFilteringRule 次の 2 種類のサーバーは無視されます: (1) デフォルトでは、このサーバーへの接続が 3 回失敗すると、サーバーは「短絡」状態に設定されます。短絡状態は30秒間続きます。接続が再度失敗すると、短絡の持続時間は指数関数的に増加します。 (2) 同時接続数が多すぎるサーバー。サーバーへの同時接続数が多すぎる場合、AvailabilityFilteringRule ルールが設定されたクライアントもそれを無視します。同時接続の上限は、クライアントの\u0026lt;clientName\u0026gt;.\u0026lt;clientConfigNameSpace\u0026gt;.ActiveConnectionsLimitプロパティで設定できます。 WeightedResponseTimeRule 各サーバーに重み値を割り当てます。サーバーの応答時間が長くなるほど、このサーバーの重みは小さくなります。このルールはサーバーをランダムに選択します。この重み値はサーバーの選択に影響します。 BestAvailableRule 短絡したサーバーを無視し、同時実行性の低いサーバーを選択する RandomRule 利用可能なサーバーをランダムに選択 RetryRule 再試行メカニズムの選択ロジック ランダム戦略の使用 負荷分散ルールは、次の 2 つの方法で IRule 実装を定義することによって変更できます。\nコードメソッド: 構成クラスで、新しい IRule（グローバル設定）を定義します。 1 2 3 4 @Bean public IRule randomRule(){ return new RandomRule(); } 設定ファイル方式: orderServer application.yml ファイルで、ルールを変更するための新しい設定を追加します。 1 2 3 userService: # マイクロサービスの負荷分散ルールを設定します。ここでは userservice サービスです ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 負荷分散ルール 遅延読み込み Ribbon はデフォルトで遅延読み込みを使用します。つまり、初めてアクセスされたときにのみ LoadBalanceClient が作成され、要求時間が非常に長くなります。プロジェクトの開始時にハングリー読み込みが作成され、最初のアクセスの時間消費が短縮されます。ハングリー読み込みを有効にするには、次のように構成します。\n1 2 3 4 ribbon: eager-load: enabled: true clients: userService # userService サービスのハングリーロードを指定します ","date":"2024-04-28T15:50:15+08:00","permalink":"https://blog.yexca.net/ja/archives/168/","title":"Ribbon 負荷分散"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: この記事\nGoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 造を使用してクラスとオブジェクトの概念を構築する\nオブジェクト指向を理解する: オブジェクト指向の基礎(簡体字中国語だけど) struct まずは、C に似た type キーワードを使用したカスタム型です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; type myType int func main() { var a myType fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a is %T\u0026#34;, a) } /* * 出力 * a = 0 * type of a is main.myTye */ stuct を使用して型を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } fun main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Print(zhang) } 関数転送は関連しており、ポインタは使用されず、値の転送です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; type Person struct { name string age int } // 値の転送、元のデータは変更されません func changeName(person Person) { person.name = \u0026#34;liSi\u0026#34; } // 参照を渡すと元のデータが変更されます func changeAge(person *Person) { person.age = 18 } func main() { var zhang Person zhang.name = \u0026#34;zhangSan\u0026#34; zhang.age = 20 fmt.Println(zhang) changeName(zhang) fmt.Println(zhang) changeAge(\u0026amp;zhang) fmt.Println(zhang) } カプセル化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import \u0026#34;fmt\u0026#34; // クラス type Person struct { // プロパティ name string age int } // クラスメソッド func (this *Person) SetName(name string) { this.name = name } func (this *Person) SetAge(age int) { this.age = age } func (this *Person) GetName() string { return this.name } func (this *Person) GetAge() int { return this.age } func main() { person := Person{name: \u0026#34;zhangSan\u0026#34;, age: 18} fmt.Println(person) } クラス名とメソッド名の最初の文字が大文字になっていることに注意してください。これは、クラスとメソッドが他のパッケージからアクセスできることを意味します (java public)。最初の文字が小文字の場合は、このパッケージからのみアクセスできます (java private) プロパティについても同様です。\n継承 次のコードは同じファイル、親クラスにあります\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 親クラス type Person struct { name string age int } // 親クラスのメソッド func (this *Person) Eat() { fmt.Println(\u0026#34;Person Eat...\u0026#34;) } func (this *Person) Walk() { fmt.Println(\u0026#34;Person Walk...\u0026#34;) } サブクラス\n1 2 3 4 5 6 7 8 9 10 11 12 13 // サブクラス type SuperMan struct { Person // 親クラスから継承 level int // サブクラス属性 } // サブクラスは親クラスのメソッドをオーバーライドします func (this *SuperMan) Walk() { fmt.Println(\u0026#34;SuperMan Walk\u0026#34;) } // サブクラス固有のメソッド func (this *SuperMan) Fly() {} main 関数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func main() { // サブクラスの属性を定義する、方法 1 superMan1 := SuperMan{Person{\u0026#34;zhangSan\u0026#34;, 18}, 4} // サブクラスの属性を定義する、方法 2 var superMan2 SuperMan superMan2.name = \u0026#34;liSi\u0026#34; // 同じパッケージ内にあるため、親クラスの属性にアクセスできます superMan2.age = 20 superMan2.level = 5 // サブクラスは親クラスのメソッドを呼び出す superMan1.Eat() // サブクラスのオーバーライドメソッド superMan1.Walk() // サブクラスメソッド superMan2.Fly() } 多態性 次のコードは同じファイルにあり、インターフェースを定義しています\n1 2 3 4 5 6 // インターフェース、基本的にはポインタ type Animal interface { Sleep() GetName() string GetType() string } 実装クラス 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 実装クラス 1 type Cat struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Cat) GetName() string { return this.name } func (this *Cat) GetType() string { return this.kind } 実装クラス 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 実装クラス 2 type Dog struct { name string kind string } // インターフェースのすべてのメソッドを実装する func (this *Dog) Sleep() { fmt.Println(\u0026#34;Cat Sleep()\u0026#34;) } func (this *Dog) GetName() string { return this.name } func (this *Dog) GetType() string { return this.kind } func ShowAnimal(animal Animal) { fmt.Println(animal) } main\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func ShowAnimal(animal Animal) { fmt.Println(animal) } func main() { var animal Animal animal = \u0026amp;Cat{\u0026#34;cat1\u0026#34;, \u0026#34;cat\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;dog1\u0026#34;, \u0026#34;dog\u0026#34;} animal.Sleep() cat := Cat{\u0026#34;cat2\u0026#34;, \u0026#34;cat\u0026#34;} dog := Dog{\u0026#34;dog2\u0026#34;, \u0026#34;dog\u0026#34;} ShowAnimal(\u0026amp;cat) ShowAnimal(\u0026amp;dog) } ユニバーサル型とアサーション 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; // ユニバーサルデータ型を表すために空のインターフェースを使用する func f(arg interface{}) { // 型アサーションメカニズム (つまり型変換) value, flag := arg.(string) if !flag { fmt.Println(\u0026#34;arg is not string type\u0026#34;) } else { fmt.Println(\u0026#34;arg is string type, arg =\u0026#34;, value) } } func main() { // カスタムを含む任意のデータ型を渡すことができます f(\u0026#34;abc\u0026#34;) f(123) f(3.14) } /* * 出力 * arg is string type, arg = abc * arg is not string type * arg is not string type */ ","date":"2024-03-01T15:35:38+08:00","permalink":"https://blog.yexca.net/ja/archives/162/","title":"GoLang オブジェクト指向"},{"content":"レジストリを導入する前に、プロバイダーとコンシューマーの概念を紹介します。\nプロバイダーとコンシューマー サービス プロバイダー: ビジネス内の他のマイクロサービスによって呼び出されるサービス。 (他のマイクロサービスへのインターフェースを提供する)\nサービス コンシューマー: 1 つのビジネス内の他のマイクロサービスを呼び出すサービス。 (他のマイクロサービスによって提供されるインターフェースの呼び出し)\nプロバイダーとコンシューマーは相対的です。サービスはプロバイダーとコンシューマーの両方になることができます。\nEureka プロバイダーが複数ある場合、消費者はどのようにしてプロバイダー情報を入手し、プロバイダーの健全性状態を知ることができるのでしょうか?\n起動時に、マイクロサービスは Eureka にサービス情報を登録します。コンシューマーは Eureka を通じてプロバイダー情報を取得し、それをリモートで呼び出すことができます。マイクロサービスは 30 秒ごとに Eureka にまだ稼働中であることを通知し、Eureka はサービス リスト情報を更新して、正常でないサーバーを削除します。\n複数のサービス プロバイダーがある場合、コンシューマーは負荷分散アルゴリズムを使用してサービス リストから 1 つを選択します。\n建てる 新しい Maven モジュールを作成し、依存関係を導入する\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; スタートアップクラスの作成\n1 2 3 4 5 6 7 @EnableEurekaServer @SpringBootApplication public class EurekaApplication { public static void main(String[] args) { SpringApplication.run(EurekaApplication.class,args); } } 設定ファイル\n1 2 3 4 5 6 7 8 9 server: port: 7995 spring: application: name: eureka-server eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスに登録する 依存関係の導入\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 構成の記述\n1 2 3 4 5 6 7 spring: application: name: userService eureka: client: service-url: defaultZone: http://127.0.0.1:7995/eureka サービスの利用 上記の登録例\n1 2 3 4 5 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } ドメイン名をサービス名に変更する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ // String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); String url = \u0026#34;http://userService/user/\u0026#34; + order.getUserId(); User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-29T16:53:15+08:00","permalink":"https://blog.yexca.net/ja/archives/161/","title":"登録センター - Eureka"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: この記事\nGoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のスライスは配列の抽象化である\n配列 配列の長さは変更できません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { // 定義方法 1 var arr1 [10]int // トラバース for i := 0; i \u0026lt; len(arr1); i++ { fmt.Println(\u0026#34;arr1[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr1[i]) } // 定義方法 2、代入 arr2 := [10]int{0, 1, 2, 3} // range トラバーサル for index, value := range arr2 { fmt.Println(\u0026#34;index =\u0026#34;, index, \u0026#34;value =\u0026#34;, value) } // 異なる長さを定義する var arr3 [4]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr1) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\\n\u0026#34;, arr2) // [10]int fmt.Printf(\u0026#34;type of arr1 is %T\u0026#34;, arr3) // [4]int } コンパイルして実行すると、arr3 が arr1 および arr2 とは異なる型であることがわかります。そのため、関数パラメータを定義するときにも対応する型を指定する必要があります。\n1 2 3 4 5 func test(arr [4]int) { for i := 0; i \u0026lt; len(arr); i++ { fmt.Println(\u0026#34;fmt_arr[\u0026#34;, i, \u0026#34;]:\u0026#34;, arr[i]) } } 上記の関数は arr3 を値で渡すことしかできず、値を変更しても元のデータには影響しません。\nスライスを定義する 配列と比較すると、スライスは固定長ではなく、要素を追加することができます（動的配列）。追加するとスライスの容量が増加する可能性があります。\nスライスは、サイズが指定されていない配列を宣言することによって定義できます。\n1 2 3 var name []type // 例えば var s []int または make() 関数を使用してスライスを作成する\n1 2 3 var slice []type = make([]type, len) // len はスライスの初期の長さです // 次のように省略することもできます slice := make([]type, len) オプションの capacity パラメータを使用して容量を指定できます。省略した場合は、length と同じになります。\n1 var slice []type = make([]type, length, capacity) スライスの初期化 直接初期化\n1 s := []int {1, 2, 3} 配列の値を startIndex から endIndex-1 までのスライスとして初期化します。両方の値は省略できます。\n1 s := arr[startIndex:endIndex] startIndex または endIndex を省略すると、最初の要素からインデックス付けするか、最後の要素までインデックス付けすることを意味します。\nlen() と cap() スライスはインデックス可能であり、その長さは len() 関数を使用して取得できます。\ncap() は容量を計算するメソッドであり、スライスが到達できる長さを測定できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import \u0026#34;fmt\u0026#34; // スライス渡しは参照渡しであり、関数内の変更は元のデータに影響します func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\u0026#34;, len(slice), cap(slice), slice) } func main() { s := make([]int, 3, 5) printSlice(s) } /* * 出力 * len=3, cap=5, slice=[0 0 0] */ 空のスライス スライスは初期化前はデフォルトで nil (空のスライス) であり、その長さは 0 です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 空かどうか確認する if s == nil { fmt.Println(\u0026#34;slice is empty\u0026#34;) } } スライスインターセプション 上限と下限を設定してスライスをカットする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7} // 元のスライスを印刷する fmt.Println(s) // 2(含む) から 5(含まない) まで printSlice(s[2:5]) // 1 番目から 5 まで (含まない) printSlice(s[:5]) // 2 番目から最後まで printSlice(s[2:]) // この割り当てと subS の変更は s に影響します subS := s[1:6] printSlice(subS) } append() と copy() スライスの容量を増やし、スライスをコピーする\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func printSlice(slice []int) { fmt.Printf(\u0026#34;len=%d, cap=%d, slice=%v\\n\u0026#34;, len(slice), cap(slice), slice) } func main() { var s []int printSlice(s) // 要素を追加する s = append(s, 0) printSlice(s) // 複数の要素を追加する s = append(s, 1, 2, 3, 4) printSlice(s) // s の 2 倍の容量を持つ s2 を作成します s2 := make([]int, len(s), cap(s)*2) // s を s2 にコピーします。s2 を変更しても s には影響しません。 copy(s2, s) printSlice(s2) } スライス拡張: 追加された値が容量を超える場合、容量は2倍になります\nmap map を宣言する方法は 2 つあります\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { var map1 = make(map[string]string) // データを挿入 map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) // map[one:1 two:2] } 2 番目\n1 2 3 4 5 6 7 8 9 10 11 package main import \u0026#34;fmt\u0026#34; func main() { map1 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;2\u0026#34;, } fmt.Println(map1) } map のネスト 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; fmt.Println(map1) } /* * 出力 * map[first:map[one:1 two:2]] */ トラバーサルを変更して削除する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]map[string]string) map1[\u0026#34;first\u0026#34;] = make(map[string]string, 2) map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; map1[\u0026#34;first\u0026#34;][\u0026#34;two\u0026#34;] = \u0026#34;2\u0026#34; // 改訂 map1[\u0026#34;first\u0026#34;][\u0026#34;one\u0026#34;] = \u0026#34;one\u0026#34; fmt.Println(map1) // トラバース for key, value := range map1{ fmt.println(\u0026#34;key =\u0026#34;, key, \u0026#34;value =\u0026#34;, value) } // 消去 delete(map1, \u0026#34;first\u0026#34;) fmt.Println(map1) } 特定の値があるかどうかを判定する 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func main() { map1 := make(map[string]string) map1[\u0026#34;one\u0026#34;] = \u0026#34;1\u0026#34; val, key := map1[\u0026#34;one\u0026#34;] if key { fmt.Println(val) } else { fmt.Println(\u0026#34;empty\u0026#34;) } } ","date":"2024-02-27T20:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/160/","title":"GoLang スライス"},{"content":"サービスアーキテクチャ モノリシックアーキテクチャ すべてのビジネス機能を1つのプロジェクトで開発し、展開用に1つのパッケージにパッケージ化します。\n利点: シンプルなアーキテクチャ、スケーラビリティが低い、導入コストが低い、小規模プロジェクトに適している\nデメリット: 結合度が高い\n分散アーキテクチャ システムは業務機能ごとに分割されており、各業務モジュールはサービスと呼ばれる独立したプロジェクトとして開発されている。\n利点: サービスの結合を減らし、サービスのアップグレードと拡張を容易にする\nデメリット: 複雑なアーキテクチャ、使いにくい、大規模なインターネットプロジェクトに適している\nマイクロサービス マイクロサービスは、適切に設計された分散アーキテクチャ ソリューションです。マイクロサービス アーキテクチャの特徴:\n単一責任 (簡体字中国語) : マイクロサービスはより細かい粒度に分割されます。各サービスは固有のビジネス機能に対応しており、単一責任を実現し、重複したビジネス開発を回避します。 サービス指向: マイクロサービスはビジネスインターフェースを外部に公開します 自律性: チームの独立性、テクノロジーの独立性、データの独立性、展開の独立性 強力な分離: サービス呼び出しは分離され、フォールトトレラントであり、連鎖的な問題を回避するためにダウングレードされます。 マイクロサービス技術 マイクロサービス ソリューションには技術フレームワークの実装が必要です。最も一般的なものは次のとおりです。\nDubbo SpringCloud SpringCloudAlibaba 登録センター zookeeper、 Redis Eureka、 Consul Nacos、 Eureka リモートサービスコール Dubbo プロトコル Feign (http プロトコル) Dubbo、Feign 構成センター 无 SpringCloudConfig SpringCloudConfig、 Nacos サービスゲートウェイ 无 SpringCloudGateway、 Zuul SpringCloudGateway、 Zuul サービスの監視と保護 dubbo-admin，弱い機能 Hystix Sentinel マイクロサービスはビジネスモジュールに応じて分割する必要がある\n単一責任: 異なるマイクロサービスに対して同じビジネスを繰り返し開発しない データの独立性: 他のマイクロサービスのデータベースにアクセスしない サービス指向: 独自のビジネスを他のマイクロサービスが呼び出すためのインターフェースとして公開する SpringCloud SpringCloud は現在最も広く使用されているマイクロサービス フレームワークです。さまざまなマイクロサービス機能コンポーネントを統合し、SpringBoot に基づいてこれらのコンポーネントの自動アセンブリを実装します。\n公式サイト: https://spring.io/projects/spring-cloud/ サービス登録と検出: Eureka、Nacos、Consul 統合構成管理: SpringCloudConfig、Nacos リモートサービスコール: OpenFeign、Dubbo 統合ゲートウェイルーティング: SpringCloudGateway、Zuul サービスリンク監視: Zipkin、Sleuth フロー制御、劣化、保護: Hystix、Sentinel マイクロサービス呼び出し 要件: 注文 ID に基づいて注文を照会する場合、注文が属するユーザー情報を返します。\nRestTemplate を登録する 1 2 3 4 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } サービスリモート呼び出し RestTemplate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Service public class OrderService { @Autowired private OrderMapper orderMapper; @Autowired private RestTemplate restTemplate; public Order queryOrderById(Long orderId) { // 1.注文をクエリ Order order = orderMapper.findById(orderId); // 2.ユーザーをクエリ String url = \u0026#34;http://localhost:8081/user/\u0026#34; + order.getUserId(); // RestTemplateのGETメソッド User user = restTemplate.getForObject(url, User.class); // 3.ユーザー情報をカプセル化する order.setUser(user); // 4.戻る return order; } } ","date":"2024-02-25T17:56:54+08:00","permalink":"https://blog.yexca.net/ja/archives/158/","title":"Hi SpringCloud"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: この記事\nGoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 複数の戻り値 Go 関数は複数の値を返すことができる\n匿名の戻り 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (int, int) { return b, a } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } /* 出力 * 20 10 */ パラメータ名を返す 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x int, y int) { x = b y = a return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } 上記の戻り値は同じ型であり、組み合わせることができる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b int) (x, y int) { x = b y = a // 如果不给 x,y 赋值，默认为0 return } func main() { var x, y = swap(10, 20) fmt.Println(x, y) } init と main init はどのパッケージにも、あるいは同じパッケージに複数回出現することができますが、1 つだけ記述することをお勧めします。\nmain は package main 内にのみ存在でき、パッケージにはこの関数がなければなりません。\nこれら 2 つの関数は予約関数であり、定義時にパラメーターや戻り値を持つことはできません。\nGo プログラムは自動的に init() と main() を呼び出す\nプログラムの実行 プログラムの初期化と実行はすべて main パッケージから始まります。同じパッケージが複数のパッケージでインポートされた場合でも、インポートされるのは 1 回だけです。次の図は実行順序を示しています。\n例\n次の構造を想定する\n1 2 3 4 5 6 hello -- InitLib1 -- lib1.go -- InitLib2 -- lib2.go main.go 内容は以下のとおりです\nlib1.go\n1 2 3 4 5 6 7 package InitLib1 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } lib2.go\n1 2 3 4 5 6 7 package InitLib2 import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;lib2 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; // ここでのアンダースコアはパッケージの別名です。別名でない場合はインポートは呼び出されず、コンパイルは成功しません。 _ \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;main init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } 運用結果\n1 2 3 4 lib1 init lib2 init main init main Lib1 パッケージを Lib2 にインポートすると、main コードは変更されません。\nlib1.go\n1 2 3 4 5 6 7 8 9 10 package InitLib1 import ( \u0026#34;fmt\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main 結果を実行\n1 2 3 4 lib2 init lib1 init main init main lib2 は 1 回だけ出現する\n他のパッケージ関数を呼び出す 上記の例では、エイリアスとして _ を使用していますが、これは匿名であり、対応するパッケージ メソッドを呼び出すことはできません。\nlib1 に関数を追加する\nlib1.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package InitLib1 import ( \u0026#34;fmt\u0026#34; //_ \u0026#34;hello/InitLib2\u0026#34; ) // 他のパッケージから呼び出す前に、最初の文字を大文字にする必要があります func Lib1Test() { fmt.Println(\u0026#34;lib1 test\u0026#34;) } func init() { fmt.Println(\u0026#34;lib1 init\u0026#34;) } main.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; // パッケージにエイリアスを付ける mylib1 \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // alias.method 経由で呼び出す mylib1.Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } /* * 出力 * lib1 init * lib2 init * lib1 test * main */ または . を直接使用して\nmain.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; // エイリアスが . に変更されました。 . \u0026#34;hello/InitLib1\u0026#34; _ \u0026#34;hello/InitLib2\u0026#34; ) func main() { // 直接使用する Lib1Test() fmt.Println(\u0026#34;main\u0026#34;) } 推奨されません。 2 つのパッケージに同じ名前の関数がある場合、あいまいさが生じます。\nポインタ C ポインタに似ている\n数を呼び出すときにパラメータを渡す方法は、値渡しとポインタ（参照）渡しの 2 つがあります。デフォルトでは、この記事の最初のコードのように値の受け渡しが使用されます。\n変数に対応するメモリアドレスを取得するには \u0026amp; を使用します\n1 2 3 4 5 6 7 8 9 10 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var a int fmt.Printf(\u0026#34;%x\u0026#34;, \u0026amp;a) } 参照渡しはメモリアドレスを関数に渡し、関数の変更は実際のパラメータに影響します。これはスワップ関数でもあり、今回はポインタを使用しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import \u0026#34;fmt\u0026#34; func swap(a, b *int) { var tmp = *a *a = *b *b = tmp } func main() { x, y := 10, 20 swap(\u0026amp;x, \u0026amp;y) fmt.Println(\u0026#34;x =\u0026#34;, x, \u0026#34;y =\u0026#34;, y) } defer defer ステートメントは、遅延関数と呼ばれる関数の呼び出しをスケジュールするために使用されます。その機能は次のとおりです。\n占有されているリソースを解放する 例外をキャッチして処理する 出力ログ try\u0026hellip;catch\u0026hellip;finally の finally に似ています\nファイルのオープン/クローズ、ロックの取得/解放、接続/切断などのペア操作を処理するためによく使用され、エラーや早期復帰が発生した場合でもリソースが適切に解放され、実行が保証されます。\n関数内に複数の defer ステートメントがある場合、それらはスタックと同様に LIFO (後入れ先出し) の順序で実行されます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func deferDemo() { defer fmt.Println(\u0026#34;1\u0026#34;) defer fmt.Println(\u0026#34;2\u0026#34;) defer fmt.Println(\u0026#34;3\u0026#34;) defer fmt.Println(\u0026#34;4\u0026#34;) } func main() { deferDemo() } /* * 出力 * 4 * 3 * 2 * 1 */ recover ランタイム パニック例外がトリガーされると、プログラムはクラッシュします。recover は、例外をキャプチャする Java の try\u0026hellip;catch と同様に、ランタイム パニックを「インターセプト」するために使用される組み込み関数です。\nrecover は defer によって呼び出される関数内でのみ有効です\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; func deferDemo(i int) { var arr [10]int // エラーインターセプションはエラーの前に設定されます defer func() { // エラーメッセージを傍受するように recover を設定する err := recover() if err != nil { fmt.Println(err) } }() arr[i] = 10 } func main() { deferDemo(10) fmt.Println(\u0026#34;main code\u0026#34;) } /* * 出力 * runtime error: index out of range [10] with length 10 * main code */ ","date":"2024-02-22T04:47:28+08:00","permalink":"https://blog.yexca.net/ja/archives/156/","title":"GoLang 関数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: https://blog.yexca.net/ja/archives/154 GoLang (var and const) 変数と定数: この記事\nGoLang (func) 関数: https://blog.yexca.net/archives/ja/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 変数 変数は通常 var キーワードを使用して宣言されます\n単一変数 タイプを定義する 初期値が指定されていない場合、デフォルトは 0 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int fmt.Println(\u0026#34;a =\u0026#34;, a) } 初期値を指定します。a は 100 です。\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { var a int = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) } 省略タイプ 宣言時に型がわからない場合、Go は変数の型を自動的に決定します。\n1 2 3 4 5 6 7 8 9 10 11 12 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a = 100 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a = %s\u0026#34;, reflect.TypeOf(a)) } := 省略に応じて型が自動的に決定され、:= を使用して変数を直接宣言できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { p := 3.14 fmt.Println(\u0026#34;p =\u0026#34;, p) fmt.Printf(\u0026#34;Type of p is %s\u0026#34;, reflect.TypeOf(p)) } /* * 出力 * p = 3.14 * Type of p is float64 */ 多変量 同じタイプ 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 同じタイプの割り当て 1 2 3 4 5 6 7 8 9 package main import \u0026#34;fmt\u0026#34; func main() { var a, b int = 100, 200 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Println(\u0026#34;b =\u0026#34;, b) } 異なるタイプ 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a, b = 100, 3.14 fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } /* * 出力 * a = 100 * Type of a is int * b = 3.14 * Type of b is float64 */ 異なるタイプ 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { a, b := 100, \u0026#34;Hello\u0026#34; fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } Go の文字列型は、基になる配列へのポインタと長さを含む構造体です。これら 2 つの部分はそれぞれ 8 バイトなので、文字列型のサイズは 16 バイトになります。\nunsafe.Sizeof()関数を使用して、タイプ占有率が見られます。\nグローバル変数 グローバル変数は := を使用して宣言することはできません\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var a, b int func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } または、グローバル変数に一般的に使用される分解を使用します。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) var ( a int = 1 b string = \u0026#34;Go\u0026#34; ) func main() { fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;Type of a is %s\\n\u0026#34;, reflect.TypeOf(a)) fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;Type of b is %s\u0026#34;, reflect.TypeOf(b)) } 定数 定数は通常、const キーワードを使用して定義されます。\n定義 1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c int = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } タイプを省略することもできます\n1 2 3 4 5 6 7 8 package main import \u0026#34;fmt\u0026#34; func main() { const c = 9 fmt.Println(\u0026#34;c = \u0026#34;, c) } 列挙 定数定義は列挙に使用できる\n1 2 3 4 5 6 7 8 9 package main func main() { const ( BEIJING = 0 SHANGHAI = 1 SHENZHEN = 2 ) } iota 自己増加 上記の列挙は 0 から始まり、増分で増加します。代わりに iota を使用できます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 package main import \u0026#34;fmt\u0026#34; func main() { const ( BEIJING = iota // 0 SHANGHAI // 1 SHENZHEN // 2 ) fmt.Println(BEIJING, SHANGHAI, SHENZHEN) } iota は式の中で使用できますが、通常は自動増分に使用されます\n","date":"2024-02-20T06:41:18+08:00","permalink":"https://blog.yexca.net/ja/archives/155/","title":"GoLang 変数と定数"},{"content":" この記事の一部は機械翻訳を使ったよ\nGolang シリーズ\nHello GoLang: この記事\nGoLang (var and const) 変数と定数: https://blog.yexca.net/ja/archives/155 GoLang (func) 関数: https://blog.yexca.net/ja/archives/156 GoLang (slice and map) スライス: https://blog.yexca.net/ja/archives/160 GoLang (OOP) オブジェクト指向: https://blog.yexca.net/ja/archives/162 GoLang (reflect) リフレクション: https://blog.yexca.net/ja/archives/204 GoLang (struct tag) 構造タグ: https://blog.yexca.net/ja/archives/205 GoLang (goroutine) ゴルーチン: https://blog.yexca.net/ja/archives/206 GoLang (channel) チャンネル: https://blog.yexca.net/ja/archives/207 Go のダウンロード： https://go.dev/dl/ JetBrains GoLand： https://www.jetbrains.com/go/ Go の紹介 Go は直接コンパイルして直接実行し、デプロイできる静的型付け言語です。\n1 2 3 4 5 6 7 # 直接実行 go run hello.go # コンパイル go build hello.go # コンパイル後に実行 ./hello Go の応用例\n(1)、クラウドコンピューティングインフラ\n代表的なプロジェクト：docker、kubernetes、etcd、consul、cloudflare CDN、\u0026ldquo;七牛云存储(中国語)\u0026ldquo;など\n(2)、基本的なバックエンドソフトウェア\n代表的なプロジェクト：tidb、influxdb、cockroachdb など\n(3)、マイクロサービス\n代表的なプロジェクト：go-kit、micro、monzo bank的typhon、bilibili など\n(4)、インターネットインフラ\n代表的なプロジェクト：Ethereum、hyperledger など\nHello Go 1 2 3 4 5 6 7 8 9 10 11 package main // パッケージ名を定義する /* * ソースファイルの最初の非コメント行で、ファイルが属するパッケージを指定する必要があります。 * main は独立して実行可能なプログラムを表します。すべての Go アプリケーションには、main という名前のパッケージが含まれています。 */ import \u0026#34;fmt\u0026#34; // IO フォーマットの関数を実装するために fmt パッケージをインポートします func main(){ // 関数 fmt.println(\u0026#34;Hello Go\u0026#34;) } 一般的に、main 関数は起動後に最初に実行される関数です。init関数がある場合は、init 関数が最初に実行されます。\n関数を定義するときは { が関数名と同じ行になければなりません\n","date":"2024-02-19T07:58:37+08:00","permalink":"https://blog.yexca.net/ja/archives/154/","title":"Hello GoLang"},{"content":"SpringBoot 入門の例 要件：SpringBoot 开发一个 Web 应用，浏览器発行起 /hello 後，返字文字列 “Hello Spring” を使用します。\n最初に必要な SpringBoot 工程、段階选 web 开公開相关依赖\nその後、制御制御クラス、路線径が *Application.java に同定されています Controller/HelloController.java\n1 2 3 4 5 6 7 8 9 @RestController public class HelloController{ @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ String s = \u0026#34;Hello Spring\u0026#34;; System.out.println(s); return s; } } *Application.java を実行して，ブラウザで http://localhost:8080/hello にアクセスして。\nHTTP ハイパーテキスト転送プロトコルは、TCP プロトコル (接続指向、安全) と要求応答モデル (1 つの要求が 1 つの応答に対応する) に基づいています。\nHTTP プロトコルはステートレス プロトコルであり、トランザクション処理用のメモリ機能はありません。各リクエストとレスポンスは独立しているため高速ですが、複数のリクエスト間でデータを共有することはできません。\n詳細については (簡体字中国語)： https://blog.yexca.net/archives/64 ","date":"2024-01-10T17:53:18+08:00","permalink":"https://blog.yexca.net/ja/archives/142/","title":"JavaWeb 入門"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 ある会社が長い鉄棒を購入し、それを切断して販売します。鉄筋を切断するコストはごくわずかで、鉄筋の長さはインチです。価格表 $p$ が与えられます。ここで、 $p_{i}(i=1,2,\\cdots,m)$ は長さ $i$ インチの鉄棒の価格を表します。今、売上収益を最大化するカット計画を見つける必要があります。\n問題分析 長い鋼棒の長さが $n$ インチで、最適な切断計画の左端の切断セグメントの長さが $i$ インチであると仮定して、残りの鋼棒の長さに対する最適な切断計画を解き続けます。 $m-1$ インチ。すべての可能な $i$ を考慮すると、最大の利益 $r_{n}$ に対応する伐採計画が最適な伐採計画となります。 $r_{n}$ の再帰定義は次のようになる。\n$$ r_{n}=max_{1\\le i \\le n}(p_{i}+r_{n-i}) $$\nC コード この問題には2つの解決策があります\n(1) 分割統治法（上から下まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int Top_Down_Cut_Rod(int p[], int n){ int r=0; // 最大値 int i; if(n==0){ retrun 0; } for(i=1; i\u0026lt;=n; i++){ int tmp = p[i]+Top_Down_Cut_Rod(p, n-i); r = (r\u0026gt;=tmp) ? r : tmp; } return r; } 時間計算量 $O(2^{n})$\n(2) 動的計画法（下から上まで） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int Bottom_Up_Cut_Rod(int p[], int n, int *s){ // *s:部分問題の最適な切断方法 int r[n+1]; // 部分問題の最適値 r[0]=0; for(int j=1; j\u0026lt;=n; j++){ int tmp=0; for(int i=1; i\u0026lt;=j; i++){ if(p[i]+r[j-1] \u0026gt; tmp){ tmp = p[i]+r[j-i]; s[j]=i; } } r[i]=tmp; } return r[n]; } 時間計算量 $O(n^{2})$\nその他のコンテンツ 検索プロセス中に、既存の記事を見つけました： 【基础算法】动态规划详解——钢条切割 ","date":"2023-05-27T19:37:08+08:00","permalink":"https://blog.yexca.net/ja/archives/110/","title":"アルゴリズム 鉄筋切断問題 (動的計画法 分割統治法)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 コインは $n$ 枚あり、そのうち 1 枚は偽造コインであり、偽造コインの方が軽いことが分かっています。今では残高は 1 つだけなので、できるだけ少ない比較で偽造コインを見つける必要があります。\n問題分析 $n$ 枚のコインを 2 つの等しい部分に分割します。\n$n$ が偶数の場合、最初の部分と2番目の部分、$1\\cdots\\frac{n}{2}$ と $\\frac{n}{2}+1\\cdots n$ を2つのスケールの端と端を照らします。軽い方の端に偽造コインが含まれています。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけます。 $n$ が奇数の場合、最初と最後の部分 $1\\cdots\\frac{n-1}{2}$ と $\\frac{n+1}{2}+1\\cdots n$ を、天秤の軽い方の端に偽造コインがあります。同じ方法を使用して、コインの軽い部分にある偽造コインを見つけ続けます。両端の重さが同じであれば、真ん中のコインは偽造コインです。つまり、$\\frac{n+1}{2}$ 枚のコインは偽造品である。 Cコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; // coins:重量配列 first,last:配列の最初と最後の添え字 int getCounterfeitCoin(int *coins, int first, int last); int main(void){ int coins[10] = {2,2,1,2,2,2,2,2,2,2}; int tmp = getCounterfeitCoin(coins, 0, 9); printf(\u0026#34;%d は偽造コインです\\n\u0026#34;,tmp+1); return 0; } int getCounterfeitCoin(int *coins, int first, int last){ int firstSum=0; int lastSum=0; int i; // 残りコインは2枚のみ if(first == last -1){ if(coins[first] \u0026lt; coins[last]) return first; return last; } // 偶数枚のコイン if ((last-first+1)%2 == 0){ for(i=first; i\u0026lt;first+(last-first)/2+1; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2); }else{ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); } }else{ // 奇数のコイン for(i=first; i\u0026lt;first+(last-first)/2; i++){ firstSum += coins[i]; } for(i=first+(last-first)/2+1; i\u0026lt;last+1; i++){ lastSum += coins[i]; } if(firstSum \u0026lt; lastSum){ return getCounterfeitCoin(coins, first, first+(last-first)/2-1); }else if(firstSum \u0026gt; lastSum){ return getCounterfeitCoin(coins, first+(last-first)/2+1, last); }else{ return first+(last-first)/2; } } } ","date":"2023-05-18T20:17:35+08:00","permalink":"https://blog.yexca.net/ja/archives/109/","title":"アルゴリズム偽造コイン問題 (分割統治)"},{"content":" この記事は Google 翻訳を使用して処理されました\n問題の説明 回路基板の上端と下端には n 個の端子があります。回路設計によれば、$(i, \\pi(i))$ は、上側の端子 i と下側の端子 $\\pi(i)$ の間の接続を表すために使用され、これは回路図上の i 番目の接続と呼ばれます。\n下の図に示す $\\pi(i)$ は、任意の $1 \\le i \u0026lt; j \\le n $ に対して ${8, 7, 4, 2, 5, 1, 9, 3, 10, 6}$ として配置されます。i 番目のリンクと j 番目のリンクが交差するための必要十分条件は $\\pi(i)\u0026gt;\\pi(j)$ である。\n回路基板を作るとき、これらのn本の配線を複数の絶縁層に分配する必要があり、同じ層の配線は交差しません。次に、どの配線を層に配置するかを決定する必要があります。このレイヤーで可能な限り多くのリンク、つまりリンクセット $Nets={ (i,\\pi(i)),1\\le i\\le n }$ の最大の分離サブセットを決定する。\n問題分析 $N(i,j)={ t|(t,\\pi(t))\\in Nets, t\\le i, \\pi(t) \\le j }$ とする。$N(i,j)$ の最大の分離部分集合を $MNS(i,j)$ ，$size(i,j)=|MNS(i,j)|$ とする。\n分析の結果、この問題は最適なサブ構造特性を持つことがわかりました。規模 n の回路配線問題では、次の再帰式を構築できます。\n$$ \\begin{align*} \u0026amp;(1) \\ \\ i=1\\ とする、 size(1,j)= \\begin{cases} 0, \u0026amp; \\text{j\u0026lt;$\\pi$(1)} \\ 1, \u0026amp; \\text{その他の状況} \\end{cases} \\ \u0026amp;(2) \\ \\ i\u0026gt;1\\ とする， size(i,j)= \\begin{cases} size(i-1,j), \u0026amp; \\text{j\u0026lt;$\\pi$(i)} \\ max{size(i-1,j),size(i-1,\\pi(i)-1)+1}, \u0026amp; \\text{その他の状況} \\end{cases} \\end{align*} $$\nC コード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 10 // 問題の大きさ // 分離した接続の最大数を見つける void maxNum(int pi[], int **size); // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net); int main(void){ // 下付き文字は1から始まります int pi[N+1] = {0, 8, 7, 4, 2, 5, 1, 9, 3, 10, 6}; int net[N]; int **size; size = (int**)malloc(sizeof(int*)*(N+1)); for(int i=0;i\u0026lt;N+1;i++) size[i]=(int*)malloc(sizeof(int)*(N+1)); maxNum(pi, size); int m = constructSet(pi, size, net); printf(\u0026#34;分離接続の最大数は次のとおりです。%d\\n\u0026#34;,m); printf(\u0026#34;含まれる接続は次のとおりです。\\n\u0026#34;); for(int i=0; i\u0026lt;m; i++){ printf(\u0026#34;(%d,%d)\\n\u0026#34;, net[i], pi[net[i]]); } } void maxNum(int pi[], int **size){ // size[i][j]: 上部と下部にそれぞれ i と j の端子がある回路基板の最初の層における分離接続の最大数 int i,j; // when j\u0026lt;pi(1) for(j=0; j\u0026lt;pi[1]; j++) size[1][j]; // when j\u0026gt;=pi(1) for(j=pi[1]; j\u0026lt;=N; j++) size[1][j]; for(i=2; i\u0026lt;N; i++){ // when j\u0026lt;pi(i) for(j=0; j\u0026lt;pi[i]; j++) size[i][j] = size[i-1][j]; // when j\u0026gt;=c[i] for(j=pi[i]; j\u0026lt;=N; j++) size[i][j]=size[i-1][j]\u0026gt;=size[i-1][pi[i]-1]+1 ? size[i-1][j] : size[i-1][pi[i]-1]+1; } // 最大接続数 size[N][N] = size[N-1][N]\u0026gt;=size[N-1][pi[N]-1]+1 ? size[N-1][N] : size[N-1][pi[N]-1]+1; } // 最大分離接続セットを構築します。net[i]は、最大分離サブセット内のi番目の接続の上位端末のシリアル番号を表します。 int constructSet(int pi[], int **size, int *net){ int i; int j=N; int m=0; // 端末セット内の最大接続数を記録する for(i=N; i\u0026gt;1; i--){ // 減少 // (i,pi[i])は最大の互いに素な部分集合を結ぶ線である。 if(size[i][j] != size[i-1][j]){ net[m++]=i; // iを配列ネットに記録し、接続ラインの数を1増やす j=pi[i]-1; // 拡張リンクバー間隔を更新しました } } // when i=1 if(j\u0026gt;=pi[1]) net[m++] = 1; return m; } その他のコンテンツ 検索中に既存の記事が見つかりました： 算法设计与分析——电路布线（动态规划） 参考文献 LaTeX公式手册 Typora中使用LaTeX：多行公式左对齐 用malloc动态申请一个二维数组的三种方法 ","date":"2023-05-16T17:53:31+08:00","permalink":"https://blog.yexca.net/ja/archives/106/","title":"アルゴリズム回路配線問題（動的計画法）"},{"content":" この記事は Google 翻訳を使用して処理されました\n「ハードドライブに保存されていないものはあなたのものではない」という原則に従い、個人の携帯電話に保存されている写真の数が増えているため、携帯電話のメモリ危機を緩和するために、緊急に整理してハードドライブに保存する必要があるため、アーティストによるダウンロード・保存方式を採用する。そのため、便利な記録と迅速な検索および変更の方法が必要です。アーティストの数が増えると、Markdown を使用した元のリストは必然的に非常に遅くなる可能性があります。\n2 日後に振り返ってみると、何かを記録する最良の方法はデータベースを使用することです。\nダウンロードとインストール 考えた結果、MySQLを使うことにしました。ダウンロードについては、 MySQL下载与安装 - 知乎 を参照してください。一部変更されていますが、ほぼ同じ。\nインストールはデフォルトのままで完了するまでクリックし続けました （面倒すぎる）\nサービスを開始し、win+Rを押してservices.mscと入力し、サービスを見つけて開始します。\nデータベース設計 正直に言うと、ここでデザインすることはあまりありません。今のところ、主に Pixiv からアーティストをダウンロードし、いくつかは Twitter からダウンロードしているので、1 つのテーブルしか使用できないはずです。\nID name downloadDate lastDownloadID platform url アーティスト固有ID 名前 ダウンロード日 最後にダウンロードした作品ID プラットフォーム リンク このデザインはどのようなパラダイムですか? コードは次のとおりです\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- データベースを作成する create database hello; -- データベースを選択 use hello; -- テーブルを作成 create table pic ( ID varchar(99), name varchar(255), downloadedDate datetime, lastDownloadID varchar(255), platform varchar(50), url varchar(255), primary key(ID) ); 作品をダウンロード Pixiv Powerful Pixiv Downloader 拡張機能 Chrome App Store リンク を使用する\nGithub リンク： xuejianxianzun/PixivBatchDownloader 必ず低速クロールを有効にしてください。そうしないと、ダウンロード速度が速すぎたり、一度にダウンロードする量が多すぎたりした場合に、IP が一時的にブロックされます。\nTwitter Twitter Media Downloader 拡張機能 Chrome App Store リンク を使用する\n公式ウェブサイトのリンク： Twitter メディアダウンローダ：ユーザータイムラインの原寸画像や動画をまとめてダウンロードするユーザースクリプト(PC用Google Chrome・Firefox等対応) - 風柳メモ データ挿入 1 2 3 4 5 6 -- データベースを選択 use hello; -- データの挿入 insert into pic values (\u0026#39;6049901\u0026#39;, \u0026#39;鬼针草\u0026#39;, \u0026#39;2023-02-09\u0026#39;, \u0026#39;105176620\u0026#39;, \u0026#39;pixiv\u0026#39;, \u0026#39;https://www.pixiv.net/users/6049901\u0026#39;) 複数行のデータの場合、データは , で区切られます。\nデータの更新 1 2 3 update pic set downloadedDate = \u0026#39;2023-03-02\u0026#39;, lastDownloadID = \u0026#39;105716156\u0026#39; where ID = \u0026#39;6049901\u0026#39; 詳細： データベースの学習 3 SQL言語 – yexca\u0026rsquo;Blog データベースについてもっと知りたいですか? 私が書いた (完全に翻訳しないけど)： データベース学習 1 データベース入門 – yexca\u0026rsquo;Blog 中国語（簡体字）: SQL 教程-菜鸟教程 参照記事 MySQL常见建表选项及约束 - GeaoZhang - 博客园 ","date":"2023-03-02T10:16:38+08:00","permalink":"https://blog.yexca.net/ja/archives/94/","title":"データベースにはダウンロードされたアーティストの作品が記録されます"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: 本文\n以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 SQL言語の分類 DDL（データ定義言語） データベースシステムでは、データベース内の各データベース、テーブル、ビュー、インデックスなどがデータベースオブジェクトです。データベースオブジェクトを作成または削除するには、SQL 言語を使用します。 DDL には CREATE、ALTER、DROP などが含まれます。\nDML（データ操作言語） DML は、INSERT、DELETE、UPDATE など、データベース内のデータを追加、変更、削除するために使用されるステートメントを指します。\nDQL (データクエリ言語) クエリはデータベースの基本機能であり、クエリ操作は SQL データ クエリ言語を通じて実装されます。たとえば、テーブルの内容を照会するにはSELECTを使用します。\nDCL（データ制御言語） DCL には、データベース オブジェクトの権限管理やトランザクション管理などが含まれます。\n(I) DDLデータ定義言語 1. データベースを作成する 1 create database \u0026lt;データベース名\u0026gt; 2。基本テーブルを作成します 1 2 3 4 5 6 7 create table \u0026lt;テーブル名\u0026gt; ( \u0026lt;列名\u0026gt; \u0026lt;データ型\u0026gt; [列レベルの整合性制約], [···,] [テーブルレベルの整合性制約,] [···] ) \u0026lt;1\u0026gt; データタイプ INT / INTEGER : 整数 FLOAT(n): 少なくともn桁の精度を持つ浮動小数点数 NUMERIC(p, d) / DECIMAL(p, d) / DEC(p, d): p桁（符号と小数点を除く）のd桁の固定小数点数小数点以下の数字 CHAR(n): 長さnの固定長文字列 DATETIME: 日付と時刻の型 1 2 3 4 5 6 -- 例えば create table test ( f1 char(10), f2 int ) \u0026lt;2\u0026gt; ラインレベルの整合性の制約 not null: 空ではない\nunique: ユニーク\nnot null unique: 空ではなくユニーク\ndefault: デフォルト値を定義する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -- 例えば create table test ( f1 int not null, -- この列は空にできません f2 int unique, -- この列の値は空でも構いませんが、各行は異なる必要があります f3 int not null unique, -- 列は空ではなく、各行は異なります f4 char(5) default \u0026#39;nashi\u0026#39; -- 新しく追加された行に値が割り当てられていない場合、この列はデフォルトで「nashi」になります。 ) \u0026lt;3\u0026gt; テーブルレベルの整合性の制約 名前 条項 通信の完全性 主キー句 PRIMARY KEY エンティティの整合性 チェック条項 CHECK ユーザー定義の整合性 外部キー句 FOREIGN KEY 参照整合性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 例えば create table student ( sid int, primary key(sid) -- not null unique ) -- または create table student ( sid int primary key ) create table course ( cid int, sid int, score int, check(score \u0026gt;= 0 and score \u0026lt;= 100), foreign key(sid) references student(sid) ) 整合性の検査 アサート（通常は推奨されません） 1 2 3 4 CREATE ASSERTION \u0026lt;アサーション名\u0026gt; \u0026lt;チェック条項\u0026gt; -- チェック句は、where 句の式に似ています。 -- アサーション名を削除 DROP ASSERTION \u0026lt;断言名\u0026gt;; トリガー テーブルが追加、削除、または変更されると、トリガー内の条件がチェックされます。条件が満たされている場合はトリガー内のアクションが実行され、満たされていない場合はアクションは実行されません。\n1 2 3 4 5 6 7 8 9 10 11 12 13 CREATE TRIGGER \u0026lt;トリガー名\u0026gt; -- トリガー イベントが発生するたびに、トリガーがアクティブになります。 {BEFORE|AFTER} \u0026lt;トリガーイベント\u0026gt; ON \u0026lt;テーブル名\u0026gt; -- トリガー イベントの実行前または実行後にトリガーがアクティブ化されるかどうかを示します。 REFERERCING NEW|OLD ROW AS \u0026lt;変数\u0026gt; -- REFERENCINGは参照される変数を示す FOR EACH{ROW|STATEMENT} -- トリガーの種類を定義し、アクション本体の実行頻度を指定します。 [WHEN \u0026lt;トリガーイベント\u0026gt;] \u0026lt;トリガーアクション本体\u0026gt; -- トリガーアクションはトリガー条件が真の場合にのみ実行されます -- トリガーの削除 DROP TRIGGER \u0026lt;トリガー名\u0026gt; ON \u0026lt;テーブル名\u0026gt; 3。基本的なテーブル構造を変更します 新しい列を追加する 1 2 3 4 alter table \u0026lt;テーブル名\u0026gt; add \u0026lt;列名\u0026gt; \u0026lt;タイプ\u0026gt; -- 例えば alter table test add f3 datetime 列を変更する* 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; alter column \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; modify \u0026lt;列名\u0026gt; \u0026lt;新しいタイプ\u0026gt; -- 例えば alter table test alter column f3 float -- alter table test modify f3 float 列の削除 1 2 3 4 5 6 7 alter table \u0026lt;テーブル名\u0026gt; drop column \u0026lt;列名\u0026gt; -- MySQL -- alter table \u0026lt;テーブル名\u0026gt; drop \u0026lt;列名\u0026gt; -- 例えば alter table test drop column f3 -- alter table test drop f3 4。基本テーブルを削除します 1 2 3 4 drop table \u0026lt;テーブル名\u0026gt; -- 例えば drop table test (二)、DML データ操作言語 次のコンテンツの例は、これらのテーブルに基づいています\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 -- 注: 理解しやすいように中国語を使用しています。実際の開発では英語を使用してください。 -- 学生テーブル create table student ( 学号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 班号 char(5) ) -- 成績テーブル create table score ( 学号 char(5), 课程号 char(5), 分数 int ) -- 教師テーブル create table teacher ( 教师编号 char(5) not null unique, 姓名 char(8), 性别 char(2), 出生日期 datetime, 职称 char(6), 系别 char(10) ) -- コーススケジュール create table course ( 课程号 char(5) not null unique, 课程名 char(20), 任课教师编号 char(5) ) 1. INSERT ステートメントを挿入 SQL基本テーブルにデータを挿入する方法は2つあります。タプル値を直接挿入するか、クエリの結果値を挿入するかです。\nタプル値を直接挿入する 1 2 3 4 5 6 7 8 9 10 11 12 13 insert into テーブル名[(列名の順序)] values (タプル値)[, ···] -- 或者 insert into テーブル名[(列名の順序)] (table (タプル値)[, (タプル値), ···]) -- 例如 insert into student values (\u0026#39;108\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-01-01\u0026#39;, \u0026#39;09033\u0026#39;), (\u0026#39;109\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-05-05\u0026#39;, \u0026#39;09034\u0026#39;) -- 指定した列を挿入する insert into student(学号，姓名，性别，出生日期) values (110, \u0026#39;王五\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-04-18\u0026#39;) クエリの結果値を挿入する 1 2 3 4 5 insert into テーブル名[(列名の順序)] select \u0026lt;クエリステートメント\u0026gt; -- 例えば insert into student select 111, \u0026#39;赵六\u0026#39;, \u0026#39;男\u0026#39;, \u0026#39;2000-03-19\u0026#39;, \u0026#39;09035\u0026#39; 2. DELETE 削除ステートメント 1 2 3 4 5 6 7 delete from \u0026lt;テーブル名\u0026gt; [where \u0026lt;条件式\u0026gt;] -- 例えば delete from student -- テーブル全体を削除する -- 生徒番号111のタプルを削除します delete from student where 学号 = 111 3. UPDATE ステートメントを修正 1 2 3 4 5 6 7 8 9 10 11 12 update \u0026lt;テーブル名\u0026gt; set \u0026lt;列名\u0026gt; = \u0026lt;価値表現\u0026gt;[, ···] [where \u0026lt;条件式\u0026gt;] -- 例えば update student set 班号 = \u0026#39;09058\u0026#39; where 学号 = 110 -- または update student set 班号 = \u0026#39;09057\u0026#39;, 性别 = \u0026#39;女\u0026#39; where 学号 = 110 and 班号 = \u0026#39;09058\u0026#39; (三)、DQL データクエリ言語 SQL データクエリ機能は SELECT 文を通じて実装されます。完全な構文は次のとおりです。\n1 2 3 4 5 6 select \u0026lt;対象テーブルの列名または列式のシーケンス\u0026gt; from \u0026lt;リレーションテーブルシーケンス\u0026gt; [where \u0026lt;行条件式\u0026gt;] [group by \u0026lt;列名の順序\u0026gt;] [having \u0026lt;グループ条件式\u0026gt;] [order by \u0026lt;列名\u0026gt; [asc|desc]] 1. 投影クエリ クエリ テーブル内の任意の列を選択するには、SELECT コマンドを使用します。複数の列がある場合は、カンマ , を使用して区切ります。 FROM句に複数のリレーショナルテーブルがある場合、各テーブルの名前を記述する必要があります。\n1 2 3 4 5 6 7 8 9 -- 例えば select 1 + 1 select 学号 * 100 from student -- 学生IDとスコアを照会する select student.学号, score.分数 from student, score -- すべての列をクエリする select * from student 重複行を削除するには DISTINCT を使用します\n1 2 3 -- 重複行を削除し、選択したコースを照会する select distinct 课程号 from score クエリ結果の列名をカスタマイズするには AS を使用します\n1 2 3 -- 例えば select 学号 as \u0026#39;sno\u0026#39; from student 2. クエリを選択 選択クエリは、クエリ条件を指定し、ソース テーブルからクエリ条件を満たすレコードのみを抽出または表示します。\n選択クエリでは通常、次の種類の操作が使用されます。\nオペレーター コード 説明する セットメンバーシップ演算子 INNOT IN セット内セットに含まれない 文字列マッチング演算子 LIKE _ および % を使用した単一または複数の文字の一致 NULL比較演算子 IS NULLIS NOT NULL 空の空にすることはできません 算術演算子 \u0026gt;\u0026gt;=\u0026laquo;br /\u0026gt;\u0026lt;==\u0026lt;\u0026gt; より大きいより大きいか等しい未満以下等しい等しくない \u0026lt;1\u0026gt; 条件式の比較演算 1 2 3 4 5 6 --- スコアが60～80のレコードを検索する select * from score where 分数 between 60 and 80 -- 60と80を含めるにはbetweenを使用します。つまり[60, 80]です。 -- スコア \u0026gt;= 60 かつスコア \u0026lt;= 80 の場合と同等 \u0026lt;2\u0026gt; 文字列マッチング操作 1 where [not] like \u0026#39;一致する文字列\u0026#39; [escape \u0026#39;一致する文字列\u0026#39;] '一致文字列' は完全な文字列にすることも、ワイルドカード文字 % と _ を含めることもできます。\n%: 任意の長さの文字を表します _ : 任意の1文字を表す \u0026lt;3\u0026gt; 集合の比較演算 1 2 3 4 -- スコアが85、86、または88のレコードをクエリします select * from score where 分数 in (85, 86, 88) \u0026lt;4\u0026gt; 論理的結合演算 1 2 3 4 -- クラス09031の女子生徒全員を照会する select * from student where 班号 = \u0026#39;09031\u0026#39; and 性别 = \u0026#39;女\u0026#39; 3. 並べ替えクエリ クエリ結果はORDER BY句を使用して並べ替えることができます。\n1 2 3 4 5 6 7 8 -- 昇順 asc (デフォルト、省略可能) select 学号, 姓名 from student order by 学号 -- 降順 desc select 学号, 姓名 from student order by 学号 desc 複数の列を指定して並べ替えることもできます。最初の列が最初に並べ替えられ、次に2番目の列が並べ替えられます。\n1 2 3 4 -- コース番号の昇順とスコアの降順で検索結果を表示します select * from score order by 课程号 asc, 分数 desc ORDER BY 句はクエリの最後に配置する必要があります。\n4. 集計関数 集計関数は、データ統計やその他の機能を実装します。一連の値を計算し、単一の値を返すために使用されます。\n通常は group by 句とともに使用される一般的な集計関数は次のとおりです。\n関数名 説明 AVG 平均値 COUNT 指定された式で選択された項目の数をカウントしますCOUNT(*)はクエリによって出力された行数をカウントします MIN 最小値 MAX 最大値 SUM 値の合計 STDWV 指定された式のすべてのデータの標準偏差を計算します STDEVP 母集団標準偏差 集計関数の引数の一般的な形式は次のとおりです。\n1 [all|distinct] expr このうち、ALL はすべての値に対して集計関数演算を実行することを意味し、これがデフォルト値となります。また、DISTINCT は、すべての一意の値が考慮されることを指定します。 exprは式です\n1 2 3 4 -- クラス「09031」の生徒数を照会する select count(*) as \u0026#39;人数\u0026#39; from student where 班号 = \u0026#39;09031\u0026#39; 5. データのグループ化 集計関数は1つの結果しか出力しないため、列をクエリして集計関数をまとめるとエラーが報告されます。\n特定のカテゴリの集計関数の結果は、データをグループ化することで計算できます。つまり、集計関数の範囲は各グループ内のすべてのレコードになります。\n集計関数をフィルター条件として使用する場合は、それを HAVING 句の後に置く必要があります。\n1 2 3 4 5 6 -- 最低スコアが 70 を超え、最高スコアが 90 未満の学生の学生 ID を照会します。 select 学号 from score where 分数 is not null group by 学号 having min(分数) \u0026gt; 70 and max(分数) \u0026lt; 90 クエリ内に WHERE 句、GROUP BY 句、HAVING 句、および集計関数が同時に出現する場合、SELECT コマンドの実行順序は次のようになります。\nWHERE句を実行してテーブルから行を選択します 選択した行を「GROUP BY」でグループ化する 集計関数を実行する HAVING句を実行して条件を満たすグループを選択します。 1 2 3 4 -- 各コースの平均スコアを照会する select 课程号, avg(分数) from score group by 课程号 集計関数は条件として HAVING 句の後にのみ配置でき、 WHERE 句の後には配置できません。\nSELECT句が列名と集計関数で構成されている場合、すべての列名をグループ化する必要があります。\n6. テーブル接続クエリ FROM 句では結合するテーブルを指定し、WHERE 句では結合条件を指定します。\n1 2 3 select \u0026lt;列名1\u0026gt;[, ···] from \u0026lt;表1\u0026gt;[, ···] where 接続条件 2つのテーブルの共通列には、student.学号などのプレフィックスを指定する必要があります。\nSQL Server では、接続は内部接続と外部接続に分けられます。\n\u0026lt;1\u0026gt; 内部結合 Θ 結合、等価結合、自然結合\n内部結合は最も基本的な結合方法です。INNER JOIN キーワードを使用します。このキーワードを使用しない場合、デフォルトは内部結合になります。\n等接続 つまり、2つのテーブル間の接続関係は「等しい」です。\n1 2 3 4 5 6 7 8 9 -- すべての学生の名前、コース番号、スコアの列を照会する select student.姓名, score.课程号, score.分数 from student, score where student.学号 = score.学号 -- したがって select student.姓名, score.课程号, score.分数 from student inner join score on student.学号 = score.学号 入力を簡略化するために、テーブルエイリアスを使用することができます。\n1 2 3 4 -- 前の例の簡略化 select x.姓名, y.课程号, y.分数 from student x, score y where x.学号 = y.学号 非等価結合 つまり、2つのテーブル間の接続関係は「等しい」ではない。\n自己接続 同じテーブルを結合することを自己結合と呼びます。\n1 2 3 4 5 6 -- \u0026#39;3-105\u0026#39; を受験し、そのスコアが生徒 \u0026#39;109\u0026#39; のスコアより高い生徒の記録を照会します。 select x.课程号, x.学号, x.分数 from score x, score y where x.课程号 = \u0026#39;3-105\u0026#39; and x.分数 \u0026gt; y.分数 and y.学号 = \u0026#39;109\u0026#39; and y.课程号 = \u0026#39;3-105\u0026#39; order by x.分数 desc \u0026lt;2\u0026gt; 外部結合 OUTER JOIN 左外部結合: LEFT OUTER JOIN または LEFT JOIN\n右外部結合: RIGHT OUTER JOIN または RIGHT JOIN\n完全外部結合: FULL OUTER JOIN または FULL JOIN\n1 2 3 4 5 -- 左外部結合の例 -- すべてのコースの教師の名前を照会する select course.课程名, teacher.姓名 from course left join teacher on (course.任课教师编号 = teacher.教师编号) 7. サブクエリ \u0026lt;1\u0026gt; 一般的なサブクエリ あるクエリが別のクエリの条件である場合、つまり、テーブルから行を選択する条件がテーブル自体または他のテーブルの結合情報に依存する場合、サブクエリを実装する必要があります。\nサブクエリは、SELECT ステートメントの WHERE 句で最もよく使用されます。\n1 2 3 4 5 6 7 8 -- 学生番号「105」の学生と同じ年に生まれた学生を検索します select 学号, 姓名, year(出生日期) as \u0026#39;出生年份\u0026#39; from student where year(出生日期) = ( select year(出生日期) from student where 学号 = \u0026#39;105\u0026#39; ) \u0026lt;2\u0026gt; 相関サブクエリ 通常のサブクエリでは、各サブクエリは 1 回だけ実行され、返された値はメインクエリの WHERE 句で使用されます。\nメイン クエリが各行を選択するかどうかを判断するときは、サブクエリを「起動」し、メイン クエリにフィードバックする必要があります。つまり、内部条件に外部属性が含まれるサブクエリは相関サブクエリと呼ばれます。\n1 2 3 4 5 6 7 8 9 -- コースの平均スコアよりも低いスコアを持つ学生を照会する select 学号, 课程号, 分数 from score a where 分数 \u0026lt; ( select avg(分数) from score b where a.课程号 = b.课程号 and 分数 is not null ) \u0026lt;3\u0026gt; EXISTS テストを含むサブクエリ EXISTS は存在量指定子 ∃ を表し、論理真または論理偽の値のみを返します。\n1 2 3 4 5 6 7 8 -- すべての教師の名前と部門を照会する select 姓名, 系别 from teacher a where exists ( select * from course b where a.教师编号 = b.任课教师编号 ) あるいは、結果を否定する「NOT EXISTS」がある。\n8. クエリ結果の結合、交差、差の演算 次の演算子を使用して、2 つの SELECT クエリの結果に対して操作を実行できます。\nUNION : および 交差: 例外: 差異 1 2 3 4 5 6 7 8 -- ANDの例 -- すべての教師と生徒の名前、性別、生年月日を照会する select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from teacher union select 姓名, 性别, year(出生日期) as \u0026#39;出生年份\u0026#39; from student -- order by 生年 (四)、DCL データ制御言語 データ制御は、ユーザーのデータ保存権限を制御し、DBA（データベース管理者）によって決定されます。\nデータベースセキュリティ 不安要素:\nデータベースへの不正アクセスと破壊 データベースから重要なデータが漏洩 安全保障環境の脆弱性 セキュリティコントロール:\nユーザーID認証: 静的パスワード認証、動的パスワード認証、生体認証、スマートカード認証 アクセス制御 自律的なアクセス制御方式（ユーザーが操作権限をカスタマイズし、他のユーザーに割り当てることができる） 自律アクセス制御 DBMS（データベース管理システム）データ制御には以下の機能が必要です\nGRANTとREVOKEを通じてシステムに権限を通知し、データ辞書に保存する ユーザーがリクエストを行った場合、認可ステータスに基づいて操作リクエストを実行するかどうかを確認します。 SQL 標準には、DELETE、INSERT、SELECT、および UPDATE 権限が含まれます。 SELETE 権限は READ 権限に対応します。SQL には REFERENCES 権限も含まれており、これはリレーションを作成するときにユーザーが外部キーを定義する機能を制限するために使用されます。\n1. 認可ステートメントの形式 1 2 3 4 grant \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] to \u0026lt;ユーザー\u0026gt;[, ···] [with grant option] 操作オブジェクトの種類によって権限は異なります。一般的な権限は次のとおりです。\nオブジェクト オブジェクトタイプ 操作権限 属性列 TABLE SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4つの権限の合計) ビュー TABLE SELECT、INSERT、UPDATE、DELETE、ALL PRIVILEGES (4つの権限の合計) 基本テーブル TABLE SELECT、INSERT、UPDATE、DELETE、ALTER、INDEXALL PRIVILEGES (6つの権限の合計) データベース DATABASE CREATETAB テーブルを作成する権限。DBA が一般ユーザーに付与できます。 PUBLIC: 権限を受け取るユーザーは、単一のユーザーまたは複数の特定のユーザーです。PUBLIC パラメータは、すべてのユーザーに権限を付与できます。 GRANT OPTION付き: この句が指定されている場合、権限を取得したユーザーは他のユーザーに権限を付与することもできます。 2. 権限取り消しステートメントの形式 1 2 3 revoke \u0026lt;権限\u0026gt;[, ···] on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt;[, ···] from \u0026lt;ユーザー\u0026gt;[, ···] データベースの役割 役割とは、CEO、取締役、一般従業員など、人物のタイプを指します。人物のタイプを承認できます。\nキャラクター作成 1 create role \u0026lt;キャラクター名\u0026gt; ロールの承認 1 grant \u0026lt;権限\u0026gt; on \u0026lt;オブジェクトタイプ\u0026gt; \u0026lt;オブジェクト名\u0026gt; to \u0026lt;役割1\u0026gt;[, ···] 他のユーザーまたはロールにロールを付与する 1 2 grant \u0026lt;役割\u0026gt; to \u0026lt;役割\u0026gt;または\u0026lt;ユーザー名\u0026gt; [with admin option] with admin option は、このユーザーが他のロールまたはユーザーにこの権限を付与できることを意味します。\nロール権限の取り消し 1 revoke \u0026lt;権限\u0026gt; on \u0026lt;オブジェクト名\u0026gt; from \u0026lt;キャラクター名\u0026gt; ビューのメカニズム ビューは、1 つ以上の基本テーブルまたはビューから派生したテーブルです。これは仮想テーブルです。\nユーザーごとに異なるビューを定義し、ユーザーが間違いを起こさないように不要なデータを非表示にします。\nビューの作成 1 2 3 create view \u0026lt;ビュー名(リスト名)\u0026gt; as select \u0026lt;クエリ句\u0026gt; [with check option] サブクエリのSELECT文には通常、ORDER BY句とDISTINCT文を含めることはできません。 WITH CHECK OPTION は、UPDATE、INSERT、および DELETE 操作の場合、操作対象の行がビュー定義の述語条件 (つまり、サブクエリの条件式) を満たす必要があることを意味します。 ビューを構成する属性列名がすべて省略されているか、すべて指定されています。省略した場合、ビューは SELECT サブクエリのターゲット列のプライマリ属性で構成されていることが暗黙的に示されます。 1 2 3 4 5 6 7 8 -- 関係モデル：student(sno, sname, sex, SD, email) -- 「コンピュータサイエンス（CS）」の学生向けのビューを作成し、変更操作を実行する場合 -- ビュー内のコンピュータサイエンスの学生のみが影響を受けるようにする create view cs-student as select sno, sname, sex from student where SD = \u0026#39;CS\u0026#39; with check option ビューの削除 1 2 3 4 drop view \u0026lt;ビュー名\u0026gt; --例えば drop view cs-student 監査 データベースに対するすべての操作は監査ログに記録され、そのログを使用して不正な動作があるかどうかを確認できます。\n1 2 3 4 -- 「SC」データを変更する監査操作 AUDIT UPDATE ON SC; -- 「SC」テーブルのすべての監査をキャンセルします NOAUDIT UPDATE ON SC; データ暗号化 いくつかの暗号化アルゴリズムにより、プレーンテキストは暗号テキストに変換され、他の人が閲覧できなくなります。\n＃＃ 索引\nインデックスを使用すると、データベース プログラムはテーブル全体をスキャンしなくても、テーブル内の必要なデータを見つけることができます。\nデータベースのインデックスは、テーブルの 1 つ以上の列の値のコレクションと、これらの値を物理的に識別するテーブル内のデータ ページへの論理ポインターの対応するリストです。\n内部スキーマによって定義されます（内部スキーマはすべての内部レコードタイプ、インデックス、およびファイル構成を定義します）\nインデックスを作成する 1 2 create [unique] [cluster] index \u0026lt;インデックス名\u0026gt; on \u0026lt;テーブル名\u0026gt;(列名[順序], ···) 順序：オプションASC（デフォルト）または DSC\nUNIQUE ：このインデックスの各インデックス値が 1 つのデータ レコードのみに対応することを示します。\nCLUSTER ：作成されるインデックスがクラスター化インデックスであることを示します。つまり、インデックス項目の順序は、テーブル内のレコードの物理的な順序と一致します。\nインデックスの削除 1 drop index \u0026lt;インデックス\u0026gt; ","date":"2023-02-08T08:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/88/","title":"データベースの学習 3 SQL言語"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: https://blog.yexca.net/ja/archives/86 データベース学習 2 リレーショナル モデル: 本文\nデータベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 リレーショナルモデルの基本用語 リレーショナル データベース システムは、リレーショナル モデルをサポートするデータベース システムです。リレーショナル モデルに関連する基本的な用語は次のとおりです。\nリレーションシップ: リレーションシップは2次元テーブルであり、各リレーションシップにはリレーションシップ名があります。 タプル: テーブル内の行はタプルであり、ストレージファイル内のレコード値に対応します。 属性: テーブル内の列は属性と呼ばれます。各列には属性名があり、属性値はレコード内のデータ項目またはフィールド値に相当します。 ドメイン: 属性の値の範囲、つまり異なるタプル内の同じ属性の値の範囲 リレーションシップモデル: リレーションシップの説明はリレーションシップモデルと呼ばれ、リレーションシップ名とその属性セットで構成されます。リレーションシップモデルの形式は次のとおりです: リレーションシップ名(属性名 1，···，属性名 n) 通常、リレーショナルモデルはリレーショナルファイルの結果に対応する。\n候補キー: タプルを一意に識別する値を持つ属性または属性の組み合わせ 主キー: 関係には複数の候補キーが存在する場合があり、そのうちの1つが主キーとして選択されます。 主属性: 候補コード に含まれる属性は主属性と呼ばれ、候補コード に含まれない属性は非主属性と呼ばれます。 外部キー: リレーション内の属性または属性グループがリレーションのキーではないが、別のリレーションのキーである場合、その属性または属性グループをリレーションの外部キーと呼びます。 フルコード: リレーショナルスキーマのすべての属性グループは、このリレーショナルスキーマの候補コードであり、フルコードと呼ばれます。 スーパーコード（スーパーキー）：コードを含む属性のセットはスーパーコードと呼ばれます 関係モデルの定義 関係の記述はリレーショナルモデルと呼ばれ、正式には次のように表現されます: R(U, D, dom, F)\nここで、Rは関係名、Uは関係を構成する属性名のセット、Dは属性グループUの属性の由来となるドメイン、domは属性からドメインへのマッピングのセット、Fは属性データ間の依存関係のセット。\nこれは通常、R(U)またはR($A_1$, $A_2$, ···)と略記されます。ここで、Rは関係名、Uは属性名セット、$A_1$、···は個々の属性です。名前。\nリレーショナル モデルは、リレーショナル データ構造、リレーショナル操作セット、リレーショナル整合性制約の 3 つの部分で構成されます。\nリレーショナルデータ構造 リレーショナルモデルにおけるデータの論理的な関係は2次元のテーブルである\n関係演算セット リレーショナルモデルは関係を操作する機能を提供する\n一般的なリレーショナル操作には、選択、投影、接続、除算、結合、積、差などのクエリ操作、および追加操作と削除操作が含まれます。\nリレーショナル整合性制約 リレーショナル モデルの 3 つの整合性ルールは次のとおりです。\nエンティティの整合性: リレーションシップの主キーの値は空または部分的に空にすることはできません。つまり、主キーの属性、つまり主属性は空の値を取ることはできません。 参照整合性: リレーション $R_2$ の外部キーXがリレーション $R_1$ の主キーに対応する場合(基本リレーション $R_1$ と $R_2$ は必ずしも異なるリレーションではなく、同じリレーションである可能性があります)、次に、外部キー X の各値は、リレーション $R_1$ の主キーの値内に見つかる必要があります。見つからない場合は null になります。 ユーザー定義の整合性: 特定のデータに対してユーザーが指定した制約の検証を指します。 関係代数演算子 オペレーター シンボル 意味 集合演算子 ∪–∩× 連合違い交差点デカルト積 特殊な関係演算子 σπ⋈÷ 選ぶ投影接続分割 比較演算子 ＞≥＜≤＝≠ より大きいより大きいか等しい未満以下等しい等しくない 論理演算子 ¬∧∨ 否及びまたは 従来の集合計算 専門的な関係オペレーター 接続 θ 接続、等接続と自然接続\nθ 接続：接続条件が等しくない 等価接続：接続条件は等価です 自然接続: 重複するプロパティの等価接続を削除します。最もよく使用される接続計算。 プロジェクター 投影計算は関係の垂直方向から計算を実行し、関係 R で新しい関係を構成するいくつかの属性列 A を抽出し、$π_A(R)$ を計算します。\n选择 選択計算は関係の水平方向からの計算であり、関係 R の中から所定の条件を満たす要素を選択し、$σ_F(R)$ として計算します。\n外部接続 外部接続計算は接続計算の拡張であり、接続計算によってメッセージが失われる可能性があります。\n左外部接続: 左側関係関係のすべてと右側関係関係のいずれかの要素グループが一致しない要素グループを取り出し、右側関係関係からのすべての属性を空の null で埋めます。 外部接続: 右側関係系のすべてと左側関係系のいずれかの元組が一致しない元組を取り出し、左側関係系からのすべての属性を空の null で埋めます。 ※全外部接続：左外部接続と右外部接続の操作を完了します。 除法 シンボルからSQL言語へ 関係 R：\nA B C 1 2 3 4 5 6 7 8 9 SQL言語への投影 $π_?(?)$\n1 select ? from ? $π_{A, B, C}(R)$ 或者 $π_{1, 2, 3}(R)$\n1 select A, B, C from R 注：SQL 语言不サポート列 (プロパティ) の順序番号\n選択からSQLへ $π_?(σ_?(?))$\n1 select ? from ? where ? $π_{A, B, C}(σ_{B \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$ 或者 $π_{1, 2, 3}(σ_{2 \u0026gt;= \u0026lsquo;5\u0026rsquo;}(R))$\n1 2 3 select A, B, C from R where B \u0026gt;= \u0026#39;5\u0026#39; # または select A, B, C from R where B \u0026gt;= 5 デカルト積からSQLへ $π_{R.A, R.B, R.C, S.A, S.B, S.D}(R×S)$\n1 2 3 4 select R.A, R.B, R.C, S.A, S.B, S.D from R, S # 昇順で並べ替え order by R.A asc SQL言語への自然接続 関係 R(A, B, C) および S(B, C, D)\n$π_{R.A, R.B, R.C, S.D}(σ_{R.B = S.B ∩ R.C = S.C}(R×S))$\n1 2 3 select R.A, R.B, R.C, S.D from R, S where R.B = S.B and R.C = S.C ","date":"2023-02-07T06:00:00+08:00","permalink":"https://blog.yexca.net/ja/archives/87/","title":"データベース学習 2 リレーショナル モデル"},{"content":" この記事は Google 翻訳を使用して処理されました\nSQL Series\nデータベース学習 1 データベース入門: 本文\nデータベース学習 2 リレーショナル モデル: https://blog.yexca.net/archives/ja/87 データベースの学習 3 SQL言語: https://blog.yexca.net/ja/archives/88 以下のはまだ翻訳しないので、中国語（簡体字）のリンクだよ\n数据库学习四 关系数据库理论: https://blog.yexca.net/archives/89 数据库学习五 范式: https://blog.yexca.net/archives/90 数据库学习六 数据库设计: https://blog.yexca.net/archives/91 数据库学习七 数据库的控制功能: https://blog.yexca.net/archives/92 導入 以前のデータベースはうまく書かれていなかったので、見直して書き直しました（ただし、これもかなり乱雑です）\nデータベース4つの基本概念 データ 物事を記述する象徴的な記録\nデータベース 一般に、データベース データには、永続的な保存、整理、共有という 3 つの基本的な特性があります。\n厳密に言えば、データベースとは、長期間コンピューターに保存され、整理され、共有可能な大量のデータの集合です。データベース内のデータは、特定のデータ モデルに従って整理、記述、保存され、冗長性が低く、データの独立性が高く、スケーラビリティが容易で、さまざまなユーザーが共有できます。\nデータベース管理システム これは、ユーザーとオペレーティング システムの間に位置するデータ管理ソフトウェアのレイヤーです。オペレーティングシステムと同様に、コンピュータの基本ソフトウェアです。\n主な機能:\nデータ定義機能\nデータの整理、保存、管理\nデータ操作機能\nデータベースのトランザクション管理と運用管理\nデータベースの構築と保守機能\nその他の機能（通信機能、データ変換機能、相互アクセス・相互運用機能等）\nデータベースシステム これは、データベース、データベース管理システム (およびそのアプリケーション開発ツール)、アプリケーション、およびデータベース管理者 (DBA) で構成され、データを保存、管理、処理、および維持するシステムです。\nコンピューターデータ管理の開発 手動管理段階（1950年代半ば以前） データは保存、共有、独立していない\nファイル システム フェーズ (1950 年代後半から 1960 年代中期から後半) 保存はできるが、共有が不十分、冗長性が高く、独立性が低い\nデータベース システムの段階 (1960 年代後半から) データベースシステムの登場により、情報システムはデータ処理プログラム中心から共有データベース中心へと移行し、データ全体の構造化が実現しました。\nデータは高度に共有され、冗長性が低く、拡張が容易です。データの冗長性を大幅に削減し、ストレージスペースを節約し、データの独立性を高めることができます。\nデータモデル分類 モデル適用の目的の違いにより、モデルは2つのカテゴリまたは2つのレベルに分けられます。情報世界から抽象化されたデータモデルは概念データモデルと呼ばれ、DBMS（データベース管理システム）によってサポートされるデータモデルは情報世界から抽象化されます。コンピュータの世界では、構造データモデル（またはデータモデル）と呼ばれています。\nコンセプトデータモデル（概念モデル） 概念データモデルは、コンピュータシステムから独立したモデルです。システム内の情報の表現にはまったく関係しません。特定の組織が関心を持つ情報構造を記述するためにのみ使用されます。つまり、データをモデル化します。情報世界モデリングは、一般的にエンティティ・リレーションシップ法（E-R法）を用いて表現されます。主にデータベース設計に使用\n概念データ モデルでよく使用される用語は次のとおりです。\nエンティティ: 客観的に存在し、互いに区別できるものをエンティティと呼びます\n属性: エンティティを記述する特性を属性と呼びます。\nコード: エンティティを一意に識別する属性のセットはコードと呼ばれます。\nエンティティタイプ: エンティティ名と属性セットを使用して、類似のエンティティを抽象化し、特徴付けます。\nエンティティセット: 同じタイプのエンティティのコレクション\nドメイン: 属性の値の範囲は、属性のドメインと呼ばれます。\n関係: エンティティ間の対応する関係を関係と呼びます\n2つのエンティティ間の関係には3つの種類がある\n1対1のコンタクト 1対多の連絡 多対多の接続 実体関連法によって表現される概念データ モデルは、E-R 図と呼ばれます。エンティティは四角形で表され、属性は楕円形で表され、無向エッジはそれらを関連するエンティティに接続するために使用されます。\n構造データモデル（ロジックモデル） 構造データ モデルは、データベースの論理構造に直接関係します。すべての DBMS は構造データ モデルに基づいています。主にデータベース管理システムの実装に使用されます\n構造データモデルには主に、階層型、ネットワーク型、リレーショナル型、オブジェクト指向型などがある。\n階層モデル 階層モデルは、データ間の関係を表すために「ツリー構造」を使用します。そのデータ構造は「有向ツリー」です。\nメッシュモデル ネットワークモデルは「グラフ構造」を使用してデータ間の関係を表します。\nリレーショナルモデル リレーショナル モデルは、2 次元のテーブル構造を使用してエンティティとエンティティ間の関係を表すデータ モデルです。各 2 次元テーブルは行と列で構成され、これらは関係とも呼ばれます。リレーショナル モデルは、関係を記述したものです。したがって、リレーショナル モデルはリレーショナル パターンの集合であると言えます。\n物理モデル これはデータの抽象化の最低レベルです。システム内のデータの表現とアクセス方法、またはディスクやテープ上のデータの保存とアクセス方法を記述します。これはコンピュータシステム指向です。\nデータベースシステム構造 ストレージ構造が異なるデータベース製品は数多くあるが、アーキテクチャはすべて「3レベルモデルと2レベルイメージ」を採用しており、同じ特徴を持っている。\n3番目のレベルモード 概念モデル（基本表） スキーマまたは論理スキーマとも呼ばれ、データベース内のすべてのデータの論理構造と特性を記述したもので、すべてのユーザーに共通のデータ ビューです。\n外部モード（表示） ユーザー モードまたはサブモードとも呼ばれ、ユーザーとデータベース システム間のインターフェイスであり、ユーザーが使用するデータの説明です。\n内部モード（保存ファイル） ストレージ モードとも呼ばれ、データベースには 1 つの内部モードのみがあります。これは、データの物理的な構造と保存方法を記述したもので、データベース内でデータが整理される方法です。\n2 レベルの画像 データベース システムは、3 つのレベルのモデル間に、モデル/内部モデル マッピングと外部モデル/モデル マッピングという 2 つのレベルのマッピングを提供します。\nこれら 2 つのレベルのイメージがあるからこそ、データベース内のデータは高度な論理的独立性と物理的独立性を持つことになります。\nモード/内部モードイメージ（ストレージ） 概念レベルと内部レベルの間に存在し、概念モデルと内部モデルの相互変換を実現する\nデータベースのストレージ構造が変更された場合、データベース管理者はスキーマ/内部スキーマに対応する変更を加えてスキーマを変更しないようにできるため、アプリケーションを変更する必要がありません。データとプログラムの物理的な独立性を保証します\n外観モデル/モデルイメージ（表示） 外部レベルと概念レベルの間に存在し、外部モデルと概念モデルの相互変換を実現する\nスキーマが変更された場合、データベース管理者は各外部スキーマ/スキーマ イメージに対応する変更を加え、外部スキーマを変更せずに維持することができます。アプリケーションを変更する必要はありません。データとプログラムの論理的独立性を保証します\nデータの独立性とは、データがプログラムから独立しており、データの定義がプログラムから分離されていることを意味します。 DBMSの二次イメージング機能によりデータの独立性が確保されます。データの独立性には、データの物理的な独立性と論理的な独立性が含まれます。\nデータの物理的な独立性: ユーザーのアプリケーションとデータベース内のデータの物理的な保存は互いに独立しています。\nデータの論理的独立性: ユーザーのアプリケーションとデータベース内の論理構造は互いに独立しています。\nデータとプログラムが独立しているため、データの定義と記述をアプリケーション プログラムから分離できます。さらに、データアクセスはデータベース管理システムによって管理されるため、アプリケーションプログラムのコンパイルが簡素化され、アプリケーションプログラムの保守や修正にかかる手間が大幅に軽減されます。\nデータベースシステム構成 ハードウェアプラットフォームとデータベース 十分な大きさのメモリ、ディスクまたはディスクアレイ、その他のデバイス、データ転送速度を向上させるための高いチャネル容量\nソフトウェア データベース管理システム、データベース管理システムの動作をサポートするオペレーティングシステム、データベースインターフェースを備えた高級言語とそのコンパイルシステム、データベース管理システムを中核とするアプリケーション開発ツール、特定のアプリケーション環境向けに開発されたデータベースアプリケーションシステム\n人事 データベースを開発、管理、使用する人には、主にデータベース管理者、システムアナリスト、データベース設計者、アプリケーションプログラマー、エンドユーザーが含まれます。\nデータベース管理者の責任: データベースの情報内容と構造を決定し、データベースのストレージ構造とアクセス戦略を決定し、データのセキュリティ要件と整合性制約を定義し、データベースの使用と操作を監視し、データベースを改善および再編成します。 、データベースを再構築します。\n","date":"2023-02-06T19:57:35+08:00","permalink":"https://blog.yexca.net/ja/archives/86/","title":"データベース学習 1 データベース入門"},{"content":" この記事は Google 翻訳を使用して処理されました\n導入 コマンドラインから何かを実行して自慢したいと思わない男の子がいるでしょうか?以前から youtube-dl については知っていましたが、複雑すぎるようだったので使用していませんでした。今日試してみたところ、とても便利だとわかりました。\n環境 Python 3.7以降をインストールする Python の公式サイト でダウンロードしていい、インストールのとき、Add Python x.x to PATH をチェックしてね\nyt-dlp をインストール yt-dlp は youtube-dl に基づいて変更され、ダウンロード速度が速い\nダウンロード releases で yt-dlp.exe をダウンロードする\n構成 ダウンロードしたファイルを固定の場所に置き、マイコンピュータのプロパティを開き、システムの詳細設定 - 環境変数 - システム変数に移動し、Path を選択して編集をクリックし、新しいウィンドウで新規をクリックします。yt -dlp.exe のファイルを入力して\n次に、「はい」を 3 回クリックしてすべてのウィンドウを閉じる。\nテスト Win+R を押して「cmd」と入力し、Enter を押す。\ncmd に yt-dlp と入力します。Usage: yt-dlp [OPTIONS] URL [URL...] が表示されたら、設定は成功だ。\n更新 cmdに「yt-dlp -U」と入力するといい\n動画をダウンロード ダウンロードを開始するには、cmd に「yt-dlp」+「スペース」+「YouTube ビデオ リンク」と入力するだけです。\nデフォルトのダウンロードは720Pで、保存場所はC:/Users/%UserName%/です。\nダウンロード保存場所を変更する C:\\Users\\%UserName%\\AppData\\Roaming に新しいフォルダを作成し、yt-dlp という名前を付け、新しく作成したフォルダに入り、新しいファイル config.txt を作成します。\nファイルに次のコードを入力してください\n1 -o \u0026#39;C:/Users/%UserName%/Downloads/Video/%(title)s.%(ext)s\u0026#39; このうち、C:/Users/%UserName%/Downloads/Video/はダウンロードディレクトリです。\n%(title)s.%(ext)sは、ビデオのタイトルであるファイル名を保存する形式で、ビデオのタイトル.ビデオの拡張子名\n1080Pをダウンロード 1080P以上の動画は音声と動画が分離されているため、まずffmpegをダウンロードする必要があります。\nffmpeg 公式サイト にアクセスし、左下隅のシステムタイプを選択してから、ダウンロードを選択します。\nReleases · BtbN/FFmpeg-Builds を選択し、ffmpeg-n5.0-latest-win64-gpl-5.0.zipをダウンロードしました。\n次に、それを固定フォルダに配置し、システム変数に「bin」ファイルディレクトリを配置します。\nテスト cmd を開いて ffmpeg -version と入力します。バージョン番号が表示されれば、設定は成功です。\nクエリコマンド 現在のビデオの完全な形式を表示するには、yt-dlp -D [URL]と入力します (クエリのみ、ダウンロードは行われません)\nダウンロードコマンド 指定した形式でビデオをダウンロードするには、yt-dlp -f [ID] [URL]と入力します。ビデオとオーディオをダウンロードするには、[ID]+[ID]の組み合わせを使用できます。つまり、yt-dlp -f [ID]+[ID] [URL]はダウンロード後に自動的に結合されます\n注: 最高品質のビデオとオーディオをダウンロードします: -f \u0026quot;bv+ba/b\u0026quot;\naria2 を呼び出す ダウンロード コマンドの後に--external-downloader aria2c --external-downloader-args \u0026quot;-x 16 -k 1M\u0026quot; を追加するだけです。\n字幕をダウンロード 1 2 3 4 5 6 7 outube-dl --write-sub [url]\t//これはvtt形式の英語字幕とmkv形式の1080pビデオをダウンロードします youtube-dl --write-sub --skip-download [url] //ビデオをダウンロードせずに別の vtt 字幕ファイルをダウンロードします youtube-dl --write-sub --all-subs [url] //すべての言語の字幕をダウンロードします（ある場合） youtube-dl --write-auto-sub [url] //自動生成された字幕をダウンロードする（YouTubeのみ） ビデオリストをダウンロード 1 2 3 4 5 6 7 youtube-dl -f [format code] [palylist_url] //この方法では、指定された解像度のmp4ビデオをダウンロードできます youtube-dl [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl -cit [playlist_url] //ビデオ リストをダウンロードします。この方法でダウンロードされたビデオは、mkv または webm 形式である可能性があります。 youtube-dl --yes-playlist [url] //リンクがビデオリストの場合、リスト内のビデオをダウンロードします。上記と同じですが、mkv または webm 形式である可能性があります。 視覚化 Releases · jely2002/youtube-dl-gui 参考文献 yt-dlp - Github 【备份】youtube-dl使用介绍 - 简书 一文搞懂Windows系统【目录变量】的相关知识_黑就黑到底的博客-CSDN博客_username变量 ","date":"2022-07-25T12:52:27+08:00","permalink":"https://blog.yexca.net/ja/archives/52/","title":"コマンドラインからYouTube動画をダウンロードする"},{"content":"WordPress へようこそ。これが最初の投稿です。編集または削除して書き込みを始めてください。\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/ja/archives/1/","title":"Hello World！"}]