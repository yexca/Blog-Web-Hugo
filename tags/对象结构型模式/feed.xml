<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>对象结构型模式 on yexca'Blog</title><link>https://blog.yexca.net/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 对象结构型模式 on yexca'Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>yexca</copyright><lastBuildDate>Fri, 08 Sep 2023 12:15:26 +0800</lastBuildDate><atom:link href="https://blog.yexca.net/tags/%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/feed.xml" rel="self" type="application/rss+xml"/><item><title>代理模式</title><link>https://blog.yexca.net/archives/123/</link><pubDate>Fri, 08 Sep 2023 12:15:26 +0800</pubDate><guid>https://blog.yexca.net/archives/123/</guid><description>&lt;p>Proxy Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>为其他对象提供一种代理以控制对这个对象的访问&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.1lw7cilzkxds.webp"
loading="lazy"
alt="代理模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Proxy 保存一个引用使得代理可以访问实体；提供一个与 Subject 的接口相同的接口，使代理可以用来代替实体；控制对实体的存取，并可能负责创建和删除它&lt;/li>
&lt;li>Subject 定义 RealSubject 和 Proxy 的共用接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy&lt;/li>
&lt;li>RealSubject 定义 Proxy 所代表的实体&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Proxy 模式适用于在需要比较通用和复杂的对象指针代替简单的指针的时候，常见的情况有：&lt;/p></description></item><item><title>享元模式</title><link>https://blog.yexca.net/archives/122/</link><pubDate>Thu, 07 Sep 2023 13:54:55 +0800</pubDate><guid>https://blog.yexca.net/archives/122/</guid><description>&lt;p>Flyweight Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>运用共享技术有效地支持大量细粒度的对象&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e4%ba%ab%e5%85%83%e6%a8%a1%e5%bc%8f.7jg2ravau7o0.webp"
loading="lazy"
alt="享元模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Flyweight 描述一个接口，通过这个接口 Flyweight 可以接受并作用于外部状态&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ConcreteFlyweight 实现 Flyweight 接口，并为内部状态 (如果有) 增加存储空间。ConcreteFlyweight 对象必项是可共享的。它所存储的状态必须是内部的，即它必须独立于 ConcreteFlyweight 对象的场景&lt;/p></description></item><item><title>外观模式</title><link>https://blog.yexca.net/archives/121/</link><pubDate>Wed, 06 Sep 2023 03:02:02 +0800</pubDate><guid>https://blog.yexca.net/archives/121/</guid><description>&lt;p>Facade Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>为子系统中的一组接口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8f.6awzfhe505c0.webp"
loading="lazy"
alt="外观模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Facade 知道哪些子系统类负责处理请求；将客户的请求代理给适当的子系统对象&lt;/li>
&lt;li>Subsystem classes 实现子系统的功能；处理有 Facade 对象指派的任务；没有 Facade 的任何相关信息，即没有指向 Facade 的指针&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Facade 模式适用于：&lt;/p></description></item><item><title>装饰器模式</title><link>https://blog.yexca.net/archives/120/</link><pubDate>Tue, 05 Sep 2023 21:45:45 +0800</pubDate><guid>https://blog.yexca.net/archives/120/</guid><description>&lt;p>Decorator Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>动态地给一个对象添加一些额外的职责。就增加功能而言，Decorator 模式比生成子类更加灵活&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e8%a3%85%e9%a5%b0%e5%99%a8.2xwcg7gcu640.webp"
loading="lazy"
alt="装饰器"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Component 定义一个对象接口，可以给这些对象动态地添加职责&lt;/li>
&lt;li>ConcreteComponent 定义一个对象，可以给这个对象添加一些职责&lt;/li>
&lt;li>Decorator 维持一个指向 Component 对象的指针，并定义一个与 Component 接口一致的接口&lt;/li>
&lt;li>ConcreteDecorator 向组件添加职责&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Decorator 模式适用于：&lt;/p></description></item><item><title>组合模式</title><link>https://blog.yexca.net/archives/119/</link><pubDate>Sun, 03 Sep 2023 15:44:45 +0800</pubDate><guid>https://blog.yexca.net/archives/119/</guid><description>&lt;p>Composite Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将对象组合成树型结构以表示 &amp;ldquo;部分 - 整体&amp;rdquo; 的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性&lt;/p></description></item><item><title>桥接模式</title><link>https://blog.yexca.net/archives/118/</link><pubDate>Sat, 02 Sep 2023 17:34:34 +0800</pubDate><guid>https://blog.yexca.net/archives/118/</guid><description>&lt;p>Bridge Pattern 对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将抽象部分与其实现部分分离，使它们都可以独立地变化&lt;/p>
&lt;h2 id="结构">结构
&lt;/h2>&lt;p>&lt;img src="https://cdn.statically.io/gh/yexca/picx-images-hosting@master/2023/03-%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f.63qf1btnav80.webp"
loading="lazy"
alt="桥接模式"
>&lt;/p>
&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>Abstraction 定义抽象类的接口，维护一个指向 Implementor 类型对象的指针&lt;/li>
&lt;li>RefinedAbstraction 扩充由 Abstraction 定义的接口&lt;/li>
&lt;li>Implementor 定义实现类的接口，该接口不一定要与 Abstraction 的接口完全一致；事实上这两个接口可以完全不同
一般来说，Implementor 接口仅提供基本操作，而 Abstraction 定义了基于这些基本操作的较高层次的操作&lt;/li>
&lt;li>ConcreteImplementor 实现 Implementor 接口并定义它的具体实现&lt;/li>
&lt;/ul>
&lt;h2 id="适用性">适用性
&lt;/h2>&lt;p>Bridge 模式适用于：&lt;/p></description></item><item><title>适配器模式</title><link>https://blog.yexca.net/archives/117/</link><pubDate>Fri, 01 Sep 2023 15:03:03 +0800</pubDate><guid>https://blog.yexca.net/archives/117/</guid><description>&lt;p>Adapter Pattern 类结构型模式/对象结构型模式&lt;/p>
&lt;h2 id="意图">意图
&lt;/h2>&lt;p>将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作&lt;/p></description></item></channel></rss>