[{"content":" 該文章使用 Google 翻譯處理。\nRedis 是一個基於記憶體的鍵值結構資料庫，是互聯網技術領域使用廣泛的儲存中間件\n官網：https://redis.io 簡體中文網：https://www.redis.net.cn/ Redis 基於記憶體存儲，讀寫效能高，適合儲存熱點資料 (商品、資訊、新聞) 。是用 C 語言開發的一個開源的高效能鍵值對資料庫，儲存 value 類型比較豐富，也被稱為結構化的 NoSql (Not Only SQL) 資料庫\nNoSql 泛指非關係型資料庫，不是要取代關係型資料庫，而是關係型資料庫的補充\n關係型資料庫 (RDBMS)：\nMySQL Oracle DB2 SQLServer 非關係型資料庫 (NoSQL)：\nRedis Mongo DB MemCached Redis 下載安裝與執行 下載地址：\nWindows: https://github.com/microsoftarchive/redis/releases Linux: https://download.redis.io/releases/ cn: http://www.redis.cn/download.html Windows 版直接解壓縮即可使用，Linux 版：\n解壓縮 tar -zxvf redis-4.0.0.tar.gz -C /usr/local 安裝依賴環境 yum install gcc-c++ 進入安裝目錄，編譯 make 進入 redis 的 src 目錄安裝 make install 相關文件說明：\n/usr/local/redis-4.0.0/src/redis-server：Redis 服務啟動腳本 /usr/local/redis-4.0.0/src/redis-cli：Redis 客戶端腳本 /usr/local/redis-4.0.0/redis.conf：Redis 設定檔 服務端啟動，以 Windows 版為例，啟動命令：\nredis-server.exe redis.windows.conf 默認端口號為 6379，默認無密碼，啟動完成後可以用客戶端連接\n命令行連接 通過 redis-cli.exe 進行連接\nredis-cli.exe -h ip -p port -a password 如果省略，則使用 127.0.0.1:6379\n可以通過修改配置文件 (redis.windows.conf) 設置密碼\nrequirepass 123456 修改完成後重啟生效\n圖形化連接 Github：https://github.com/qishibo/AnotherRedisDesktopManager\n下載安裝後新建連接，輸入相關信息後連接即可\nDocker 部署 拉取鏡像\ndocker pull redis 獲取配置文件，下載對應版本，抽取配置文件即可，Linux 為 redis.conf\n創建 Redis 數據映射文件夾，例如\nmkdir /home/redis mkdir /home/redis/data 修改配置文件，傳送至部署機子，例如使用 scp 從 Win 傳至 Linux\nscp pathOfFile root@IP:/PathOfFile 啟動\ndocker run -p 6379:6379 --name redis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf 參考資料：https://cloud.tencent.com/developer/article/1670205\nRedis 數據類型 Redis 的 key 是字符串類型，value 有 5 種常用的數據類型\n字串 (string)：普通字串 哈希 (hash)：也叫散列 清單 (list)：依插入順序排序，可以有重複元素 集合 (set)：無序集合，不允許重複元素 有序集合 (sorted set/zset)：集合中每個元素關聯一個分數 (score)，根據分數升序排序 Redis 常用命令 Redis 大小寫不敏感\n字符串操作常用命令：\n# 設置指定 key 值 SET key value # 獲取指定 key 值 GET key # 設置指定 key 值，並將 key 的過期時間設為 seconds 秒 SETEX key seconds value # 只在 key 不存在時才設置 key 的值 SETNX key value hash 是一個 string 類型的 field 和 value 映射表，特別適合存儲對象，常用命令：\n# 將哈希表 key 中的 field 值設為 value HSET key field value # 取得儲存在哈希表中指定欄位的值 HGET key field # 刪除儲存在哈希表中的指定字段 HDEL key field # 獲取哈希表中所有字段 HKEYS key # 獲取哈希表中所有值 HVALS key 列表是簡單的字符串列表，按照插入順序排列，常用命令：\n# 將一個或多個值插入到清單頭部 LPUSH key value1 [value2] # 取得清單指定範圍內的元素 LRANGE key start stop # 移除並取得清單最後一個元素 RPOP key # 取得清單長度 LLEN key # 移出並取得清單的最後一個元素 # 如果清單沒有元素會阻塞清單直到等待逾時或發現可彈出元素為止 BRPOP key1 [key2] timeout 類似隊列，先進先出\n集合是字串型別的無序集合，集合成員唯一，常用指令：\n# 在集合中新增一個或多個成員 SADD key member1 [member2] # 傳回集合中的所有成員 SMEMBERS key # 取得集合的成員數 SCARD key # 傳回給定所有集合的交集 SINTER key2 [key2] # 傳回所有給定集合的並集 SUNION key1 [key2] # 移除集合中一個或多個成員 SREM key member1 [member2] 有序集合是字符串類型元素的集合，每個成員關聯一個 double 類型的分數，常用命令：\n# 在有序集合中新增一個或多個成員 ZADD key score1 member1 [score2 member2] # 透過索引區間傳回有序集合中指定區間內的成員 ZRANGE key start stop [WITHSCORES] # 有序集合中對指定成員的分數加上增量increment ZINCRBY key increment member # 移除有序集合中的一個或多個成員 ZREM key member1 [member2] 除了各數據類型專有，還有通用命令，即所有類型都可以使用的命令：\n# 尋找所有符合給定模式(pattern)的key KEYS pattern # pattern可以為* # 檢查指定key是否存在 EXISTS key # 傳回key所儲存的值的類型 TYPE key # 在key存在時刪除key DEL key 在 Java 中操作 Redis 如同使用 JDBC 操作 MySQL 資料庫一樣，需要使用 Redis 的 Java 用戶端進行操作 Redis\nRedis 的 Java 客戶端很多，常用的幾種：\nJedis Lettuce Spring Data Redis Jedis 封裝最好，與Redis 命令相同，是官方推薦；Lettuce 對線程呼叫更好，性能更好；Spring 對Redis 客戶端進行了整合，提供了Spring Data Redis，在Spring Boot 專案中還提供了對應的Starter，即spring-boot-starter-data-redis\nspring data Redis Spring Data Redis 是 Spring 的一部分，提供了在 Spring 應用中透過簡單的配置就可以存取 Redis 服務，對 Redis 底層開發包進行了高度封裝。在 Spring 專案中，可以使用Spring Data Redis來簡化 Redis 操作。網址：https://spring.io/projects/spring-data-redis\nMaven 座標：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Spring Data Redis 中提供了一個高度封裝類 RedisTemplate 對相關 api 進行了歸類封裝，將同一類型的操作封裝為 operation 接口：\nValueOperations：string 資料操作 SetOperations：set 類型資料操作 ZSetOperations：zset 類型資料操作 HashOperations：hash 類型的資料操作 ListOperations：list 類型的資料操作 配置 Redis 資料來源，設定文件\n# application spring: profiles: active: dev redis: host: ${sky.redis.host} port: ${sky.redis.port} password: ${sky.redis.password} database: ${sky.redis.database} # -dev sky: redis: host: localhost port: 6379 password: 123456 # 使用哪個資料庫，不填預設為 0 database: 10 Redis 預設有 16 個資料庫 (0-15)，可以透過修改設定檔來指定資料庫的數量\n編寫配置類，建立 RedisTemplate 對象\n@Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){ log.info(\u0026#34;開始創建 Redis 對象\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 設定 redis 的連接工廠對象 redisTemplate.setConnectionFactory(redisConnectionFactory); // 設定 redis key 的序列化器 redisTemplate.setKeySerializer(new StringRedisSerializer()); return redisTemplate; } } 此配置類別不是必須的，SpringBoot 框架會自動組裝 RedisTemplate 對象，不過預設的序列化器為 JdkSerializationRedisSerializer，儲存到 Redis 中的資料與原始資料有差別\n字串類型數據 @SpringBootTest public class RedisTest { @Autowired private RedisTemplate redisTemplate; @Test public void testString(){ // set redisTemplate.opsForValue().set(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); // get String name =(String) redisTemplate.opsForValue().get(\u0026#34;name\u0026#34;); System.out.println(name); // setex redisTemplate.opsForValue().set(\u0026#34;code\u0026#34;, \u0026#34;1234\u0026#34;, 2, TimeUnit.MINUTES); // setnx redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;1\u0026#34;); redisTemplate.opsForValue().setIfAbsent(\u0026#34;lock\u0026#34;,\u0026#34;2\u0026#34;); } } 哈希類型數據 @Test public void testHash(){ HashOperations hashOperations = redisTemplate.opsForHash(); // hset hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;Jerry\u0026#34;); hashOperations.put(\u0026#34;100\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;20\u0026#34;); // hget String name =(String) hashOperations.get(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); System.out.println(name); // hkeys Set keys = hashOperations.keys(\u0026#34;100\u0026#34;); System.out.println(keys); // hvals List values = hashOperations.values(\u0026#34;100\u0026#34;); System.out.println(values); // hdel hashOperations.delete(\u0026#34;100\u0026#34;, \u0026#34;name\u0026#34;); } 列表類型數據 @Test public void testList(){ ListOperations listOperations = redisTemplate.opsForList(); // lpush listOperations.leftPushAll(\u0026#34;mylist\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); listOperations.leftPush(\u0026#34;mylist\u0026#34;, \u0026#34;d\u0026#34;); // lrange List mylist = listOperations.range(\u0026#34;mylist\u0026#34;, 0, -1); System.out.println(mylist); // rpop listOperations.rightPop(\u0026#34;mylist\u0026#34;); // llen Long size = listOperations.size(\u0026#34;mylist\u0026#34;); System.out.println(size); } 集合類型數據 @Test public void testSet(){ SetOperations setOperations = redisTemplate.opsForSet(); // sadd setOperations.add(\u0026#34;set1\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;); setOperations.add(\u0026#34;set2\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;y\u0026#34;); // smembers Set members = setOperations.members(\u0026#34;set1\u0026#34;); System.out.println(members); // scard Long size = setOperations.size(\u0026#34;set1\u0026#34;); System.out.println(size); // sinter Set intersect = setOperations.intersect(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(intersect); // sunion Set union = setOperations.union(\u0026#34;set1\u0026#34;, \u0026#34;set2\u0026#34;); System.out.println(union); // srem setOperations.remove(\u0026#34;set1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 有序集合類型數據 @Test public void testZset(){ ZSetOperations zSetOperations = redisTemplate.opsForZSet(); // zadd zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, 10); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;b\u0026#34;, 12); zSetOperations.add(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 9); // zrange Set zset = zSetOperations.range(\u0026#34;zset1\u0026#34;, 0, -1); System.out.println(zset); // zincrby zSetOperations.incrementScore(\u0026#34;zset1\u0026#34;, \u0026#34;c\u0026#34;, 10); // zrem zSetOperations.remove(\u0026#34;zset1\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); } 通用命令操作 @Test public void testCommon(){ // keys Set keys = redisTemplate.keys(\u0026#34;*\u0026#34;); System.out.println(keys); // exists Boolean name = redisTemplate.hasKey(\u0026#34;name\u0026#34;); System.out.println(name); // type for (Object key : keys) { DataType type = redisTemplate.type(key); System.out.println(type.name()); } // del redisTemplate.delete(\u0026#34;set2\u0026#34;); } ","date":"2024-02-23T16:40:34+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/157/","title":"Redis"},{"content":" 該文章使用 Google 翻譯處理。\n順序棧 (數組實作) #include \u0026lt;stdio.h\u0026gt; // 元素 elem 進棧，a 為數組，top 值為目前堆疊的棧頂位置 int push(int* a,int top,int elem) { a[++top]=elem; return top; } // 資料元素出棧 int pop(int * a,int top) { if (top==-1) { printf(\u0026#34;空堆疊\u0026#34;); return -1; } printf(\u0026#34;彈棧元素：%d\\n\u0026#34;,a[top]); top--; return top; } int main(void) { int a[100]; int top=-1; top = push(a, top, 1); top = push(a, top, 2); top = push(a, top, 3); top = push(a, top, 4); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); top = pop(a, top); return 0; } 輸出結果：\n彈棧元素：4 彈棧元素：3\n彈棧元素：2 彈棧元素：1 空堆疊\n鏈堆疊 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct lineStack{ int data; struct lineStack * next; }lineStack; // stack 為目前的鏈棧，a 表示入棧元素 lineStack* push(lineStack * stack,int a) { // 建立儲存新元素的節點 lineStack * line=(lineStack*)malloc(sizeof(lineStack)); line-\u0026gt;data=a; // 新節點與頭節點建立邏輯關係 line-\u0026gt;next=stack; // 更新頭指標的指向 stack=line; return stack; } // 棧頂元素出鏈棧的實作函數 lineStack * pop(lineStack * stack) { if (stack) { // 宣告一個新指標指向棧頂節點 lineStack * p=stack; // 更新頭指針 stack=stack-\u0026gt;next; printf(\u0026#34;出棧元素：%d \u0026#34;,p-\u0026gt;data); if (stack) { printf(\u0026#34;新棧頂元素：%d\\n\u0026#34;,stack-\u0026gt;data); } else { printf(\u0026#34;堆疊已空\\n\u0026#34;); } free(p); } else { printf(\u0026#34;棧內沒有元素\u0026#34;); return stack; } return stack; } int main(void) { lineStack * stack=NULL; stack=push(stack, 1); stack=push(stack, 2); stack=push(stack, 3); stack=push(stack, 4); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); stack=pop(stack); return 0; } 輸出結果：\n出棧元素：4 新棧頂元素：3 出棧元素：3 新棧頂元素：2\n出棧元素：2 新棧頂元素：1\n出棧元素：1 堆疊已空 棧內沒有元素\n","date":"2021-11-21T22:19:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/17/","title":"資料結構 堆疊程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n程式碼 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // malloc()、exit() #define Size 5 // 對 Size 進行巨集定義，表示順序表申請空間的大小 typedef struct Table { int * head; // 宣告了一個名為head的長度不確定的數組，也叫“動態數組” int length; // 記錄當前順序表的長度 int size; // 記錄順序表分配的儲存容量 }table; // 初始化函數 table initTable() { table t; t.head = (int*)malloc(Size * sizeof(int)); // 建構一個空的順序表，動態申請儲存空間 if (!t.head) // 若申請失敗，作出提示並直接退出程序 { printf(\u0026#34;初始化失敗\u0026#34;); exit(0); } t.length = 0; // 空表的長度初始化為 0 t.size = Size; // 空表的初始儲存空間為 Size return t; } // 插入函數，其中，elem 為插入的元素，add 為插入到順序表的位置 table addTable(table t, int elem, int add) { int i; // 判斷插入本身是否有問題（如果插入元素位置比整張表的長度 +1 還大 (如果相等，是尾隨的情況)，或者插入的位置本身不存在，程序作為提示並自動退出) if (add \u0026gt; t.length + 1 || add \u0026lt; 1) { printf(\u0026#34;插入位置有問題\u0026#34;); return t; } // 做插入操作時，首先需要看順序表是否有多餘的儲存空間提供給插入的元素，如果沒有，則需要申請 if (t.length == t.size) { t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) { printf(\u0026#34;儲存分配失敗\u0026#34;); return t; } t.size += 1; } // 插入操作，需要將從插入位置開始的後續元素，逐個後移 for (i = t.length - 1; i \u0026gt;= add - 1; i--) { t.head[i + 1] = t.head[i]; } // 後移完成後，直接將所需插入元素，新增至順序表的相應位置 t.head[add - 1] = elem; // 由於添加了元素，所以長度 +1 t.length++; return t; } // 刪除函數 table delTable(table t, int add) { int i; if (add \u0026gt; t.length || add \u0026lt; 1) { printf(\u0026#34;被刪除元素的位置有誤\u0026#34;); exit(0); } for (i = add; i \u0026lt; t.length; i++) { t.head[i - 1] = t.head[i]; } t.length--; return t; } // 尋找函數，其中，elem 表示要尋找的資料元素的值 int selectTable(table t, int elem) { int i; for (i = 0; i \u0026lt; t.length; i++) { if (t.head[i] == elem) { return i + 1; } } return -1; } // 更改函數，其中，elem 為要更改的元素，newElem 為新的資料元素 table amendTable(table t, int elem, int newElem) { int add = selectTable(t, elem); t.head[add - 1] = newElem; return t; } // 輸出順序表中元素的函數 void displayTable(table t) { int i; for (i = 0; i \u0026lt; t.length; i++) { printf(\u0026#34;%d \u0026#34;, t.head[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int i, add; table t1 = initTable(); // 在順序表中新增元素 for (i = 1; i \u0026lt;= Size; i++) { t1.head[i - 1] = i; t1.length++; } printf(\u0026#34;原順序表：\\n\u0026#34;); displayTable(t1); printf(\u0026#34;刪除元素 1:\\n\u0026#34;); t1 = delTable(t1, 1); displayTable(t1); printf(\u0026#34;在第 2 的位置插入元素 5:\\n\u0026#34;); t1 = addTable(t1, 5, 2); displayTable(t1); printf(\u0026#34;尋找元素 3 的位置:\\n\u0026#34;); add = selectTable(t1, 3); printf(\u0026#34;%d\\n\u0026#34;, add); printf(\u0026#34;將元素 3 改為 6:\\n\u0026#34;); t1 = amendTable(t1, 3, 6); displayTable(t1); return 0; } 結果 程式運行結果為：\n原順序表： 1 2 3 4 5\n刪除元素 1:\n2 3 4 5\n在第 2 的位置插入元素 5:\n2 5 3 4 5\n尋找元素 3 的位置:\n3\n將元素 3 改為 6:\n2 5 6 4 5\n","date":"2021-11-20T23:01:47+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/16/","title":"資料結構 順序表程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n簡單鍊錶 #include \u0026lt;stdio.h\u0026gt; struct student { long num; float score; struct student *next; }; void main() { struct student a, b, c, *head, *p; a.num = 99101; a.score = 89.5; b.num = 99103; b.score = 90; c.num = 99107; c.score = 85; // 對結點的 num 和 score 成員賦值 head = \u0026amp;a; // 將結點 a 的起始位址賦給頭指標 head a.next = \u0026amp;b; // 將結點 b 的起始位址賦給 a 結點的 next 成員 b.next = \u0026amp;c; c.next = NULL; // c 結點的 next 成員不存放其他結點位址 p = head; // 使 p 指標指向 a 結點 do { printf(\u0026#34;%ld %5.1f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); // 輸出 p 指向的結點的數據 p = p-\u0026gt;next; // 使 p 指向下一個結點 }while(p != NULL); // 輸出完 c 結點後 p 的值為 NULL system(\u0026#34;pause\u0026#34;); } 記憶體分配函數 malloc 函數 void *malloc(unsigned int size); 作用是在記憶體的動態儲存區中分配一個長度為 size 的連接空間。有些函數的值（即傳回值）是一個指向分配空間起始位址的指標（基底型別為 void）。如果些函數未能成功地執行（例如記憶體空間不足）則傳回空指標 NULL。\ncalloc 函數 void *calloc(unsigned n, unsigned size); 其作用是在記憶體的動態區儲存中分配 n 個長度為 size 的連續空間。函數傳回一個指向分配空間起始位址的指針，如果分配不成功，則傳回 NULL。 用 calloc 函數可以為一維數組開啟動態儲存空間， n 為數組元素個數，每個元素長度為 size。\nfree 函數 void free(void *p); 其作用是釋放由 p 指向的記憶體區，使這部分記憶體區能被其它變數使用， p 是最後一次呼叫 calloc 或 malloc 函數時傳回的值。 free 函數無回傳值​​。請注意：以前的C版本提供的 malloc 和 calloc 函數得到的是指向字元型資料的指標。 ANSI C 提供的 malloc 和 calloc 函數規定為 void * 類型。\n動態鍊錶的實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define NULL 0 #define LEN sizeof(struct student) struct student { long num; float score; struct student *next; }; struct student *create() { struct student *p1, *p2, *head; int num; float score; int n = 0; head = NULL; p1 = p2 = (struct student *)malloc(LEN); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); while(p1-\u0026gt;num != 0) { n ++; if(n == 1) head = p1; else p2-\u0026gt;next = p1; p2 = p1; p1 = (struct student *)malloc(sizeof(struct student)); printf(\u0026#34;please input num and score.\\n\u0026#34;); scanf(\u0026#34;%d,%f\u0026#34;, \u0026amp;p1-\u0026gt;num, \u0026amp;p1-\u0026gt;score); } p2-\u0026gt;next = NULL; return head; } void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }while(p != NULL); } } void main() { struct student *head; head = create(); printlist(head); system(\u0026#34;pause\u0026#34;); } // 列印鍊錶 void printlist(struct student *head) { struct student *p; p = head; if(head != NULL) { do { printf(\u0026#34;num=%d score=%5.2f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; } while (p != NULL); } /* while(p -\u0026gt; next != NULL) { printf(\u0026#34;num=%d score=%f\\n\u0026#34;, p-\u0026gt;num, p-\u0026gt;score); p = p-\u0026gt;next; }*/ } // 刪除節點 struct student *delNode(struct student *head, int num) { printf(\u0026#34;delNode.\\n\u0026#34;); struct student *p1, *p2; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != num) { p2 = p1; p1 = p1-\u0026gt;next; } if(p1-\u0026gt;num == num) { if(p1 == head) head = p1-\u0026gt;next; else p2-\u0026gt;next = p1-\u0026gt;next; } else printf(\u0026#34;Can not find list num.\\n\u0026#34;); } return head; } // 更新節點 struct student *update(struct student *head, int index, int num, float score) { printf(\u0026#34;update.\\n\u0026#34;); struct student *p; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p = head; while(p-\u0026gt;next != NULL \u0026amp;\u0026amp; p-\u0026gt;num != index) { p = p-\u0026gt;next; } if(p-\u0026gt;num == index) { p-\u0026gt;num = num; p-\u0026gt;score = score; } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } // 增加節點 struct student *add(struct student *head, int index, int num, float score) { printf(\u0026#34;add.\\n\u0026#34;); struct student *p1, *p2, *p3; if(head == NULL) { printf(\u0026#34;The List is NULL.\\n\u0026#34;); } else { p1 = p2 = head; while(p1-\u0026gt;next != NULL \u0026amp;\u0026amp; p1-\u0026gt;num != index) { p1 = p1-\u0026gt;next; p2 = p1; } if(p1-\u0026gt;num == index) { p3 = (struct student *)malloc(LEN); p3-\u0026gt;num = num; p3-\u0026gt;score = score; if(p2-\u0026gt;next == NULL) { p2-\u0026gt;next = p3; p3-\u0026gt;next = NULL; } else { p3-\u0026gt;next = p2-\u0026gt;next; p2-\u0026gt;next = p3; } } else printf(\u0026#34;Can not find list index.\\n\u0026#34;); } return head; } ","date":"2021-11-17T12:00:49+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/15/","title":"資料結構 鍊錶程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n//數組堆疊的實現 #include\u0026lt;stdio.h\u0026gt; #define MaxSize 50 typedef struct Stack_Array{ int data[MaxSize]; int top; }Sqstack,*pSqstack; void Initstack(); //初始化 int Isempty(); //判斷棧空 int Push(); //入堆疊 int Pop(); //出堆疊 int Gettop(); //get 堆疊頂元素 int main(void) //測試 { int val; Sqstack s1; pSqstack ps1=\u0026amp;s1; Initstack(\u0026amp;s1); //初始化 if(Isempty(\u0026amp;s1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); printf(\u0026#34;輸入壓棧元素的值\u0026#34;); //壓棧 2 scanf(\u0026#34;%d\u0026#34;,\u0026amp;val); Push (ps1,\u0026amp;val); if(Isempty(ps1)) //判斷棧空 printf(\u0026#34;棧為空！\\n\u0026#34;); else printf(\u0026#34;棧不為空！\\n\u0026#34;); if(Gettop(ps1,\u0026amp;val)) //get 堆疊頂元素 printf(\u0026#34;棧頂值為%d\\n\u0026#34;,val); else printf(\u0026#34;棧頂元素查找失敗！\\n\u0026#34;); if(Pop(ps1,\u0026amp;val)) //出棧 printf(\u0026#34;出棧成功，出棧元素為%d\\n\u0026#34;,val); else printf(\u0026#34;出棧失敗！\\n\u0026#34;); return 0; } //初始化 void Initstack (pSqstack ps1) { ps1-\u0026gt;top=-1; return; } //判斷棧空 int Isempty(pSqstack ps1) { if(ps1-\u0026gt;top==-1) return 1; else return 0; } //若棧不滿，則進行壓棧 int Push(pSqstack ps1,int *val)//*val:接受一個地址(int *(\u0026amp;val)) { if(ps1-\u0026gt;top==MaxSize) return 0; else { ps1-\u0026gt;top++; ps1-\u0026gt;data[ps1-\u0026gt;top]=*val;//這裡傳遞的是值，這裡的*val是*(\u0026amp;val),\u0026amp;val是由主調函數輸入 //也可写作ps1-\u0026gt;data[++ps1-\u0026gt;top]=*val; 一定是++ps1-\u0026gt;top return 1; } } //若棧不空，則進行出棧，用val返回棧頂元素 int\tPop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top--]; return 1; } } //get棧頂元素，用val返回棧頂元素 int Gettop(pSqstack ps1,int *val) { if(Isempty(ps1)) return 0; else { *val=ps1-\u0026gt;data[ps1-\u0026gt;top]; return 1; } } 圖解簡化\n//棧的鍊式存儲實現 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define Stack_Init_Size 10 // 初始化堆疊的最大長度 #define StackIncrement 10 // 若堆疊最大空間不夠時，需要增加的長度 typedef int ElemType; typedef int Status; typedef struct { ElemType *base; // 堆疊底部指針 ElemType *top; // 堆疊頂指針 int stack_size; // 堆疊的最大長度 } SqStack; // 初始化堆疊 Status InitStack(SqStack *S) { // 分配初始空間 S-\u0026gt;base = (ElemType *) malloc(Stack_Init_Size * sizeof(ElemType)); if (!S-\u0026gt;base) { exit(0); } S-\u0026gt;top = S-\u0026gt;base; /// 棧頂與棧底相同 S-\u0026gt;stack_size = Stack_Init_Size; // 堆疊的最大長度等於初始長度 return 1; } // 判斷棧是否為空，只需要判斷棧頂指標與棧底指標是否相同即可 Status EmptyStack(SqStack *S) { return S-\u0026gt;base == S-\u0026gt;top; } // 取得棧的實際長度，棧頂減去棧底指標即為棧的長度 Status LengthStack(SqStack *S) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } return (Status) (S-\u0026gt;top - S-\u0026gt;base); } // 取得棧頂的元素，參數e用來存放棧頂的元素 Status GetTopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;top == S-\u0026gt;base) { return 0; } *e = *(S-\u0026gt;top - 1); return 1; } // 進棧，參數e是要進棧的元素 Status PushStack(SqStack *S, ElemType e) { // 若棧的最大長度不會夠用時，重新開闢，增大長度 if (S-\u0026gt;top - S-\u0026gt;base \u0026gt;= S-\u0026gt;stack_size) { S-\u0026gt;base = (ElemType *)realloc(S-\u0026gt;base, (S-\u0026gt;stack_size + StackIncrement) * sizeof(ElemType)); if (!S-\u0026gt;base) { return 0; } // 棧頂指標為棧底指標加上堆疊之前的最大長度 S-\u0026gt;top = S-\u0026gt;base + S-\u0026gt;stack_size; // 堆疊目前的最大長度等於堆疊之前的最大長度與增加的長度總和 S-\u0026gt;stack_size += StackIncrement; } *S-\u0026gt;top++ = e; // 先賦值，後棧頂指標上移 return 1; } // 出棧，參數e用來存放出棧的元素 Status PopStack(SqStack *S, ElemType *e) { if (S-\u0026gt;base == S-\u0026gt;top) { return 0; } *e = *--S-\u0026gt;top; // 棧頂指標先下移，後賦值 return 1; } // 銷毀棧，釋放棧空間，棧頂棧底指標置為NULL，長度置為0 Status DestroyStack(SqStack *S) { free(S-\u0026gt;base); S-\u0026gt;base = S-\u0026gt;top = NULL; S-\u0026gt;stack_size = 0; return 1; } // 遍歷棧，依序列印每個元素 Status StackTraverse(SqStack *S) { ElemType *p; if (S-\u0026gt;top == S-\u0026gt;base) { printf(\u0026#34;Stack is NULL.\\n\u0026#34;); return 0; } p = S-\u0026gt;top; // 由棧頂依序向下遍歷 while (p \u0026gt; S-\u0026gt;base) { p--; printf(\u0026#34;%d \u0026#34;, *p); } printf(\u0026#34;\\n\u0026#34;); return 1; } int main() { SqStack q, *S; S = \u0026amp;q; int i, n, e; printf(\u0026#34;Creat a NULL Stack :\\n\u0026#34;); InitStack(S); printf(\u0026#34;input the length of the Stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); } printf(\u0026#34;Is the stack NULL?\\n\u0026#34;); if (EmptyStack(S)) { printf(\u0026#34;Yes!\\n\u0026#34;); } else { printf(\u0026#34;No!\\n\u0026#34;); } printf(\u0026#34;The length of stack is %d.\\n\u0026#34;, LengthStack(S)); printf(\u0026#34;The stack is :\\n\u0026#34;); StackTraverse(S); e = GetTopStack(S, \u0026amp;e); printf(\u0026#34;The top data is %d.\\n\u0026#34;, e); printf(\u0026#34;input the data to the stack :\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;e); PushStack(S, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Delete the top data : \u0026#34;); e = PopStack(S, \u0026amp;e); printf(\u0026#34;%d\\n\u0026#34;, e); printf(\u0026#34;The new stack is :\\n\u0026#34;); StackTraverse(S); printf(\u0026#34;Destroy the stack :\\n\u0026#34;); DestroyStack(S); StackTraverse(S); return 0; } ","date":"2021-11-11T23:03:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/14/","title":"C 資料結構程式碼"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 ctxbb 編寫，因為是圖片，沒翻譯\n","date":"2021-11-11T18:01:33+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/13/","title":"揚州杏雨後"},{"content":" 該文章使用 Google 翻譯處理。\n雖然米忽悠的米遊社提供了原神樹脂的查看，但是使用電腦時每次查看還要打開手機然後打開米遊社著實有億點不方便\n原作者文章：自己做了一個樹脂記錄軟件\n原文軟件鏈接：提取碼：1w5b\n下載完成後打開，會提示輸入 uid 和 cookie，下面是如何抓取米遊社的 cookie\n首先打開米遊社並登錄\n然後按 F12 打開開發者工具，這時刷新網頁\n然後點擊“網絡-ys/”，找到請求標頭，然後在 cookie 右擊複製\n注意：需要的 cookie 字段為 account_id=xxx; cookie_token=xxx，請自行修改\n**2022-6-6 修改 (hiyoung)**\n由於米哈遊修改了 bbs 可以獲取的 Cookie，導致一次獲取的 Cookie 缺失，所以需要增加步驟\n按下鍵盤上的 F12 或右鍵檢查,開啟開發者工具,點選 Console\n輸入\nvar cookie=document.cookie;var ask=confirm(\u0026#39;Cookie:\u0026#39;+cookie+\u0026#39;\\n\\nDo you want to copy the cookie to the clipboard?\u0026#39;);if(ask==true){copy(cookie);msg=cookie}else{msg=\u0026#39;Cancel\u0026#39;} 回車執行，並在確認無誤後點擊確定。此時 Cookie 已經復製到你的粘貼板上了\n注意：請使用 Chrome，Edge 獲取也是不完整的 (yexca)\n","date":"2021-11-10T15:21:30+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/12/","title":"原神樹脂查看與推送"},{"content":" 該文章使用 Google 翻譯處理。\n首先我們找到要下載的視頻 (廢話)，複製圖中框選部分的鏈接\n然後打開視頻下載解析網站，輸入複製的鏈接然後點擊解析視頻圖片 (如需驗證根據網站提示進行即可)\n然後點擊下載視頻即可\n// 這篇好水\n","date":"2021-11-10T11:29:51+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/11/","title":"微博影片下載"},{"content":" 該文章使用 Google 翻譯處理。\n多數情況下，我們瀏覽網頁一般使用瀏覽器或系統自帶的返回，但有些系統的交互邏輯及其不好用，這時在網頁添加一個返回上一頁按鈕可以極大改善瀏覽體驗\n首先，在 WordPress 的後台點擊“外觀-自定義”來到可視化編輯頁面\n在左方找到“額外CSS”選項（一般在最後）\n然後在裡面輸入下方代碼\n.float-button { position: fixed; height: 90px; width: 40px; bottom: 90px; right: 50px; /* 可以自行修改相關描述 */ } 輸入完成後儲存，然後編輯主題相關介面\n如果您不能訪問服務器文件，可以在 WordPress 後台的“外觀-主題編輯器”中找到要添加的界面修改\n如果您可以存取伺服器文件，可以開啟路徑 網站根目錄/wp-content/themes/\u0026lt;您的主題名稱\u0026gt;/ 然後開啟相應頁面修改\n只需在相關頁面文件插入下面代碼並保存即可\n\u0026lt;div class=\u0026#34;float-button\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; name=\u0026#34;Submit\u0026#34; value=\u0026#34;返回\u0026#34; onclick=\u0026#34;javascript:history.back(-1);\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 可以自行修改相關描述 --\u0026gt; 參考文章 網頁上的「返回上一頁」的幾種實作程式碼\ndiv 套路之懸浮的 button\n","date":"2021-11-10T11:06:27+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/10/","title":"WordPress 新增返回上一頁按鈕"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n準備條件：win11 專業版及以上，將系統地區調至美國\n在設置-\u0026gt;應用 -\u0026gt; 可選功能 -\u0026gt; 更多Windows功能中勾選虛擬機平台，然後重啟系統即可\n然後下載安裝包，鏈接: https://pan.baidu.com/s/1215GlKeDCHcbE0I2SgtWLg 提取碼: frkx\n下載完成後我們可以看到下面兩個文件：倒數第二個是安卓子系統安裝包，倒數第一個是WSA工具箱用於安裝 apk 文件\n最下面兩份文件\n現在我們以管理員身份打開 Windows power shell\n執行指令：add-appxpackage 空格 + 安卓子系統的文件路徑 (切記指令與路徑之間加一個空格)\n!Win11android_4\n出現上面這個即說明安裝成功\n然後在開始選單即可看到安裝完成的安卓子系統，點擊運行，勾選上開發者模式\n解壓縮另一個 zip 檔案運行，即可安裝 apk 文件\n至此即安裝完成\n**********以下內容由 yexca 添加**********\n如果工具箱無法安裝或出現下圖情況，請打開子系統設置，打開第一個選項“文件”，再打開工具箱即可 獲取文件路徑 在文件上鼠標右擊選擇“屬性-安全”，第一行對象名稱即為文件路徑\nWSA 工具箱 原發布地址\n","date":"2021-11-09T23:45:42+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/9/","title":"Win11 官方安卓子系統安裝"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n1.SQL ORDER BY 關鍵字 ORDER BY 關鍵字用於對結果集按照一個列或者多個列進行排序。\nORDER BY 關鍵字默認按照升序對記錄進行排序。如果需要按照降序對記錄進行排序，您可以使用 DESC 關鍵字\nSQL ORDER BY 語法 SELECT *column\\_name*,*column\\_name* FROM *table\\_name* ORDER BY *column\\_name*1,*column\\_name*2 ASC|DESC; –ASC 表示升序，DESC 表示降序\n–使用 order by 語句時應放在所有語句的最後使用，並且排序多個列時先排 column\\_name1 再 column\\_name2…\n2.刪除所有數據（delete 和 drop table） 您可以在不刪除表的情況下，刪除表中所有的行。這表示表格結構、屬性、索引將保持不變：DELETE FROM table\\_name;\n或\nDELETE * FROM table\\_name;\n**註釋：**在刪除記錄時要格外小心！因為您不能重來！\nDROP TABLE 語句 DROP TABLE 語句用於刪除表。DROP TABLE table\\_name\n**註釋：**與 elete 不同的是 drop table 會刪除表數據和結果，也是不可逆的！\nDROP DATABASE 語句 DROP DATABASE 語句用於刪除數據庫。DROP DATABASE database\\_name\nTRUNCATE TABLE 語句 如果我們僅僅需要刪除表內的數據，但並不刪除表本身，那麼我們該如何做呢？\n請使用 TRUNCATE TABLE 語句：TRUNCATE TABLE table\\_name\n3.SQL join SQL join 用於把來自兩個或多個表的行結合起來。\n下圖展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相關的 7 種用法。\nINNER JOIN：如果表中有至少一個匹配，則返回行(INNER JOIN 與 JOIN 是相同的) LEFT JOIN：即使右表中沒有匹配，也從左表返回所有的行 RIGHT JOIN：即使左表中沒有匹配，也從右表返回所有的行 FULL JOIN：只要其中一個表中存在匹配，則返回行 註釋：SQL 中的 join 語句其實對應數據庫理論中的連接概念，left join、right join 和 inner join 對應自然連接，full join 對應笛卡爾積\n4.SQL 約束 (Constraints) CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); NOT NULL – 指示某列不能存儲 NULL 值。 UNIQUE – 保證某列的每行必須有唯一的值。（一個表可以有多個 UNIQUE 約束但只能有一個 primary key，primary key 自動包含 unique 約束） PRIMARY KEY – NOT NULL 和 UNIQUE 的結合。確保某列（或兩個列多個列的結合）有唯一標識，有助於更容易更快速地找到表中的一個特定的記錄。（主鍵） FOREIGN KEY – 保證一個表中的數據匹配另一個表中的值的參照完整性。（外鍵） CHECK – 保證列中的值符合指定的條件。 DEFAULT – 規定沒有給列賦值時的默認值。 5.AUTO INCREMENT 字段 我們通常希望在每次插入新記錄時，自動地創建主鍵字段的值。\n我們可以在表中創建一個 auto-increment 字段。\n下面的 SQL 語句把 “Persons” 表中的 “ID” 列定義為 auto-increment 主鍵字段：CREATE TABLE Persons\n( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) ) 在上面的實例中，IDENTITY 的開始值是 1，每條新記錄遞增 1。\n**提示：**要規定 “ID” 列以 10 起始且遞增 5，請把 identity 改為 IDENTITY(10,5)。\n要在 “Persons” 表中插入新記錄，我們不必為 “ID” 列規定值（會自動添加一個唯一的值）：\nINSERT INTO Persons (FirstName,LastName) VALUES (\u0026#39;Lars\u0026#39;,\u0026#39;Monsen\u0026#39;) 上面的 SQL 語句會在 “Persons” 表中插入一條新記錄。”ID” 列會被賦予一個唯一的值。”FirstName” 列會被設置為 “Lars”，”LastName” 列會被設置為 “Monsen”。\n6.觸發器 參見：SqlServer 基礎之(觸發器) – wangchuang2017 – 博客園\n","date":"2021-11-08T11:51:18+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/8/","title":"SQL 語句的一些語法細節 (SQL SERVER 語句)"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n在安裝完 SQL server 和 navicat 後在 navicat 中添加數據庫：\n1.連接名無要求，按照自己需要命名\n2.打開安裝好的 SQL server 配置管理器\n注意 SQL Server（SQLEXPRESS）要保證在運行中，否則 navicat 無法連接\n雙擊開啟後點選服務，可以看到自己的主機名\n3.此時打開 navicat 在主機的地方填上：主機名 \\SQLEXPRESS (格式)\n4.用戶名填 sa (為安裝 SQL server 時的預設用戶名，具體 SQL server 網路教學很多可以自己參考) ，密碼是自己設定的 (同樣在 SQL server 安裝時設定的密碼)\n5.測試連接成功即可使用\n注：僅個人在安裝過程中遇到的問題，具體安裝教程請參考網絡\n附上 navicat 15 及註冊機：https://pan.baidu.com/s/1cJ1EZ9Gyz6Jp6J03VqcDHA\n提取碼：3n7g\n","date":"2021-11-07T23:41:46+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/7/","title":"關於在使用 navicat 連接 SQL server 的一些問題"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫，翻譯自 yexca\n其文章 (簡體中文): https://blog.hiyoung.xyz/2022/12/15/997871bc263d/\n正文 VSC只是一個純文本編輯器，不是 IDE (集成開發環境)，不含編譯器和許多其它功能，所以編譯器要自己裝好\n第一步：在 vscode 官網下載軟件，鏈接：Visual Studio Code – Code Editing. Redefined\n第二步：我們需要下載一個編譯器，C 語言使用 gcc，鏈接：MinGW-w64 – for 32 and 64 bit Windows download | SourceForge.net，選最新版本中的 x86\\_64-posix-seh 即可，網站下載可能較慢，下面給出百度網盤鏈接\n（以下附上百度網盤秒傳鏈接：b48357234368d9ba439fc0db6e86531d#84cbf1dc60abe4fff77d035540ea3132#140697937#mingw64.zip）\n（正常百度網盤鏈接：鏈接: https://pan.baidu.com/s/17FYT\\_Y-s-I2yajFc2MICqw 提取碼: ewis ）\n第三步：將 E:\\mingw64\\bin 添加到系統變量中（盤符根據自己編譯器安裝的位置）\n以 Win11 為例：打開設置-\u0026gt;系統-\u0026gt;關於-\u0026gt;高級系統設置-\u0026gt;環境變量-\u0026gt;系統變量-\u0026gt;點擊Path-\u0026gt;編輯-\u0026gt; 瀏覽-\u0026gt; 把對應文件加入即可\n第四步：\n按 Win+R，運行 cmd（不要跳這一步），輸入 gcc，應該會提示 no input files 而不是“不是內部命令或外部命令”或者“無法將“gcc” 項識別為cmdlet、函數、腳本文件或可運行程序的名稱”。如果是“不是內部命令或外部命令”，說明 gcc 在的文件夾沒有在環境變量的Path中，要加進去才行。如果加了還是這樣，重啟（不要忘記重啟）。如果重啟了還不行，那就是你自己進行的操作有問題。\n輸 gcc -v 可以顯示出 gcc 的版本。如果顯示出來的版本與你剛下的不同/更老，說明 Path 裡原本有老版本的編譯器，可能是安裝其它 IDE 時裝上的。則需要去掉 Path 裡原來的那一個 gcc 的路徑。\n這兩項驗證一定要符合，否則必須修改環境變量。小心別錯刪了。\n第五步：現在打開 vscode，下載相關插件\n第六步：我們需要寫兩個 json 文件，下面依次是 launch.json 和tasks.json（兩個文件名也必須是launch.json 和tasks.json ） 注意看代碼註釋，兩個文件都有幾處地方需要將路徑改為自己編譯器的路徑\n{ // 使用 IntelliSense 了解相關屬性。 // 懸停以查看現有屬性的描述。 // 欲了解更多信息，請訪問: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\bin\\\\$ {fileBasenameNoExtension}.exe\u0026#34;,//這裡意思生成的二進制代碼會放入當前文件的bin文件夾中，我們需要自己新建一個bin文件夾 \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;為 gdb 啟用整齊打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34; } ] } { \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: gcc.exe 生成活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ /*\u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-g\u0026#34;//多檔編譯*/ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;(多文件)gcc.exe - 生成和調試活動文件\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;E:\\\\mingw64\\\\bin\\\\gcc.exe\u0026#34;,//改成自己的檔案路徑 \u0026#34;args\u0026#34;: [ \u0026#34;${fileDirname}\\\\*.c\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\bin\\\\${fileBasenameNoExtension}.exe\u0026#34;,//這裡意思產生的二進位程式碼會放入目前檔案的 bin 資料夾中，我們需要自己新建一個 bin 資料夾 \u0026#34;-g\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;presentation\u0026#34;: { \u0026#34;echo\u0026#34;: true, \u0026#34;reveal\u0026#34;: \u0026#34;always\u0026#34;, // 執行任務時是否跳到終端面板，可以為 always，silent，never。具體參見 VSC 的文檔 \u0026#34;focus\u0026#34;: true, // 設為 true 後可以使執行 task 時焦點聚集在終端，但對編譯 C/C++ 來說，設為 true 沒有意義 \u0026#34;panel\u0026#34;: \u0026#34;shared\u0026#34; // 不同的檔案的編譯資訊共享一個終端面板 }, \u0026#34;detail\u0026#34;: \u0026#34;調試器生成的任務。\u0026#34; } ], \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34; } 至此設置工作基本結束，vscode 有許多好用的插件可以自己探索，未來也會在寫一篇文章推荐一些好用的插件\n","date":"2021-11-07T23:32:26+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/6/","title":"VsCode 配置 C 語言環境"},{"content":" 該文章使用 Google 翻譯處理。\n正文 安裝完成 VS Code 和 Python 並配置環境變量後\n開啟 VS Code，進入拓展搜尋並下載 Python\n在資源管理器新建一個 Python 原始檔 (.py) 後，資源管理器會在.vscode 資料夾下產生 setting.json 檔案（若沒有自動產生可自行建立）\n開啟 setting.json 文件，並替換為以下程式碼\n{ \u0026#34;python.linting.flake8Enabled\u0026#34;: true, \u0026#34;python.linting.flake8Args\u0026#34;: [\u0026#34;--max-line-length=248\u0026#34;], \u0026#34;python.linting.pylintEnabled\u0026#34;: false } 此時回到 python 文件，VS Code 右下會彈出警告，點擊下載\n按 CTRL+SHIFT+P 鍵，輸入 Python: Select Interpreter (即 Python：選擇編譯器)\n然後選擇您下載的編譯器即可\n如果 .vscode 資料夾下有 launch.json 文件，需要在該文件的 configurations 中加入以下程式碼\n{ \u0026#34;name\u0026#34;: \u0026#34;Python: 目前文件\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${file}\u0026#34;, \u0026#34;console\u0026#34;: \u0026#34;integratedTerminal\u0026#34; } 參考文章 VsCode 配置 Python 環境小白教程\nVSCode 配置 Python 教程\n","date":"2021-11-07T11:28:58+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/5/","title":"VsCode 配置 Python 環境"},{"content":" 該文章使用 Google 翻譯處理。\n該文章由 Hiyoung 編寫\nmailto：可以自動調用當前系統默認的郵件客戶端，並自動填充收件人、抄送人、密送人、主題、內容。\n參數說明:\nmailto： 收件人，多個以;分隔\ncc： 抄送人，多個以;分隔\nbcc： 密送人，多以;分隔\nsubject： 主題\nbody： 內容\n各參數間用\u0026amp;連接即可\n例如：\u0026lt;a mailto:***@***.com?subject=this is subject\u0026amp;body=this is body\u0026gt;…\u0026lt;a\u0026gt;\n注：在 elementor 中應在文本編輯器的超鏈接選項中直接填寫 mailto:***@***.com?subject=this is subject\u0026amp;body=this is body 即可\n","date":"2021-11-06T17:05:36+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/4/","title":"如何自動呼叫目前系統預設的郵件用戶端"},{"content":" 該文章使用 Google 翻譯處理。\n正文 首先到待嵌入的視頻將鼠標移到分享按鈕上（不用點擊）\n然後移到嵌入代碼並複制\n（本例代碼如下）\n\u0026lt;iframe src=\u0026#34;//player.bilibili.com/player.html?aid=583631611\u0026amp;bvid=BV1Tz4y1X7Bg\u0026amp;cid=206708397\u0026amp;page=1\u0026#34; scrolling=\u0026#34;no\u0026#34; border=\u0026#34;0\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; 我們需要這串程式碼中的「aid」和「cid」部分（即 aid=583631611 和 cid=206708397 ）\n然後將 aid 和 cid 填入下方代碼的對應位置\n\u0026lt;div style=\u0026#34;position: relative; padding: 30% 45%;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;position: absolute; width: 100%; height: 100%; left: 0; top: 0;\u0026#34; src=\u0026#34;https://player.bilibili.com/player.html?cid=206708397\u0026amp;aid=583631611\u0026amp;page=1\u0026amp;as_wide=1\u0026amp;high_quality=1\u0026amp;danmaku=0\u0026#34; frameborder=\u0026#34;no\u0026#34; scrolling=\u0026#34;no\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; （以上代碼中 aid 和 cid 已替換）\n在寫文章的過程若插入影片只需將區塊設為「自訂 HTML」然後把替換好aid和cid的程式碼拷貝過去即可\n如下為示例視頻\n參考文章 關於博客園內嵌入bilibili視頻\n","date":"2021-11-06T16:43:20+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/3/","title":"WordPress 嵌入 BiLiBiLi 影片說明"},{"content":" 該文章使用 Google 翻譯處理。\n預設情況下，WordPress 允許作者查看您網站媒體庫中的所有圖像。允許作者查看媒體庫中的所有檔案。 他們還可以查看由管理員 ， 編輯或其他作者上傳的圖像。\n對於許多網站而言，這可能並不重要。 但是，如果您運行一個多作者網站 ，則可能需要更改它。\n首先，進入 網站根目錄/wp-content/themes/您目前使用的主題名稱/\n找到 functions.php 檔案並編輯，在末尾插入如下程式碼即可\n// Limit media library access add_filter( \u0026#39;ajax_query_attachments_args\u0026#39;, \u0026#39;wpb_show_current_user_attachments\u0026#39; ); function wpb_show_current_user_attachments( $query ) { $user_id = get_current_user_id(); if ( $user_id \u0026amp;\u0026amp; !current_user_can(\u0026#39;activate_plugins\u0026#39;) \u0026amp;\u0026amp; !current_user_can(\u0026#39;edit_others_posts \u0026#39;) ) { $query[\u0026#39;author\u0026#39;] = $user_id; } return $query; } 參考文章 如何限制媒體庫對 WordPress 中使用者自己上傳的內容的訪問\n","date":"2021-11-06T14:31:04+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/2/","title":"WordPress 限制使用者存取媒體庫"},{"content":" 該文章使用 Google 翻譯處理。\n歡迎使用 WordPress。這是您的第一篇文章。編輯或刪除它，然後開始寫作吧！\n","date":"2021-11-06T14:15:19+08:00","permalink":"https://blog.yexca.net/zh-tw/archives/1/","title":"Hello World！"}]